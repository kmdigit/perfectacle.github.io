<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>오늘도 끄적끄적</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://perfectacle.github.io/"/>
  <updated>2019-05-06T17:01:09.965Z</updated>
  <id>https://perfectacle.github.io/</id>
  
  <author>
    <name>양권성</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>(JVM) Garbage Collection Basic</title>
    <link href="https://perfectacle.github.io/2019/05/07/jvm-gc-basic/"/>
    <id>https://perfectacle.github.io/2019/05/07/jvm-gc-basic/</id>
    <published>2019-05-06T16:43:52.000Z</published>
    <updated>2019-05-06T17:01:09.965Z</updated>
    
    <content type="html"><![CDATA[<p><img src="thumb.png" alt="PermGen은 자바 8에서 Metaspcae로 대체됐다. 이미지 출처: https://help.sap.com/">  </p><h2 id="읽기-전-주의사항-그림을-보는-법"><a href="#읽기-전-주의사항-그림을-보는-법" class="headerlink" title="읽기 전 주의사항(그림을 보는 법)"></a>읽기 전 주의사항(그림을 보는 법)</h2><p>그림을 그리다보니 Stack에 있는 동그라미 모양과 힙 메모리에 있는 동그라미 모양이 동일한 그림들이 많이 있습니다.<br>이건 <strong>둘이 동일한 메모리를 의미하는 게 아니라 그냥 스택에서 힙을 참조</strong>한다는 걸 그린 건데,<br>사실 둘의 모양을 다르게 그려야하는데 아무 생각없이 복붙해서 그리다보니 이렇게 그리게 되었고…<br>되돌리기에는 너무 많이 그림을 그려놔서(히스토리 추적이 안 되게 막 그려서…) 귀챠니즘으로 인해 그림을 수정하지 않았습니다.<br>이 점 참고하셔서 보시길 바랍니다!</p><h2 id="들어가기에-앞서"><a href="#들어가기에-앞서" class="headerlink" title="들어가기에 앞서"></a>들어가기에 앞서</h2><p><img src="optimizing-java.jpeg" alt=""><br>이 글은 이일웅 님께서 번역하신 <a href="https://book.naver.com/bookdb/book_detail.nhn?bid=14796595" rel="external nofollow noopener noreferrer" target="_blank">자바 최적화</a>란 책을 읽던 도중 공부한 내용을 정리한 글입니다.<br>절대 해당 책의 홍보는 아니며 좋은 책을 써준 사람과 번역해주신 분께 진심으로 감사하는 마음에 썼습니다. </p><p>자바는 C언어와 달리 프로그래머가 일일이 쓰지 않는 메모리(가비지)를 회수할 필요가 없게 끔 가비지 컬렉터가 알아서 열일한다.<br>자바의 모든 가비지 컬렉션에는 Stop the World(어플리케이션 스레드를 모두 멈추기 때문에 어플리케이션이 멈추게 된다.)가 발생하고 GC 쓰레드만 열일하게 된다.<br><img src="stop-the-world.png" alt="죠죠의 기묘한 모험이 떠오르는 건 왜일까..."><br>저수준 세부를 일일이 신경쓰지 않는 대가로 저수준 제어권을 포기한다는 사상이 자바의 핵심이다.</p><blockquote><p>자바는 블루 컬러(주로 생산직에 종사하는 육체 노동자) 언어입니다.<br>  박사 학위 논문 주제가 아니라 일을 하려고 만든 언어죠.<br>  — 제임스 고슬링(자바의 아버지) —</p></blockquote><p>즉, 일일이 메모리 해제하는 걸 ‘박사 학위 논문 주제’ 급의 어려운 일이라고 자바에서 여기는 것이다.<br>이런 어려운 일은 우리가 할테니 너희는 일을 해라!(비즈니스 로직이나 짜라!) 이런 뉘앙스 같다.</p><p>GC는 아래 두 가지 원칙을 준수해야한다. (프로그래머가 일일이 메모리 해제하다간 이런 유형의 휴먼 에러가 발생한다는 걸 보여준다.)</p><ul><li>반드시 모든 가비지(쓰지 않는 메모리)를 수집(free)해야한다.<br>메모리만 엄~청 빵빵하다면 가비지가 많더라도 굳이 메모리 해제할 필요가 없다.<br>사실 GC도 메모리가 부족할 때만 수행한다.</li><li>살아있는 객체(접근 가능한 객체)는 절대로 수집해선 안 된다.<br>C언어에서는 살아있는 객체(접근 가능한 객체)를 해제하면 Dangling pointer가 만들어지고, 어플리케이션이 뻗거나 해당 메모리에 다른 데이터가 할당돼서 해당 데이터를 더럽히는 등의 버그가 발생하게 된다.<br>자바에서는 살아있는 객체를 수집해가면 나중에 참조하는 쪽에서 NPE(NullPointerException) 등등이 발생할 가능성이 높다.</li></ul><h2 id="Mark-and-Sweep-Algorithm"><a href="#Mark-and-Sweep-Algorithm" class="headerlink" title="Mark and Sweep Algorithm"></a>Mark and Sweep Algorithm</h2><p>자바의 GC 알고리듬의 기본은 Mark(살아있는 객체를 표시) and Sweep(쓸어담기) 알고리듬이다.</p><p><img src="mark-and-sweep-01.png" alt="GC 루트(스택 프레임, 전역 객체 등등과 같이 메모리 풀 외부에서 내부를 가리키는 포인터)로부터 살아있는 객체(접근 가능한 객체)를 찾는다."><br><img src="mark-and-sweep-02.png" alt="살아있는 객체를 찾으면 mark bit를 true(혹은 1)로 세팅한다."><br><img src="mark-and-sweep-03.png" alt="모든 객체에 대해 마크가 끝났으면 이제 mark bit가 false(혹은 0)인 객체를 찾는다."><br><img src="mark-and-sweep-04.png" alt="mark bit가 false(혹은 0)인 객체는 죽은 객체(접근 불가능한 객체)이므로 가비지 컬렉터가 수거해간다."></p><h2 id="Weak-Generational-가설"><a href="#Weak-Generational-가설" class="headerlink" title="Weak Generational 가설"></a>Weak Generational 가설</h2><blockquote><p>JVM 및 유사 소프트웨어에서 객체 수명은 이원적 분포 양상을 보인다.<br>대부분의 객체는 아주 짧은 시간만 살아있지만, 나머지 객체는 기대 수명이 훨씬 길다.</p></blockquote><p>이 법칙은 사람들이 실제 실험과 경험을 토대로 얻어냈다.<br>따라서 GC의 대상인 힙은 아래 두 가지가 핵심이라는 결론이 나왔다.</p><ul><li>젊은 객체를 빠르게 수집할 수 있도록 설계해야한다.</li><li>늙은 객체와 단명 객체를 떼어놓는 게 가장 좋다.</li></ul><p>Hotspot VM은 Weak Generational 가설을 활용해 아래와 같은 규칙을 만들었다.</p><ul><li>객체마다 generational count(객체가 지금까지 무사통과한 가비지 컬렉션 횟수)를 센다.</li><li>새로운 객체는 Young Generation이라는 공간에 생성된다.</li><li>장수했다고 할 정도로 충분히 오래 살아남은 객체들은 별도의 메모리 영역(Old Generation 또는 Tenured Generation)에 보관된다.</li></ul><p>또한 Weak Generational 가설 중에 <strong>‘늙은 객체가 젊은 객체를 참조할 일은 거의 없다.’</strong>는 내용도 있는데 아예 없는 건 아니므로<br>Hotspot VM에서는 카드 테이블(JVM이 관리하는 바이트 배열로 각 요소는 Old Generation 공간의 512 바이트 영역을 가리킨다.)이라는 자료구조에 늙은 객체가 젊은 객체를 참조하는 정보를 기록한다.<br>따라서 Young Generation의 GC가 수행될 때 늙은 객체가 젊은 객체를 참조하는지도 확인해봐야한다.<br>하지만 이 때는 늙은 객체를 전부 뒤져보는 게 아니라 카드 테이블만 뒤져보면 돼서 GC의 수행 속도를 높여준다.</p><p><img src="c-01.png" alt="또한 메모리의 raw address를 가지고 데이터에 접근(역참조) 가능한 C언어 같은 언어는 이렇게 이분법적으로 메모리 영역을 나눈 구조와 맞지 않는다."><br><img src="c-02.png" alt="Young Generation에서 Old Generation으로 이동한 데이터는 메모리의 raw address도 바뀔텐데, 해당 raw address로 역참조를 했을 때 메모리 재할당으로 인해 다른 값이 튀어나올 가능성이 높기 때문이다."><br>다행히 자바는 메모리의 raw address를 사용하지도 않고, offset 연산자(. 연산자)만으로 필드나 메서드에 액세스 할 수 있기 때문에 이런 문제로부터 자유롭다.</p><h2 id="Young-Generation"><a href="#Young-Generation" class="headerlink" title="Young Generation"></a>Young Generation</h2><p>Weak Generational 가설에 따라 단명하는 젊은 객체들만 모아놓은 공간이다.<br>대부분의 객체가 Young Generation에서 사망하시고, 새로 생성된 객체가 할당되기 때문에 GC가 자주 일어나는 영역이다.<br>GC가 일어나는 동안 Stop the World가 발생하는데 이 빈도가 매우 잦기 때문에 Young Generation의 GC는 수행 시간이 짧아야한다.<br>수행 시간이 짧으려면 수거해가는 객체의 수를 줄이면 되고, 객체의 수를 줄이려면 영역의 사이즈를 적당히 줄이면 된다.<br>수행 시간이 짧은 GC이기 때문에 Minor GC라고 부르는 게 아닐까?</p><p>Young Generation 사이즈를 지정하는 JVM flag는 -XX:NewSize와 -XX:MaxNewSize이며<br>-XX:NewRatio 속성을 통해 Old Generation 사이즈와 Young Generation 사이즈의 비율을 정할 수 있다.<br>예를 들어 -XX:NewRatio=3으로 지정하면 1:3=Young:Old 라고 보면 된다.<br>(Young은 힙 메모리의 1/4를 먹고, Old는 힙 메모리의 3/4를 먹게 되는 것이다.)  </p><blockquote><p>The parameters NewSize and MaxNewSize bound the young generation size from below and above.<br>Setting these to the same value fixes the young generation,<br>just as setting -Xms and -Xmx to the same value fixes the total heap size.<br>This is useful for tuning the young generation at a finer granularity than the integral multiples allowed by NewRatio.<br><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/sizing.html" rel="external nofollow noopener noreferrer" target="_blank">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/sizing.html</a></p></blockquote><p>-XX:NewRatio 파라미터보다는 -XX:NewSize와 -XX:MaxNewSize의 사이즈를 동일하게 설정하는 게 튜닝하는데 더 좋다고 한다.<br>아마 동일하게 설정하는 이유는 해당 영역의 사이즈가 동적으로 줄어들고 늘어나게 되면, GC에도 영향을 미치고 기타 Ratio 관련 설정을 재계산해야되기 때문에 성능에 영향을 미치지 않기 때문 아닐까…?</p><p>또한 Young Generation의 GC는 자주 일어나기 때문에 수행 시간이 매우 짧아야하니 적어도 Old Generation의 사이즈보다 적게 할당하는 게 일반적이라고 한다.<br>다만 객체의 수명이 긴 객체들이 많거나 새로운 객체의 할당이 별로 없는 객체의 경우는 Young Generation의 사이즈를 좀 더 과감하게 줄이는 등 케이스 바이 케이스로 사이즈를 정해야할 것 같다.<br>이 모든 결정은 추측이 아닌 모니터링을 통해 할당 비율이라던지 기타 등등의 데이터들을 수치화해서 정확한 데이터 기반으로 의사 결정을 내려야할 것이다. <del>(말이 쉽지 ㅠㅠ 어떻게 하는지도 모른다…)</del></p><h3 id="Eden-Space"><a href="#Eden-Space" class="headerlink" title="Eden Space"></a>Eden Space</h3><p>Young Generation의 일부분이다.<br><img src="eden-space-01.png" alt="새롭게 생성된 객체의 용량이 Eden Space의 용량보다 큰 경우를 제외하고는 Eden 영역에 할당된다."><br><img src="eden-space-02.png" alt="그러다가 새롭게 할당할 객체의 메모리 확보를 하지 못한 경우, 즉 Eden 영역이 꽉 찬 경우에 Minor GC를 수행하게 된다."><br><img src="eden-space-03.png" alt="이 때 GC를 수행하게 되면 메모리 단편화가 생기게 되고 이로 인해 객체를 할당할 전체적인 용량은 확보됐지만 연속된 메모리 공간이 없게 된다."><br>OS 레벨에서는 연속된 메모리 공간에 할당하지 않고 쪼개서 할당해도 되긴 하지만 할당하는 데도 오랜 시간이 걸리고, 데이터를 불러올 때도 순차적인 접근이 아니기 때문에 오래 걸리게 된다.<br>또한 JVM의 메모리 할당은 <a href="#알아두면-좋을-상식">알아두면 좋을 상식</a>에도 나오다 싶이 bump-the-pointer라는 기술을 써서 저렇게 중간에 메모리를 할당하는 일은 없다.<br><img src="eden-space-04.png" alt="아니면 GC 이후에 메모리 Compaction을 수행해야하기 때문에 오버헤드가 발생할 수 밖에 없다.">  </p><h3 id="Survivor-Space"><a href="#Survivor-Space" class="headerlink" title="Survivor Space"></a>Survivor Space</h3><p>위에서 언급한 Eden 영역에서 GC로 인해 생기는 오버헤드를 줄이고자 생긴 영역이다.<br>이 영역 또한 Young Generaion의 일부이다.<br>Survivor 영역은 동일한 사이즈의 두 개의 영역으로 구분되는데 각각의 이름은 from과 to이다.<br>(VisualVM 같은 모니터링 툴에는 S0, S1으로 표시되곤 한다.)<br><img src="survivor-space-01.png" alt="Eden 영역에서 생존한 객체들이 Survivor 영역의 연속된 메모리 공간으로 넘어오게 되고"><br><img src="survivor-space-02.png" alt="Eden 영역은 싹 비우게 됨으로써 Eden 영역의 제일 처음부터 할당하면 되므로 Eden 영역의 메모리 단편화 문제를 해결했다.">  </p><p>또한 -XX:SurvivorRatio 속성을 통해 Eden Space 사이즈와 Survivor Generation 사이즈의 비율을 정할 수 있다.<br>예를 들어 -XX:SurvivorRatio=6으로 지정하면 1:6=Survivor:Eden 라고 보면 된다.<br>(Suivovr는 Young Generation의 1/7를 먹고, Eden은 Young Generation의 6/7를 먹게 되는 것이다.)<br>즉, 두 Survivor 영역의 합보다 Eden 영역의 메모리가 더 크다.<br>(생존해서 Survivor 영역에 존재하는 객체보다 새롭게 생성돼서 Eden 영역에 할당되는 객체가 훨씬 많으므로…)</p><blockquote><p>You can use the parameter SurvivorRatio can be used to tune the size of the survivor spaces, but this is often not important for performance.<br>  <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/sizing.html" rel="external nofollow noopener noreferrer" target="_blank">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/sizing.html</a></p></blockquote><p>퍼포먼스에 영향을 주는 경우는 드물다고 적혀있지 않으니 굳이 쓸 필요는 없을 것 같다.</p><h4 id="Survivor-Space는-왜-2개일까"><a href="#Survivor-Space는-왜-2개일까" class="headerlink" title="Survivor Space는 왜 2개일까?"></a>Survivor Space는 왜 2개일까?</h4><p><img src="survivor-space-03.png" alt="그 이유는 Minor GC의 대상이 Eden에만 국한되는 게 아니라 Survivor 영역까지 Minor GC를 하기 때문이다."><br><img src="survivor-space-04.png" alt="Survivor 영역을 Minor GC를 수행하면 어떻게 될까? Eden 영역만 존재할 때와 마찬가지로 Survivor 영역에도 메모리 단편화가 존재하게 된다.">  </p><p><a href="#알아두면-좋을-상식">알아두면 좋을 상식</a>에도 나오다 싶이 bump-the-pointer라는 기술을 써서 중간에 빈 공간이 있더라도 해당 공간에 할당하지 않는다.<br>그럼 Survivor Space의 단편화를 없애려면 어떻게 하면 될까?<br><img src="survivor-space-05.png" alt="Eden 영역에서 Survivor 영역을 만든 것과 같이 새로운 영역을 추가하면 된다!"><br>따라서 새롭게 영역을 추가하다보니 Survivor Space가 두 개가 된 거다.</p><h3 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h3><p>그럼 이제 Young Generation에서 일어나는 Minor GC에 대해서 알아보자.<br>(물론 JVM 플래그를 어떻게 주느냐에 따라서 Minor GC의 알고리듬이 달라질 수 있고, 여기서 설명하는 Minor GC의 알고리듬은 아주 간단하고 기본적인 수준에서 설명하고 있다.)</p><p><img src="minor-gc-01.png" alt="새롭게 생성된 객체는 전부 Eden Space에 할당된다. 이 때 객체의 generational count는 0이다."><br><img src="minor-gc-02.png" alt="새롭게 생성된 객체를 또 할당하려는데 Eden Space에 할당할 공간이 없으면 Minor GC를 수행하게 된다. 이제부터 Stop the World의 시작이다."><br><img src="minor-gc-03.png" alt="Eden 영역에 할당된 객체를 순회하면서 GC 루트로부터 접근 가능한 객체만 mark를 한다."><br><img src="minor-gc-04.png" alt="생존한 모든 객체(mark 당한 객체)는 Survivor Space로 복사한다."><br><img src="minor-gc-05.png" alt="GC로부터 살아남은 객체는 이제 generational count가 1로 증가한다. (이렇게 generational count를 1씩 늘리는 프로세스를 aging이라고 부른다... 나이를 먹어가는 ㅠㅠ)"><br><img src="minor-gc-06.png" alt="Eden Space를 비운다. (Sweep) 이제 Stop the World가 끝났다."><br><img src="minor-gc-07.png" alt="이제 Eden Space의 공간 확보가 됐으니 새롭게 생성된 객체를 Eden Space에 할당한다."><br><img src="minor-gc-08.png" alt="새롭게 생성된 객체를 또 할당하려는데 Eden Space에 할당할 공간이 없으면 Minor GC를 수행하게 된다. (Stop the World의 시작)"><br><img src="minor-gc-09.png" alt="이번에는 Eden 영역과 더불어 Survivor Space에 할당된 객체를 순회하면서 GC 루트로부터 접근 가능한 객체만 mark를 한다."><br><img src="minor-gc-10.png" alt="Survivor Space에서 생존하지 못한(mark 당하지 않은) 모든 객체를 수거해간다. (Sweep)"><br><img src="minor-gc-11.png" alt="이 때 Survivor Space에서 생존한 객체는 generational count가 2로 증가한다."><br><img src="minor-gc-12.png" alt="Eden Space에서 mark된(생존한) 객체는 Survivor Space로 복사된다."><br><img src="minor-gc-13.png" alt="이 때 Eden에서 복사되는 객체는 generational count가 1로 증가한다."><br><img src="minor-gc-14.png" alt="이제 Eden Space를 비워준다, Sweep. (Stop the World의 끝)"><br><img src="minor-gc-15.png" alt="이제 새로운 객체를 할당하면 된다."><br><img src="minor-gc-16.png" alt="위 과정들을 반복하다가 또 Eden Space가 꽉 차서 GC를 수행하게 됐다고 가정하자. (Stop the world의 시작)"><br><img src="minor-gc-17.png" alt="모든 과정을 마치고 이제 Eden Space에서 생존한 객체들을 Survivor Space로 옮기려고 했더니 Survivor Space에 연속된 메모리 공간을 확보하지 못해서 더 이상 메모리 할당이 불가능하다고 가정해보자."><br><img src="minor-gc-18.png" alt="이 때 From Survivor Space에서 생존한 모든 객체들을 To Survivor Space의 연속된 공간에 먼저 옮기고, 그 후에 Eden Space에서 생존한 객체를 To Survivor Space의 연속된 공간에 옮긴다."><br>To Survivor Space에 Eden Space에 있는 내용보다 From Survivor Space에 있는 내용을 먼저 복사하는 이유는<br>generational count가 적은 객체(Eden Space에 거주중인 객체들)보다 generational count가 높은 객체(From Survivor Space에 거주중인 객체들)의<br>수명이 더 길 가능성이 높기 때문이다. (Weak Generational 가설에 의해…)<br><img src="minor-gc-19.png" alt="생존한 모든 객체를 옮겼으므로 From Survivor Space와 Eden Space를 비운다."><br><img src="minor-gc-20.png" alt="기존 From Survivor Space의 역할을 To Survivor Space가 대신하게 됐으므로 둘의 이름을 바꾼다. (Stop the World의 끝)"><br><img src="minor-gc-21.png" alt="GC가 끝났으므로 새로운 객체를 Eden Space에 할당한다."><br><img src="minor-gc-22.png" alt="위 과정을 반복하다가 생존을 반복한 From Survivor Space에 있는 객체가 적당히 나이를 먹었다고 가정해보자."><br><img src="minor-gc-23.png" alt="그럼 해당 객체는 Promotion(승진)을 한다."><br><img src="minor-gc-24.png" alt="그러다 다시 Minor GC를 해야되게 됐다."><br><img src="minor-gc-25.png" alt="이 경우에는 흔치 않게 Old Generation에서 Young Generation을 참조하고 있어서 GC 로직이 복잡해보이는데 간단하게 카드 테이블에 저장된 객체만 추가로 검사해서 Old Generation에서 Young Generation으로 참조 중인 객체를 쉽고 빠르게 찾을 수 있다.">  </p><h4 id="Promotion"><a href="#Promotion" class="headerlink" title="Promotion"></a>Promotion</h4><p>아래 나오는 그림에서 동그라미 안의 숫자는 객체의 나이(객체가 GC로부터 살아남은 횟수)를 의미한다.<br><img src="promotion-01.png" alt="Promotion(승진)은 Young Generation에서 적당히 나이를 먹어서(GC로 부터 살아남아서 계속해서 generational count가 늘어나서 적당한 generational count가 됐음을 의미)"><br><img src="promotion-02.png" alt="이제 Old Generation으로 갈 나이가 됐으니 Old Generation으로 이동하는 걸 의미한다."><br>generational count가 어느정도 있으려면<del>(짬밥을 어느정도 먹었으려면)</del> 당연히 Survivor Space에 있는 객체가 이동됨을 의미한다.</p><p>적당한 나이는 -XX:InitialTenuringThreshold와 -XX:MaxTenuringThreshold 파라미터로 정할 수 있다.<br>(Old 영역으로 승진하는 객체의 갯수나 비율이 많아지면 자동으로 TenuringThreshold를 늘리는 원리인지 뭔지 잘 모르겠다…)    </p><h4 id="Premature-Promotion"><a href="#Premature-Promotion" class="headerlink" title="Premature Promotion"></a>Premature Promotion</h4><p>적당한 나이(generational count)를 먹지 않았는데 어쩔 수 없이 Old Generation으로 이동하는 행위를 premature promotion(조기 승진)이라고 부른다.<br>아래 나오는 그림에서 동그라미 안의 숫자는 객체의 나이(객체가 GC로부터 살아남은 횟수)를 의미한다.<br><img src="premature-promotion-01.png" alt="주로 메모리 할당이 잦다보니 Survivor Space에 적당한 공간이 없어서"><br><img src="premature-promotion-02.png" alt="나이를 먹지 않았음에도 Old Generation으로 옮겨지는 경우도 Premature Promotion이고,"><br><img src="premature-promotion-03.png" alt="새롭게 할당될 객체의 용량이 Eden Space의 용량보다 큰 경우에는"><br><img src="premature-promotion-04.png" alt="바로 Old Generation에 할당되게 되는데 이 경우에도 Premature Promotion이고,"><br><img src="premature-promotion-05.png" alt="정상적으로 GC가 이루어지면 From Survivor Space가 가득차서 위와 같이 생존된 객체를 To Survivor Space로 옮겨야하는데"><br><img src="premature-promotion-06.png" alt="-XX:TargetSurvivorRatio(기본값 50)에 의해 To Survivor Space를 50% 밖에 쓰지 못하는 상황이 된다. (물론 이후에 To Survivor Space가 가득찰 때까지 해당 영역은 계속해서 사용할 수 있는데 From Survivor Space에서 To Survivor Space로 객체를 옮길 때만 -XX:TargetSurvivorRatio 값이 적용된다.)"><br><img src="premature-promotion-07.png" alt="이럴 때 적당히 나이를 먹지 않은 객체들이 나이순으로 Old Generation으로 이동하게 되는 경우도 Premature Promotion에 해당한다."></p><p>이 premature promotion의 경우에는 Old Generation에 놓기 때문에 Major GC 혹은 Full GC가 일어나기 전에는 회수해가지 않으며<br>적당한 나이를 먹지 않고 와서 단명할 가능성이 높음에도 불구하고 쓸데없이 Old Generation을 차지하고 있기 때문에<br>Major GC 혹은 Full GC의 발생 빈도를 늘려 어플리케이션 전반에 영향을 미치기 때문에 적절하게 Young Generation Space의 사이즈를 정하는 게 중요하다.</p><h2 id="Old-Generation"><a href="#Old-Generation" class="headerlink" title="Old Generation"></a>Old Generation</h2><p>객체가 적당한 나이를 먹거나 조기 승진을 통해 넘어온 객체들이 존재하는 영역이다.<br>Tenure Generation이라고도 부른다.<br>해당 영역에 존재하는 객체들을 Young Generation에 있는 객체들보다 회수당할 가능성이 적다는 게 Weak Generational 가설이다.<br>또한 대부분의 객체가 Young Generation에서 사망하시기 때문에 Old Generation으로 오는 객체는 Young Generation에 할당되는 객체의 비율에 비해 현저히 낮다.</p><h3 id="Major-GC"><a href="#Major-GC" class="headerlink" title="Major GC"></a>Major GC</h3><p>Major GC 역시 Old Generation이 꽉 찼을 때 수행된다.<br>기본적으로 Old Generation은 메모리 할당률이 낮기 때문에 GC가 일어나는 빈도가 적다.<br>또한 대부분 Old Generation은 Young Generation 보다 용량을 크게 잡기 때문에 객체의 갯수도 많아서 GC 시간이 길다.<br>GC의 시간이 길다는 것은 그만큼 Stop the World, 어플리케이션이 멈추는 시간도 길다는 의미고 그런 의미에서 Major GC(주요한 GC)라고 이름을 붙인 게 아닐까 싶다.<br>또한 Old Generation은 Young Generation과 같이 Survivor Space가 존재하는 게 아니기 때문에 메모리 단편화도 신경써야하고 관리해야할 객체도 많다보니 훨씬 알고리듬이 복잡해진다.<br>이에 대해선 다음에 글을 써볼 예정이다.</p><h2 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h2><p>Minor GC + Major GC를 Full GC라고 부른다.<br>정확히 언제 일어나는지 모르겠지만 Old Generation GC에 대해 좀 더 자세히 공부하고 다시 작성해야겠다.</p><h2 id="Permanent-Generation"><a href="#Permanent-Generation" class="headerlink" title="Permanent Generation"></a>Permanent Generation</h2><p>JVM의 Method Area를 Hotspot VM에서 Permanent Generation(줄여서 PermGen)으로 부르기 시작하면서 다른 VM에서도 PermGen이라고 부르는 것 같다.<br>PermGen은 자바 8에서 사라졌다.<br>PermGen에는 클래스의 메타데이터, 메서드의 메타데이터, 상수풀, static 변수 등등이 들어간다.<br>PermGen은 이름만 들어보면 Permanent(영구적인)가 들어가다보니 영구히 존재하는 데이터들만 저장될 거 같은데 필수는 아니지만 GC가 수행되기도 한다.<br>GC가 수행된다는 관점에서인지 이 영역을 힙 메모리로 보는 사람도 있는데 나는 클래스의 인스턴스가 저장되는 것도 아니고<br>-Xmx, -Xms와는 별개로 사이즈가 지정되다보니 힙메모리가 아니라고 생각하고 있다.<br>-XX:PermSize와 -XX:MaxPermSize로 사이즈를 지정할 수 있고, GC를 수행하지 않는다면 용량이 부족해질 수 있고 아래와 같은 OOME가 난다.<br><code>java.lang.OutOfMemoryError: PermGen space</code><br>이러한 에러가 나는 이유는 여러가지가 있는데 대표적으로 다음과 같다.</p><ul><li>collection을 static으로 만들고 계속해서 요소를 추가하는 경우(이런 실수를 범하면 절대 안된다.)</li><li>서버를 재시작하지 않고 변경 내역을 바로바로 반영해주는 HotDeploy를 계속해서 사용하다보면 Class와 Method의 메타데이터가 계속해서 쌓이게 되는데<br>서버를 주기적으로 재시작해주지 않고, 계속해서 HotDeploy 하는 경우(실서버에서 이런 경우는 거의 없을 것이다.)</li></ul><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><p>자바 8부터 PermGen의 역할을 Metadata 영역에서 맡기 시작했고 Native 영역으로 옮겨졌다. (즉 OS에서 관리한다는 의미)<br>PermGen 중에 일부만 Metadata 영역에서 맡기 시작했고, 상수풀이나 static 변수는 Heap 메모리로 옮겨져왔다.<br>즉, 개발자가 실수하기 쉽거나 변경이 잦은 내용들은 힙 메모리로 끌고와서 GC의 대상이 되게 하고, 정말 변경이 될 가능성이 적은 내용들만 Native 영역으로 옮겨버렸다.<br>문제는 Native 영역은 dump를 떠도 안 나와서 분석하기 힘들다는데 이럴 일은 아마 거의 없을 것이다…<br>Metadata에 대한 관리는 OS에서 함으로 믿고 맡겨도 된다고 생각하지만(개발자가 직접하는 것보다 낫지 않을까?),<br>혹시 이 쪽을 튜닝해야하거나 OOME(java.lang.OutOfMemoryError: Metadata space)가 발생한 경우에는 -XX:MetaspaceSize와 -XX:MaxMetaspaceSize 파라미터를 사용해보자.</p><h2 id="OutOfMemoryException"><a href="#OutOfMemoryException" class="headerlink" title="OutOfMemoryException"></a>OutOfMemoryException</h2><p>주로 OOME라고 줄여부르며 메모리 공간이 부족해서 나는 예외로 어플리케이션 자체가 뻗는 현상이 발생한다.<br>이 예외가 발생했을 때는 메모리 릭(메모리 결함)이 발생한 경우이고 Heap 메모리나 PermGen(Metaspace) 등등의 영역이 부족할 때 발생하는데<br>어떤 메모리가 부족한 건지, 아니면 왜 이 오류가 났는지 Stacktrace를 찍고 사망한다.</p><p>여기서는 힙 메모리가 부족해서 OOME가 발생한 경우의 원인에 대해서만 설명하겠다.<br>우선 메모리가 부족하면 가비지 컬렉터는 힙메모리의 가비지 컬렉션을 수행한다.<br>가비지 컬렉션을 수행했음에도 불구하고 새로운 객체를 더이상 할당할 수 없는 경우에 OOME가 발생하게 된다.<br>이 때는 아주 급한 경우에는 일단 -Xmx와 -Xms로 메모리를 늘리고 보고,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError </span><br><span class="line">-XX:HeapDumpPath=<span class="variable">$&#123;PATH&#125;</span>/<span class="variable">$&#123;FILE_NAME&#125;</span>.hprof</span><br></pre></td></tr></table></figure></p><p><img src="mat.png" alt="위 두가지 설정을 주고 실행해서 재발하면 힙덤프를 생성하거나 아니면 jmap 등등으로 살아있는 서버의 힙덤프를 떠서 어디서 메모리 릭이 발생했는지 Eclipse MAT 등등으로 분석하거나"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-Dcom.sun.management.jmxremote</span><br><span class="line">-Dcom.sun.management.jmxremote.port=<span class="variable">$&#123;JMX_PORT&#125;</span></span><br><span class="line">-Dcom.sun.management.jmxremote.authenticate=<span class="literal">false</span></span><br><span class="line">-Dcom.sun.management.jmxremote.ssl=<span class="literal">false</span></span><br><span class="line">-Dcom.sun.management.jmxremote.rmi.port=<span class="variable">$&#123;RMI_PORT&#125;</span></span><br><span class="line">-Djava.rmi.server.hostname=<span class="variable">$&#123;HOST_NAME&#125;</span></span><br></pre></td></tr></table></figure><p><img src="visual-vm.png" alt="위 설정 등등을 줘서 VisualVM으로 서버에 실제로 떠있는 어플리케이션 등등을 모니터링하는 방법이 있다."></p><h2 id="알아두면-좋을-상식"><a href="#알아두면-좋을-상식" class="headerlink" title="알아두면 좋을 상식"></a>알아두면 좋을 상식</h2><ul><li>Hotspot VM의 GC는 Arena라는 메모리 영역에서 작동한다.</li><li>Hotspot VM은 시작 시 메모리를 유저 공간에 할당/관리한다.<br>따라서 힙 메모리를 관리할 때 시스템 콜을 하지 않으므로 커널 공간으로 컨텍스트 스위칭을 하지 않아서 성능 향상에 도움이 된다.</li><li>Hotspot VM은 할당된 메모리 가장 마지막의 다음 영역을 가리켜 연속된 빈 공간에 효율적으로 빠르게 할당하는 bump-the-pointer라는 기술을 사용했다.</li><li>Hotspot VM은 멀티 스레드 환경에서 객체를 할당할 때 스레드 간의 경합 등등의 문제를 줄이고자 TLAB(Thread Local Allocation Buffer)를 사용했다.<br>Eden Space를 여러 버퍼로 나누어 각 어플리케이션 스레드에게 할당함으로써 자기 자신이 사용해야 할 버퍼를 바로 찾게되고, 리소스를 공유해서 생기는 문제를 없애버렸다.<br>만약 본인에게 할당된 TLAB가 부족할 경우에는 크기를 동적으로 조정한다.</li></ul><h2 id="참조-링크"><a href="#참조-링크" class="headerlink" title="참조 링크"></a>참조 링크</h2><ul><li><a href="https://d2.naver.com/helloworld/1329" rel="external nofollow noopener noreferrer" target="_blank">Naver D2 - Java Garbage Collection</a>  </li><li><a href="https://d2.naver.com/helloworld/1230" rel="external nofollow noopener noreferrer" target="_blank">Naver D2 - JVM Internal</a>  </li><li><a href="https://www.youtube.com/watch?v=DoJr5QQYsl8" rel="external nofollow noopener noreferrer" target="_blank">The JVM and Java Garbage Collection - OLL Live (Recorded Webcast Event)</a>  </li><li><a href="https://starplatina.tistory.com/entry/JDK8%EC%97%90%EC%84%A0-PermGen%EC%9D%B4-%EC%99%84%EC%A0%84%ED%9E%88-%EC%82%AC%EB%9D%BC%EC%A7%80%EA%B3%A0-Metaspace%EA%B0%80-%EC%9D%B4%EB%A5%BC-%EB%8C%80%EC%8B%A0-%ED%95%A8" rel="external nofollow noopener noreferrer" target="_blank">JDK8에선 PermGen이 완전히 사라지고 Metaspace가 이를 대신 함.</a>  </li><li><a href="https://brunch.co.kr/@heracul/1" rel="external nofollow noopener noreferrer" target="_blank">JDK8 적용 후, 심각한 성능저하가 발생한다면?</a></li><li><a href="https://yckwon2nd.blogspot.com/2015/03/java8-permanent.html" rel="external nofollow noopener noreferrer" target="_blank">JAVA8 Permanent 영역은 어디로 가는가</a>  </li><li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/memleaks002.html" rel="external nofollow noopener noreferrer" target="_blank">Understand the OutOfMemoryError Exception - Oracle Docs</a>  </li><li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/sizing.html" rel="external nofollow noopener noreferrer" target="_blank">Sizing the Generations - Oracle Docs</a>  </li><li><a href="https://plumbr.io/blog/garbage-collection/minor-gc-vs-major-gc-vs-full-gc" rel="external nofollow noopener noreferrer" target="_blank">Minor GC vs Major GC vs Full GC</a>  </li><li><a href="https://blog.codecentric.de/en/2012/08/useful-jvm-flags-part-5-young-generation-garbage-collection/" rel="external nofollow noopener noreferrer" target="_blank">Useful JVM Flags – Part 5 (Young Generation Garbage Collection)</a>  </li></ul><p>그 외 더 많은 거 같은데 기억이 잘 나지 않는다…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;thumb.png&quot; alt=&quot;PermGen은 자바 8에서 Metaspcae로 대체됐다. 이미지 출처: https://help.sap.com/&quot;&gt;  &lt;/p&gt;
&lt;h2 id=&quot;읽기-전-주의사항-그림을-보는-법&quot;&gt;&lt;a href=&quot;#읽기
      
    
    </summary>
    
      <category term="Programming" scheme="https://perfectacle.github.io/categories/Programming/"/>
    
      <category term="Java" scheme="https://perfectacle.github.io/categories/Programming/Java/"/>
    
    
      <category term="Java" scheme="https://perfectacle.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://perfectacle.github.io/tags/JVM/"/>
    
      <category term="GC" scheme="https://perfectacle.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>(삽질기) SSH 터널링을 통해 원격지에 존재하는 도커 컨테이너 안의 JMX 모니터링하기</title>
    <link href="https://perfectacle.github.io/2019/05/05/jmx-monitoring-inside-docker-container-over-ssh-tunneling/"/>
    <id>https://perfectacle.github.io/2019/05/05/jmx-monitoring-inside-docker-container-over-ssh-tunneling/</id>
    <published>2019-05-04T23:36:13.000Z</published>
    <updated>2019-05-05T00:41:47.453Z</updated>
    
    <content type="html"><![CDATA[<p><img src="thumb.png" alt="네가 알던 로컬호스트가 아냐! (로컬호스트처럼 보이지만 실제론 원격지에 있는 서버에 붙었음을 의미)"></p><h2 id="들어가기에-앞서"><a href="#들어가기에-앞서" class="headerlink" title="들어가기에 앞서"></a>들어가기에 앞서</h2><p>JMX를 모니터링 하려면 <a href="https://visualvm.github.io/" rel="external nofollow noopener noreferrer" target="_blank">VisualVM</a>이나 JDK에 기본적으로 내장돼있는 <a href="http://openjdk.java.net/tools/svc/jconsole/" rel="external nofollow noopener noreferrer" target="_blank">JConsole</a>을 사용해야한다.</p><h2 id="로컬에서-JMX-모니터링하기"><a href="#로컬에서-JMX-모니터링하기" class="headerlink" title="로컬에서 JMX 모니터링하기"></a>로컬에서 JMX 모니터링하기</h2><p>우선 로컬에 어플리케이션을 띄우고 JMX 모니터링하기란 참 쉽다.<br>우선 자바 어플리케이션을 띄워보자.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar air.jar</span><br></pre></td></tr></table></figure></p><p><img src="01.png" alt="그리고 모니터링 툴을 보면 바로 해당 어플리케이션이 잡혀있다."></p><h2 id="도커-컨테이너-안의-JMX-모니터링-하기"><a href="#도커-컨테이너-안의-JMX-모니터링-하기" class="headerlink" title="도커 컨테이너 안의 JMX 모니터링 하기"></a>도커 컨테이너 안의 JMX 모니터링 하기</h2><p>우선 도커 이미지 파일부터 만들어야한다.<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">11</span>-jdk-slim</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /root</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">COPY build/libs/air.jar .</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">CMD (java \</span></span><br><span class="line"><span class="bash">          -Dcom.sun.management.jmxremote \</span></span><br><span class="line"><span class="bash">          -Dcom.sun.management.jmxremote.port=9090 \</span></span><br><span class="line"><span class="bash">          -Dcom.sun.management.jmxremote.authenticate=<span class="literal">false</span> \</span></span><br><span class="line"><span class="bash">          -Dcom.sun.management.jmxremote.ssl=<span class="literal">false</span> \</span></span><br><span class="line"><span class="bash">          -Dcom.sun.management.jmxremote.rmi.port=9090 \</span></span><br><span class="line"><span class="bash">          -Djava.rmi.server.hostname=localhost \</span></span><br><span class="line"><span class="bash">          -jar air.jar)</span></span><br></pre></td></tr></table></figure></p><p>jmxremote.port와 jmxremote.rmi.port를 달리 해도 되는데 그럼 docker container의 port 2개를 host os port 2개랑 바인딩해야한다.<br>그냥 둘을 하나로 통일하면 하나만 바인딩하면 되기 때문에 굳이 두 개로 해야할 필요성을 느끼진 못했다.<br>java.rmi.server.hostname에 로컬의 사설 IP(private ip)를 넣어도 되는데 굳이 귀찮게 그렇게 할 필요성도 느끼지 못했다.<br>또한 SSH Tunneling을 거치게 됐을 때 서버의 사설 IP를 적었을 때는 접속이 불가능했으므로 <strong>무조건 localhost라고 적어주자.</strong> </p><p>해당 이미지를 빌드하고 이제 이미지를 container로 띄워보자.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># JMX를 모니터링 하는 것이기 때문에 어플리케이션의 포트는 바인딩하지 않았다.</span></span><br><span class="line"><span class="comment"># JMX remote port(9090)와 다른 포트를 Host OS에 매핑하면 모니터링이 불가능하다.</span></span><br><span class="line"><span class="comment"># 9091:9090 이렇게 하면 못 붙는다 무조건 9090:9090(jmx remote port를 다르게 했다면 해당 포트를...)을 바인딩 해야한다.</span></span><br><span class="line"><span class="comment"># 혹시 jmx remote port와 jmx remote rmi port를 다르게 했다면 두 포트를 모두 바인딩 시켜줘야한다.</span></span><br><span class="line"><span class="comment"># jmx remote port가 9090이고 jmx remote rmi port가 9091이라면 -p 9090:9090 -p 9091:9091 이렇게 해줘야한다.</span></span><br><span class="line">docker run -p 9090:9090 air</span><br></pre></td></tr></table></figure></p><p>Host OS에 자바 어플리케이션이 뜬 게 아니라 컨테이너 안에서 뜬 거고, HostOS는 JMX remort port만 바인딩 된 거기 때문에 모니터링 툴을 보면 바로 잡혀있지 않다.<br><img src="02.png" alt="좌측 상단의 해당 버튼을 클릭해주자."><br><img src="03.png" alt="localhost와 jmx remote port를 입력해주고 적당히 보기 쉬운 이름으로 Display name에 채워주고 스크린샷을 따라서 작성한 후에 OK 버튼을 눌러주자."><br>만약 jmx remote port와 jmx remote rmi port를 다르게 했더라도 입력하는 포트는 jmx remote port를 입력해줘야한다.<br><img src="04.png" alt="성공적으로 불러와졌다."><br>아쉽지만 도커 컨테이너로 띄우게 되면 쓰레드 덤프는 떠지지만 힙 덤프는 안 떠진다.<br><strong>혹시 도커 컨테이너로 띄웠을 때도 힙 덤프를 뜨게 하려면 어떻게 해야하는지 댓글에 남겨주시면 정말 감사하겠습니다.</strong></p><h2 id="SSH-Tunneling을-통해-원격지의-JMX-모니터링하기"><a href="#SSH-Tunneling을-통해-원격지의-JMX-모니터링하기" class="headerlink" title="SSH Tunneling을 통해 원격지의 JMX 모니터링하기"></a>SSH Tunneling을 통해 원격지의 JMX 모니터링하기</h2><p>서버를 퍼블릭 존에 두는 건 매우 위험하다. (크래커가 직접 SSH로 붙을 가능성이 존재하거나 각종 공격에 직접적으로 노출되기 때문에…)<br>따라서 프라이빗 존에 둬야하는데 VPN을 쓸 경제적 여력이 안 되는 가난한 환경이나 VPN을 적용하지 않은 환경에서는 매우 귀찮아진다.<br><del>(우리 회사가 가난하다는 게 아니다.)</del><br><img src="aws-bastion-host.png" alt="따라서 퍼블릭 존에 Bastion Host를 두고 해당 Host를 경유해 프라이빗 존에 있는 서버에 접근하게 된다."><br><img src="aws-ssh-local-port-forwading.png" alt="이런 환경에서는 Bastion Host를 거쳐 SSH Tunneling의 일종인 Local Port Forwading을 해야한다."><br>기본적인 명령어는 위 사진에서 보는 바와 같고 명령어의 예시를 들어보겠다.  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># JMX remote port(9090)와 다른 포트를 Localhost에 매핑하면 모니터링이 불가능하다.</span></span><br><span class="line"><span class="comment"># 9091:$&#123;application_server_ip&#125;:9090 이렇게 하면 못 붙는다.</span></span><br><span class="line"><span class="comment"># 무조건 9090:$&#123;application_server_ip&#125;:9090(jmx remote port를 다르게 했다면 해당 포트를...)을 바인딩 해야한다.</span></span><br><span class="line">ssh -N -L 9090:<span class="variable">$&#123;application_server_ip&#125;</span>:9090 -i ~/.ssh/key.pem ec2-user@&#123;bastion_host_ip&#125;</span><br></pre></td></tr></table></figure><p>이번에도 역시 Host OS에 자바 어플리케이션이 뜬 게 아니라 원격지의 도커 컨테이너 안에서 뜬 거고, Localhost에는 JMX remort port만 바인딩 된 거기 때문에 모니터링 툴을 보면 바로 잡혀있지 않다.<br><img src="02.png" alt="좌측 상단의 해당 버튼을 클릭해주자."><br><img src="05.png" alt="localhost와 jmx remote port를 입력해주고 적당히 보기 쉬운 이름으로 Display name에 채워주고 스크린샷을 따라서 작성한 후에 OK 버튼을 눌러주자."><br><img src="06.png" alt="정상적으로 접속됐다."></p><p>JMX remote port(9090)와 다른 포트를 매핑하는 바람에 몇 시간을 삽질했는지 모르겠다…<br><strong>혹시 이거보다 더 간단하게 연결하는 방법이 있다면 댓글로 남겨주시면 정말 감사하겠습니다.</strong></p><h2 id="참조-링크"><a href="#참조-링크" class="headerlink" title="참조 링크"></a>참조 링크</h2><ul><li><a href="https://stackoverflow.com/questions/1609961/visualvm-over-ssh" rel="external nofollow noopener noreferrer" target="_blank">VisualVM over ssh</a>  </li><li><a href="https://www.popit.kr/docker-jmx-profiling-tip/" rel="external nofollow noopener noreferrer" target="_blank">Docker 안에 숨어 있는 Web application JMX profiling Tip</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;thumb.png&quot; alt=&quot;네가 알던 로컬호스트가 아냐! (로컬호스트처럼 보이지만 실제론 원격지에 있는 서버에 붙었음을 의미)&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;들어가기에-앞서&quot;&gt;&lt;a href=&quot;#들어가기에-앞서&quot; class=&quot;head
      
    
    </summary>
    
      <category term="Note" scheme="https://perfectacle.github.io/categories/Note/"/>
    
      <category term="삽질" scheme="https://perfectacle.github.io/categories/Note/%EC%82%BD%EC%A7%88/"/>
    
    
      <category term="JVM" scheme="https://perfectacle.github.io/tags/JVM/"/>
    
      <category term="JMX" scheme="https://perfectacle.github.io/tags/JMX/"/>
    
  </entry>
  
  <entry>
    <title>(Troubleshooting) Hibernate MultipleBagFetchException 정복하기</title>
    <link href="https://perfectacle.github.io/2019/05/01/hibernate-multiple-bag-fetch-exception/"/>
    <id>https://perfectacle.github.io/2019/05/01/hibernate-multiple-bag-fetch-exception/</id>
    <published>2019-05-01T11:04:41.000Z</published>
    <updated>2019-05-01T11:11:36.611Z</updated>
    
    <content type="html"><![CDATA[<p><img src="thumb.jpg" alt="이미지 출처: https://pgr21.com/pb/pb.php?id=humor&amp;no=166185"></p><h2 id="Trouble"><a href="#Trouble" class="headerlink" title="Trouble"></a>Trouble</h2><p>Spring Data JPA를 이용하다보면 종종 <code>org.hibernate.loader.MultipleBagFetchException: cannot simultaneously fetch multiple bags</code>이란 메세지를 보게 된다.<br>우선 어떤 상황에 나타나는지 한 번 살펴보자.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mother</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany</span>(mappedBy = <span class="string">"mother"</span>, cascade = CascadeType.ALL, fetch = FetchType.EAGER)</span><br><span class="line">    <span class="keyword">private</span> List&lt;Daughter&gt; daughters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany</span>(mappedBy = <span class="string">"mother"</span>, cascade = CascadeType.ALL, fetch = FetchType.EAGER)</span><br><span class="line">    <span class="keyword">private</span> List&lt;Son&gt; sons = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Builder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mother</span><span class="params">(<span class="keyword">final</span> Long id, <span class="keyword">final</span> List&lt;Daughter&gt; daughters, <span class="keyword">final</span> List&lt;Son&gt; sons)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(daughters == <span class="keyword">null</span>) <span class="keyword">this</span>.daughters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            daughters.forEach(daughter -&gt; daughter.setMother(<span class="keyword">this</span>));</span><br><span class="line">            <span class="keyword">this</span>.daughters = daughters;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sons == <span class="keyword">null</span>) <span class="keyword">this</span>.sons = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sons.forEach(son -&gt; son.setMother(<span class="keyword">this</span>));</span><br><span class="line">            <span class="keyword">this</span>.sons = sons;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bearDaughters</span><span class="params">(<span class="keyword">final</span> List&lt;Daughter&gt; babyDaughters)</span> </span>&#123;</span><br><span class="line">        babyDaughters.forEach(daughter -&gt; daughter.setMother(<span class="keyword">this</span>));</span><br><span class="line">        daughters.addAll(babyDaughters);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bearSons</span><span class="params">(<span class="keyword">final</span> List&lt;Son&gt; babySons)</span> </span>&#123;</span><br><span class="line">        babySons.forEach(son -&gt; son.setMother(<span class="keyword">this</span>));</span><br><span class="line">        sons.addAll(babySons);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>엄마가 있고, 아들/딸들이 있는데 아들/딸들을 EAGER로 fetch해 올 때 발생한다.<br><strong>(즉, OneToMany, ManyToMany인 Bag 두 개 이상을 EAGER로 fetch할 때 발생한다.)</strong><br>EAGER로 땡겨오면 N+1 쿼리 문제가 존재하기 때문에 fetchType을 전부 LAZY로 바꾼 후 한 방 쿼리로 불러와도 문제는 재발한다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MotherRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Mother</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@EntityGraph</span>(attributePaths = &#123;<span class="string">"daughters"</span>, <span class="string">"sons"</span>&#125;)</span><br><span class="line">    <span class="function">List&lt;Mother&gt; <span class="title">findAllWithChildrenBy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bag"><a href="#Bag" class="headerlink" title="Bag"></a>Bag</h2><p>우선 MultipleBagFetchException 파일을 둘러보자.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Exception used to indicate that a query is attempting to simultaneously fetch multiple</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.hibernate.type.BagType bags&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p><p>여러 BagType을 동시에 fetch 해 올 때 발생하는 예외라고 한다.<br>그럼 Bag이 뭘까…?  </p><blockquote><p>A generalization of the notion of a set is that of a multiset or bag, which is similar to a set but allows repeated (“equal”) values (duplicates).<br>  <a href="https://en.wikipedia.org/wiki/Set_(abstract_data_type)#Multiset" rel="external nofollow noopener noreferrer" target="_blank">https://en.wikipedia.org/wiki/Set_(abstract_data_type)#Multiset</a></p></blockquote><blockquote><p>A Bag is a java collection that stores elements without caring about the sequencing, but allow duplicate elements in the list.<br>  A bag is a random grouping of the objects in the list.<br>  <a href="https://en.wikipedia.org/wiki/Set_(abstract_data_type)#Multiset" rel="external nofollow noopener noreferrer" target="_blank">https://en.wikipedia.org/wiki/Set_(abstract_data_type)#Multiset</a></p></blockquote><blockquote><p>A <bag> is an unordered collection, which can contain duplicated elements.<br>  That means if you persist a bag with some order of elements, you cannot expect the same order retains when the collection is retrieved.<br>  There is not a “bag” concept in Java collections framework, so we just use a java.util.List corresponds to a <bag>.<br>  <a href="https://stackoverflow.com/questions/13812283/difference-between-set-and-bag-in-hibernate" rel="external nofollow noopener noreferrer" target="_blank">https://stackoverflow.com/questions/13812283/difference-between-set-and-bag-in-hibernate</a></bag></bag></p></blockquote><p>즉, Bag(Multiset)은 Set과 같이 순서가 없고, List와 같이 중복을 허용하는 자료구조이다.<br>하지만 자바 컬렉션 프레임워크에서는 Bag이 없기 때문에 하이버네이트에서는 List를 Bag으로써 사용하고 있는 것이다.</p><h2 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting"></a>Troubleshooting</h2><p>우선 두 Bag을 Set으로 바꾸면 우리가 원하는대로 한 방 쿼리로 날아간다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mother</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany</span>(mappedBy = <span class="string">"mother"</span>, cascade = CascadeType.ALL)</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Daughter&gt; daughters = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany</span>(mappedBy = <span class="string">"mother"</span>, cascade = CascadeType.ALL)</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Son&gt; sons = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Builder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mother</span><span class="params">(<span class="keyword">final</span> Long id, <span class="keyword">final</span> Set&lt;Daughter&gt; daughters, <span class="keyword">final</span> Set&lt;Son&gt; sons)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(daughters == <span class="keyword">null</span>) <span class="keyword">this</span>.daughters = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            daughters.forEach(daughter -&gt; daughter.setMother(<span class="keyword">this</span>));</span><br><span class="line">            <span class="keyword">this</span>.daughters = daughters;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sons == <span class="keyword">null</span>) <span class="keyword">this</span>.sons = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sons.forEach(son -&gt; son.setMother(<span class="keyword">this</span>));</span><br><span class="line">            <span class="keyword">this</span>.sons = sons;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bearDaughters</span><span class="params">(<span class="keyword">final</span> Set&lt;Daughter&gt; babyDaughters)</span> </span>&#123;</span><br><span class="line">        babyDaughters.forEach(daughter -&gt; daughter.setMother(<span class="keyword">this</span>));</span><br><span class="line">        daughters.addAll(babyDaughters);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bearSons</span><span class="params">(<span class="keyword">final</span> Set&lt;Son&gt; babySons)</span> </span>&#123;</span><br><span class="line">        babySons.forEach(son -&gt; son.setMother(<span class="keyword">this</span>));</span><br><span class="line">        sons.addAll(babySons);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>실무에서 급하면 딱 이 수준까지만 하면 끝이고 이제 왜 Multiple Bag을 Fetch해 올 수 없는지 알아보자.  </p><p>우선 두 Bag 중 하나만 Set으로 바꾼 후 결과를 보자.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mother</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany</span>(mappedBy = <span class="string">"mother"</span>, cascade = CascadeType.ALL)</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Daughter&gt; daughters = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany</span>(mappedBy = <span class="string">"mother"</span>, cascade = CascadeType.ALL)</span><br><span class="line">    <span class="keyword">private</span> List&lt;Son&gt; sons = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Builder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mother</span><span class="params">(<span class="keyword">final</span> Long id, <span class="keyword">final</span> Set&lt;Daughter&gt; daughters, <span class="keyword">final</span> List&lt;Son&gt; sons)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(daughters == <span class="keyword">null</span>) <span class="keyword">this</span>.daughters = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            daughters.forEach(daughter -&gt; daughter.setMother(<span class="keyword">this</span>));</span><br><span class="line">            <span class="keyword">this</span>.daughters = daughters;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sons == <span class="keyword">null</span>) <span class="keyword">this</span>.sons = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sons.forEach(son -&gt; son.setMother(<span class="keyword">this</span>));</span><br><span class="line">            <span class="keyword">this</span>.sons = sons;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bearDaughters</span><span class="params">(<span class="keyword">final</span> Set&lt;Daughter&gt; babyDaughters)</span> </span>&#123;</span><br><span class="line">        babyDaughters.forEach(daughter -&gt; daughter.setMother(<span class="keyword">this</span>));</span><br><span class="line">        daughters.addAll(babyDaughters);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bearSons</span><span class="params">(<span class="keyword">final</span> List&lt;Son&gt; babySons)</span> </span>&#123;</span><br><span class="line">        babySons.forEach(son -&gt; son.setMother(<span class="keyword">this</span>));</span><br><span class="line">        sons.addAll(babySons);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>그리고 MotherRepository#findAllWithChildrenBy() 메서드를 통해 호출하면 아래와 같은 결과를 볼 수 있다.<br>일단 날아간 쿼리는 아래와 같다. (혹시나 join 했을 때 자식들이 없을까봐 엄마라도 불러오려고 기본적으로 outer join을 하고 있다.)<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    mother0_.id <span class="keyword">as</span> id1_1_0_,</span><br><span class="line">    daughters1_.id <span class="keyword">as</span> id1_0_1_,</span><br><span class="line">    sons2_.id <span class="keyword">as</span> id1_2_2_,</span><br><span class="line">    daughters1_.mother_id <span class="keyword">as</span> mother_i2_0_1_,</span><br><span class="line">    daughters1_.mother_id <span class="keyword">as</span> mother_i2_0_0__,</span><br><span class="line">    daughters1_.id <span class="keyword">as</span> id1_0_0__,</span><br><span class="line">    sons2_.mother_id <span class="keyword">as</span> mother_i2_2_2_,</span><br><span class="line">    sons2_.mother_id <span class="keyword">as</span> mother_i2_2_1__,</span><br><span class="line">    sons2_.id <span class="keyword">as</span> id1_2_1__ </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    mother mother0_ </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span></span><br><span class="line">    daughter daughters1_ </span><br><span class="line">        <span class="keyword">on</span> mother0_.id=daughters1_.mother_id </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span></span><br><span class="line">    son sons2_ </span><br><span class="line">        <span class="keyword">on</span> mother0_.id=sons2_.mother_id</span><br></pre></td></tr></table></figure></p><p><img src="01.png" alt="주목할 부분은 파란색으로 쳐놓은 부분이다."><br>Set으로 저장한 딸들은 중복없이 잘 불러와졌고, List(Bag)로 저장한 아들들은 중복있이 잘 불러와졌다.<br>(List라고 무조건 중복이 발생하는 건 아니다. 단일 List(Bag)만 Fetch 해오면 중복없이 잘 불러온다.)  </p><p>이 결과를 Row로 표시해보자면 다음과 같다.  </p><table><thead><tr><th>mother.id</th><th>daughter.id</th><th>son.id</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>2</td></tr><tr><td>1</td><td>1</td><td>3</td></tr><tr><td>1</td><td>2</td><td>1</td></tr><tr><td>1</td><td>2</td><td>2</td></tr><tr><td>1</td><td>2</td><td>3</td></tr><tr><td>1</td><td>3</td><td>1</td></tr><tr><td>1</td><td>3</td><td>2</td></tr><tr><td>1</td><td>3</td><td>3</td></tr></tbody></table><p>만약 daughters 마저도 중복도 보장이 안 되고, 순서도 보장이 안 됐다면 어떤 기준을 가지고 Row를 매핑할 수 있을까?<br>(뭐, 물론 이 경우에는 될 수도 있겠지만 좀 더 엔터티의 관계가 복잡한 경우에는 매핑이 불가능하거나 너무 복잡해지는 거 아닐까?)<br>그렇기 때문에 Multiple Bag은 Fetch가 안 되는 게 아닐까 싶다.</p><p>실제로 List로 저장한 데이터를 하이버네이트에서는 BagType으로 취급하고 있고, Set으로 저장한 데이터는 SetType으로 취급하고 있다.<br>ListType 클래스도 있긴 한데 언제 어떻게 써야하는지는 잘 모르겠다 ㅠㅠ…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;thumb.jpg&quot; alt=&quot;이미지 출처: https://pgr21.com/pb/pb.php?id=humor&amp;amp;no=166185&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Trouble&quot;&gt;&lt;a href=&quot;#Trouble&quot; class=&quot;hea
      
    
    </summary>
    
      <category term="Note" scheme="https://perfectacle.github.io/categories/Note/"/>
    
      <category term="Troubleshooting" scheme="https://perfectacle.github.io/categories/Note/Troubleshooting/"/>
    
    
      <category term="Hibernate" scheme="https://perfectacle.github.io/tags/Hibernate/"/>
    
      <category term="Troubleshooting" scheme="https://perfectacle.github.io/tags/Troubleshooting/"/>
    
      <category term="JPA" scheme="https://perfectacle.github.io/tags/JPA/"/>
    
      <category term="ORM" scheme="https://perfectacle.github.io/tags/ORM/"/>
    
  </entry>
  
  <entry>
    <title>(삽질기) Spring Data JPA에서 Entity Manager 관련 삽질기</title>
    <link href="https://perfectacle.github.io/2019/05/01/jpa-entity-manager-with-test/"/>
    <id>https://perfectacle.github.io/2019/05/01/jpa-entity-manager-with-test/</id>
    <published>2019-05-01T08:26:48.000Z</published>
    <updated>2019-05-01T08:26:48.361Z</updated>
    
    <content type="html"><![CDATA[<p><img src="thumb.png" alt="이미지 출처: http://bemil.chosun.com/nbrd/bbs/view.html?b_bbs_id=10044&amp;pn=0&amp;num=128739"></p><p>오랜만에 Spring Data JPA를 가지고 뭔가 뻘뻘 대보고 있었다.<br>하지만 내 의도대로 동작하지 않았다.<br>아래 코드를 보자.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@DataJpaTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MotherTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SomeEntityRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        repository.save(<span class="keyword">new</span> SomeEntity());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        repository.findById(<span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>우선 테스트를 돌릴 때마다 DB를 초기화했다. (인메모리 DB인 H2를 사용했다.)<br>따라서 테스트 할 데이터를 setup 메서드를 통해 데이터를 DB에 밀어넣고 있었다.<br>그리고 테스트 케이스에서 해당 엔터티를 불러오는 간단한 코드인데 나는 select 쿼리가 날아갈 줄 알았다.<br>하지만 insert 쿼리만 날아가고, 이거 가지고 코드를 이리저리 바꿔보며 온갖 삽질을 한 것 같다.  </p><p>왜 select 쿼리가 찍히지 않을까… 한 2시간 가까이를 이거 때문에 계속 삽질하고 있었다.<br>그리고 스프링 관련 커뮤니티에 질문하려고 <code>아마 SomeEntity 엔터티가 생성되면서 ID 값이 어딘가에 저장돼서 동일한...</code>까지 딱 치고 있는데<br><strong>어딘가 저장</strong>에 딱 꽂혀서 아! 맞다! 하고 그동안 JPA를 안 쓴 지 오래돼서 까먹었구나… 하고 한참동안 너무 허무했었다.  </p><p>답은 JPA의 동작 방식에 있었다.<br>기본적으로 JPA는 select 쿼리를 DB에 날리기 전에 엔터티 매니저를 뒤짐으로써 성능을 향상시킨다.<br>바로 save 메서드 당시에 엔터티 매니저에 해당 엔터티를 저장한 것이다.<br>엔터티 매니저에 없는 다른 ID를 조회하거나 @Id 어노테이션이 붙지 않은 다른 필드를 조건에 줄 경우에는 실제로 select 쿼리가 날아갔다.</p><p>그럼 setup 메서드와 test 메서드에서 사용하는 엔터티 매니저가 동일하다는 것을 어떻게 알 수 있을까?<br>기본적으로 엔터티 매니저는 thread safe하지 않아서 thread 별로 한 개의 엔터티 매니저 생성을 권장하는 것으로 알고 있다.<br>따라서 Spring Data JPA에서도 그렇게 하지 않았을까…?  </p><p>아래 테스트 코드를 통해 내가 생각한 가설이 맞는 거 같다. (멀티 스레드 환경에서 돌려본 건 아니긴 하지만…)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@DataJpaTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MotherTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SomeEntityRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PersistenceContext</span></span><br><span class="line">    <span class="keyword">private</span> EntityManager em;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SomeEntity entity;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        entity = <span class="keyword">new</span> SomeEntity();</span><br><span class="line">        </span><br><span class="line">        assertFalse(em.contains(entity));</span><br><span class="line"></span><br><span class="line">        repository.save(entity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(Long.valueOf(<span class="number">1L</span>), entity.getId());</span><br><span class="line">        assertTrue(em.contains(entity));</span><br><span class="line"></span><br><span class="line">        repository.findById(<span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>기본에 충실해야겠다 ㅠㅠ…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;thumb.png&quot; alt=&quot;이미지 출처: http://bemil.chosun.com/nbrd/bbs/view.html?b_bbs_id=10044&amp;amp;pn=0&amp;amp;num=128739&quot;&gt;&lt;/p&gt;
&lt;p&gt;오랜만에 Spring 
      
    
    </summary>
    
      <category term="Note" scheme="https://perfectacle.github.io/categories/Note/"/>
    
      <category term="삽질" scheme="https://perfectacle.github.io/categories/Note/%EC%82%BD%EC%A7%88/"/>
    
    
      <category term="JPA" scheme="https://perfectacle.github.io/tags/JPA/"/>
    
  </entry>
  
  <entry>
    <title>(Troubleshooting) 생애 첫 Heap 메모리 분석기 (feat. Eclipse MAT)</title>
    <link href="https://perfectacle.github.io/2019/04/28/heap-memory-analytics-with-eclipse-mat/"/>
    <id>https://perfectacle.github.io/2019/04/28/heap-memory-analytics-with-eclipse-mat/</id>
    <published>2019-04-28T14:25:38.000Z</published>
    <updated>2019-04-28T14:47:29.749Z</updated>
    
    <content type="html"><![CDATA[<p><img src="thumb.png" alt=""></p><p>어느 날 서비스가 갑자기 다운되는 사례가 발생했다.<br>다행히 서버를 이중화시켜놓아서 장애가 발생하진 않았지만 그래도 왜 다운된 건지 원인 분석을 해야했다.<br>나의 실수로 인해 WAS 로그는 제대로 남겨져있지 않았고, CTO 님께서 힙 덤프 같은 거라도 떠져있나 보라고 하셔서 지푸라기라도 잪는 심정으로 기대를 했는데 희망을 저버리지 않았다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError \</span><br><span class="line">-XX:HeapDumpPath=./jvm.hprof</span><br></pre></td></tr></table></figure></p><p>위 옵션으로 인해 OOME(Out of Memory Exception) 발생 시 힙 덤프를 뜨게 해놓았는데 다행히 힙 덤프가 존재했다.  </p><p>여기서 힙 덤프는 힙 메모리의 내용을 그대로 떠놓은 파일이다.<br>따라서 힙 메모리에 어떤 객체들로 가득 채워져있었는지 분석할 수 있게 되었다.<br><strong>여기서 흥분해서 서버에서 vi 등등을 이용해 힙 덤프 파일을 열면 안 된다. (용량이 큰 로그 및 다른 파일도 물론 서버에서 절대 열면 안 된다.)</strong><br>여는 순간 힙 메모리 사이즈만큼 <strong>서버의 메모리를 사용하게 돼서 서버가 다운</strong>될 수도 있다.<br>무조건 scp 등등의 명령어를 통해 로컬로 복사한 후에 열어보는 습관을 가지자.</p><h2 id="Eclipse-Memory-Analyzer-MAT"><a href="#Eclipse-Memory-Analyzer-MAT" class="headerlink" title="Eclipse Memory Analyzer (MAT)"></a><a href="https://www.eclipse.org/mat/" rel="external nofollow noopener noreferrer" target="_blank">Eclipse Memory Analyzer (MAT)</a></h2><p><a href="https://spoqa.github.io/2012/02/06/eclipse-mat.html" rel="external nofollow noopener noreferrer" target="_blank">Eclipse Memory Analyzer 소개</a>와 <a href="https://d2.naver.com/helloworld/1326256" rel="external nofollow noopener noreferrer" target="_blank">하나의 메모리 누수를 잡기까지</a>에서 힙 덤프를 분석하는데 Eclipse MAT를 사용했다길래 나도 한 번 사용해보았다.<br><a href="https://www.eclipse.org/mat/downloads.php" rel="external nofollow noopener noreferrer" target="_blank">다운로드</a> 페이지에서 OS에 맞는 어플리케이션을 받으면 되는데 나는 MacOSX 버전을 다운받았다.  </p><p><img src="01.png" alt="식별되지 않은 개발자가 만든 앱이라고 실행되지 않는다... 역시 보안에 빡센 애플"><br><img src="02.png" alt="Security &amp; Privacy의 General 탭에서 빨간색 표시친 곳에서 Open Anyway를 누르자."><br><img src="03.png" alt="그럼 MAT를 열 수 있게 된다."><br><img src="04.png" alt="함정카드 발동... 아직도 열 수가 없다."><br><img src="05.png" alt="MAT를 Applications 디렉토리로 옮긴 후에 열어보자."><br><img src="06.png" alt="드디어 정상적으로 열렸다 ㅠㅠ... 이제 빨간색 표시친 Open a Heap Dump를 통해 로컬로 복사한 힙 덤프 파일을 열어보자."><br><img src="07.png" alt="Heap Dump 파싱이 끝난 후 Leak Suspects Report를 체크 후 finish를 누르자."><br><img src="08.png" alt="Leak Suspects Report를 보니 com.mysql.jdbc.JDBC42ResultSet 클래스의 인스턴스가 1.8GB나 존재했다.">  </p><p>일단 툴의 사용방법도 잘 몰라서 무작정 메세지를 가지고 검색해보았다.<br>우선 최대한 일반적인 메세지만 뽑아서 <code>One instance of &quot;com.mysql.jdbc.JDBC42ResultSet&quot; loaded by</code>를 통해 구글링을 하니<br><a href="https://bugs.mysql.com/bug.php?id=90240" rel="external nofollow noopener noreferrer" target="_blank">MySQL Bugs: #90240: Possible memory leak in JDBC42PreparedStatement</a>란 글이 눈에 띄었다.<br>메모리 릭? 버그? 그럼 우리가 쓰고 있는 MySQL 관련된 무언가에서 버그가 존재한다는 것인가?란 생각이 들었다.  </p><blockquote><p>Please try with MySQL connector 5.1.45 or 5.1.44 versions and let us know if memory leak happening.</p></blockquote><p>위와 같이 답변이 달린 걸 보고 음… 역시 MySQL 버그인가 보구나… MySQL connector 버전을 올려보자~ 하고 gradle의 디펜던시를 보니 해당 버전보다도 높았다.<br>그래서 뭐지? 하고 답변을 끝까지 쭉 봤더니</p><blockquote><p>It was an application error loading too many rows in memory, nothing to do with the connector.</p></blockquote><p>어플리케이션에서 너무 많은 row를 로딩해서 생긴 문제라고 했다.<br>CTO 님께 말씀드려보니 CTO 님도 보시더니 아마도 저 문제가 맞을 거라고 하셨다.<br>그리고 우리가 저렇게 Row를 많이 불러올만한 쿼리를 쓰는 게 주문 내역 등등을 엑셀로 다운로드 받는 기능에서 날 거라고 말씀해주셨다.<br>따라서 해당 소스코드를 분석해봤는데 카운트 쿼리를 통해 사전에 너무 많은 Row를 불러오는 걸 방지하고 있었다.<br>그럼 어디서 이렇게 많은 Row를 불러오는 쿼리를 사용하지…? 도무지 이해가 가지 않았다.<br>그래서 다른 시니어 개발자 분의 도움을 받아 MAT의 간단한 사용 방법을 익혔다.  </p><h2 id="분석-및-해결"><a href="#분석-및-해결" class="headerlink" title="분석 및 해결"></a>분석 및 해결</h2><p><img src="09.png" alt="Leak Suspects Report에서 Details를 클릭하자."><br><img src="10.png" alt="그럼 위와 같은 정보를 발견할 수 있는데 위 정보를 토대로 대략 120만 Row의 데이터를 불러왔다는 걸 알 수 있다."><br><img src="11.png" alt="최상위 Object를 클릭해서 List objects &gt; with outgoing references를 클릭하자."><br>incoming이면 해당 object를 참조하는 object를, outgoing이면 해당 object가 참조하고 있는 object를 포함해서 보여준다.<br>자세한 설명은 <a href="https://dzone.com/articles/eclipse-mat-incoming-outgoing-references" rel="external nofollow noopener noreferrer" target="_blank">Eclipse MAT — Incoming, Outgoing References</a>를 참고하자.  </p><p><img src="12.png" alt="해당 Object에서 참조 중인 수많은 Row 데이터들을 볼 수 있다."><br><img src="13.png" alt="임의의 Row를 까봤는데 metadata라는 의미심장한 필드가 보이고 그 안에 완벽하진 않지만 쿼리문이나 테이블 이름 등등의 정보를 볼 수 있다."><br>다른 Row들도 까봤더니 모두 동일한 필드 및 테이블에서 데이터를 가지고 오고 있었다.<br>이를 통해 해당 테이블의 모든 Row를 가져오는 거라고 의심했고 해당 테이블을 실제로 보니 대략 120만 Row의 데이터가 있었다.<br>실제로 소스코드도 보았더니 해당 테이블을 토대로 엑셀을 다운로드 받는 기능이 어딘가에 <del>숨겨져</del>있었고 제대로 조건문이 걸려있지 않았다.<br>또한 Nginx의 Access log를 보니 힙 덤프가 떠지기 바로 직전에 해당 API를 호출한 이력도 있었다.</p><p>결국 해당 쿼리문에 조건을 추가해서 배포함으로써 해당 이슈는 일단락 짓게 되었다.<br>어찌보면 별 거 아니고, 내가 로그를 제대로 남겼더라면 힙덤프까지 안 봤을지도 몰랐겠지만<br>내가 로그를 남기지 않는 실수로 인해 힙 덤프를 분석해볼 수 있는 값진 기회가 주어졌다. <del>(절대로 노린 건 아니다.)</del><br>앞으로 이런 일이 있으면 안 되겠지만, 이런 일을 경험해보지 않고서 더 좋은 개발자로 다가가긴 힘든 것 같다.<br>역시 소프트웨어는 개발도 중요하지만 그 후에 유지보수를 해나가는 경험 또한 매우 중요한 것 같다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;thumb.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;어느 날 서비스가 갑자기 다운되는 사례가 발생했다.&lt;br&gt;다행히 서버를 이중화시켜놓아서 장애가 발생하진 않았지만 그래도 왜 다운된 건지 원인 분석을 해야했다.&lt;br&gt;나의 실수로 인해
      
    
    </summary>
    
      <category term="Note" scheme="https://perfectacle.github.io/categories/Note/"/>
    
      <category term="Troubleshooting" scheme="https://perfectacle.github.io/categories/Note/Troubleshooting/"/>
    
    
      <category term="JVM" scheme="https://perfectacle.github.io/tags/JVM/"/>
    
      <category term="Troubleshooting" scheme="https://perfectacle.github.io/tags/Troubleshooting/"/>
    
      <category term="Heap" scheme="https://perfectacle.github.io/tags/Heap/"/>
    
  </entry>
  
  <entry>
    <title>(Troubleshooting) Nginx upstream에 AWS ELB DNS를 걸 때 주의사항</title>
    <link href="https://perfectacle.github.io/2019/04/28/nginx-proxy-aws-elb/"/>
    <id>https://perfectacle.github.io/2019/04/28/nginx-proxy-aws-elb/</id>
    <published>2019-04-28T12:53:56.000Z</published>
    <updated>2019-04-28T12:53:56.243Z</updated>
    
    <content type="html"><![CDATA[<p><img src="thumb.png" alt="ALB는 Cross-Zone Load Balancing 옵션이 무조건 활성화돼있다."><br>얼마 전에 서버를 새롭게 이전했다.<br>기존에 있던 local의 upstream server 대신에 새로운 서버로 업스트림을 걸어놨다.  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://elb-dns.ap-northeast-2.elb.amazonaws.com;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LB에 바로 도메인을 붙여도 되지만 롤백을 최대한 빨리하기 위해 기존 서버에서 LB로 업스트림 걸어놓았다.</p><ol><li>만약 새로운 서버에서 문제가 생겼다고 가정  </li><li>이 때 LB에 바로 도메인을 달아놓았다면…<br>2-1. 기존의 서버로 다시 도메인 변경<br>2-2. DNS 캐시가 날아갈 때까지 유저에게 장애 발생<br>2-3. 클라이언트의 설정에 따라서 DNS 캐시가 언제 날아갈지 모르는 상황… (과연 일반 유저들이 브라우저의 DNS 캐시 지우는 방법을 알고 있을까?)</li><li>이 때 기존 서버는 내비두고 LB로 업스트림을 걸어놓았다면…<br>3-1. 기존 로컬 서버를 업스트림 서버로 변경<br>3-2. nginx -s reload<br>3-3. 수 초 이내로 원래 서버로 원복</li></ol><h2 id="Trouble"><a href="#Trouble" class="headerlink" title="Trouble"></a>Trouble</h2><p>하지만 문제는 며칠 후 발생했다.<br>ELB의 DNS로 접속하면 잘 되는데 기존 서버 도메인으로 접속하면(LB를 upstream으로 걸어놓은) 1분 가까운 시간이 흐른 후에 502 Bad Gateway가 나는 것이었다.<br>우선 급한 마음에 <code>nginx -s reload</code> 명령어를 입력했더니 다시 또 정상 동작하는 것이었다.<br>Nginx의 Access Log까지는 정상적으로 남은 걸 보니 LB를 찾지 못해서 일정 시간동안 기다리다가 502를 뱉었던 것 같았다.<br>나는 딱히 설정을 바꾼 것도 없는데… 잘 동작하니 귀신이 곡할 노릇이었다.  </p><h2 id="ELB-동작-방식"><a href="#ELB-동작-방식" class="headerlink" title="ELB 동작 방식"></a>ELB 동작 방식</h2><p><a href="https://aws.amazon.com/articles/best-practices-in-evaluating-elastic-load-balancing/" rel="external nofollow noopener noreferrer" target="_blank">Best Practices in Evaluating Elastic Load Balancing</a>을 보면 다음과 같은 구문이 나온다.</p><blockquote><p>The controller will also monitor the load balancers and manage the capacity that is used to handle the client requests.<br>  The Elastic Load Balancing service will update the Domain Name System (DNS) record of the load balancer when it scales so that the new resources have their respective IP addresses registered in DNS.<br>  The DNS record that is created includes a Time-to-Live (TTL) setting of 60 seconds, with the expectation that clients will re-lookup the DNS at least every 60 seconds.<br>  컨트롤러는 로드 밸런서를 모니터링하고 클라이언트의 요청을 핸들링하는 capacity를 관리한다.<br>  Elastic Load Balancing은 스케일링할 때 로드 밸런서의 DNS 레코드를 업데이트한다. (새로운 리소스의 IP는 DNS에 등록된다.)<br>  DNS 레코드의 TTL은 60초로 세팅돼있고, 60초가 지나면 클라이언트는 다시 lookup한다.</p></blockquote><p>ELB는 트래픽에 따라서 알아서 스케일링되는 모양이다.<br>또한 TTL은 60초이다.<br>따라서 ELB의 아이피 주소는 매우 유동적이다. (늘어났다가 줄어들었다가… 혹은 LB가 다운되면 새로 생성한다던지…)</p><h2 id="Nginx-동작-방식"><a href="#Nginx-동작-방식" class="headerlink" title="Nginx 동작 방식"></a>Nginx 동작 방식</h2><p><a href="https://www.nginx.com/blog/dns-service-discovery-nginx-plus/" rel="external nofollow noopener noreferrer" target="_blank">Using DNS for Service Discovery with NGINX and NGINX Plus</a>  </p><blockquote><p>NGINX caches the DNS records until the next restart or configuration reload, ignoring the records’ TTL values.<br>  NGINX는 restart나 reload가 발생할 때까지 DNS record를 캐시하고 record의 TTL을 무시한다.</p></blockquote><p>즉, ELB의 TTL인 60초는 무시되고, 설정파일을 읽을 당시에 DNS Lookup이 진행되기 때문에 ELB Scaling이 진행된 후에는 정상 동작하리란 보장을 할 수 없다.<br>설정파일을 읽을 당시에 DNS Lookup을 통해 얻어온 LB의 IP 주소가 트래픽 감소에 의해 더 이상 유효하지 않은 IP 주소가 됐을 가능성이 높기 때문이다.  </p><h1 id="Shooting"><a href="#Shooting" class="headerlink" title="Shooting"></a>Shooting</h1><p><a href="https://www.nginx.com/blog/dns-service-discovery-nginx-plus/" rel="external nofollow noopener noreferrer" target="_blank">Using DNS for Service Discovery with NGINX and NGINX Plus</a></p><blockquote><p>When you use a variable to specify the domain name in the proxy_pass directive, NGINX re‑resolves the domain name when its TTL expires.<br>  You must include the resolver directive to explicitly specify the name server (NGINX does not refer to /etc/resolv.conf).<br>  By including the valid parameter to the resolver directive, you can tell NGINX to ignore the TTL and re‑resolve names at a specified frequency instead.<br>  proxy_pass directive의 domain name에 변수를 명시할 경우, NGINX는 domain name의 TTL이 만료됐을 때 다시 resolve한다.<br>  resolver directive에 name server를 꼭 명시해줘야한다. (NGINX는 /etc/resolv.conf 파일을 참조하지 않는다.)<br>  resolver directive에 valid parameter를 명시하면 TTL을 무시하고 valid parameter의 주기로 다시 resolve한다.</p></blockquote><p>우리가 해야할 일은 이제 다음과 같다.</p><ol><li><code>/etc/resolv.conf</code> 파일을 참조하여 resolver directive에 name server를 명시해준다.  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/resolv.conf</span><br><span class="line"><span class="comment"># ; generated by /usr/sbin/dhclient-script</span></span><br><span class="line"><span class="comment"># search ap-northeast-2.compute.internal</span></span><br><span class="line"><span class="comment"># options timeout:2 attempts:5</span></span><br><span class="line"><span class="comment"># nameserver 10.12.0.2</span></span><br></pre></td></tr></table></figure></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        resolver 10.12.0.2;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://elb-dns.ap-northeast-2.elb.amazonaws.com;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>resolver directive에 valid parameter에 ELB DNS의 TTL인 60보다 작은 값을 세팅한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        resolver 10.12.0.2 valid=30s;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://elb-dns.ap-northeast-2.elb.amazonaws.com;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>proxy_pass directive의 domain name에 변수를 명시한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        resolver 10.12.0.2 valid=30s;</span><br><span class="line">        location / &#123;</span><br><span class="line">            <span class="built_in">set</span> <span class="variable">$elb</span>-dns elb-dns.ap-northeast-2.elb.amazonaws.com;</span><br><span class="line">            proxy_pass http://<span class="variable">$elb</span>-dns;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>nginx -s reload</code>를 통해 다운타임 없이 설정파일을 재적용한다.</p></li></ol><h2 id="참고-링크"><a href="#참고-링크" class="headerlink" title="참고 링크"></a>참고 링크</h2><ul><li><a href="https://aws.amazon.com/articles/best-practices-in-evaluating-elastic-load-balancing/" rel="external nofollow noopener noreferrer" target="_blank">Best Practices in Evaluating Elastic Load Balancing</a></li><li><a href="https://stackoverflow.com/questions/3821333/amazon-ec2-elastic-load-balancer-does-its-ip-ever-change" rel="external nofollow noopener noreferrer" target="_blank">Amazon EC2 Elastic Load Balancer: Does its IP ever Change?</a></li><li><a href="https://medium.com/@circlee7/nginx-proxy-pass-%EC%9D%98-aws-elb-%EC%97%B0%EA%B2%B0-%EC%84%A4%EC%A0%95-f0c4b792ef71" rel="external nofollow noopener noreferrer" target="_blank">Nginx proxy_pass 의 AWS ELB 연결 문제</a></li><li><a href="http://tech.kkung.net/blog/nginx-with-elb/" rel="external nofollow noopener noreferrer" target="_blank">Nginx를 ELB Reverse Proxy로 사용할때 주의 점</a></li><li><a href="https://serverfault.com/questions/560632/some-nginx-reverse-proxy-configs-stops-working-once-a-day" rel="external nofollow noopener noreferrer" target="_blank">Some nginx reverse proxy configs stops working once a day</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;thumb.png&quot; alt=&quot;ALB는 Cross-Zone Load Balancing 옵션이 무조건 활성화돼있다.&quot;&gt;&lt;br&gt;얼마 전에 서버를 새롭게 이전했다.&lt;br&gt;기존에 있던 local의 upstream server 대신에 새로
      
    
    </summary>
    
      <category term="Note" scheme="https://perfectacle.github.io/categories/Note/"/>
    
      <category term="Troubleshooting" scheme="https://perfectacle.github.io/categories/Note/Troubleshooting/"/>
    
    
      <category term="AWS" scheme="https://perfectacle.github.io/tags/AWS/"/>
    
      <category term="Troubleshooting" scheme="https://perfectacle.github.io/tags/Troubleshooting/"/>
    
      <category term="ELB" scheme="https://perfectacle.github.io/tags/ELB/"/>
    
      <category term="Nginx" scheme="https://perfectacle.github.io/tags/Nginx/"/>
    
      <category term="Proxy" scheme="https://perfectacle.github.io/tags/Proxy/"/>
    
  </entry>
  
  <entry>
    <title>무중단 배포란...?</title>
    <link href="https://perfectacle.github.io/2019/04/21/non-stop-deployment/"/>
    <id>https://perfectacle.github.io/2019/04/21/non-stop-deployment/</id>
    <published>2019-04-21T14:03:23.000Z</published>
    <updated>2019-04-21T14:18:50.982Z</updated>
    
    <content type="html"><![CDATA[<p><img src="thumbs.jpg" alt=""></p><p>실제로 우리가 간단하게 서버를 배포하는 시나리오를 생각해보자.</p><ol><li>80포트(혹은 다른 포트)에 우리의 서버를 띄운다.</li><li>새롭게 배포할 내용이 있다고 하면 포트가 충돌나면 안 되기 때문에 서버를 다운시킨다.  </li><li>(옵션) 유저의 이탈을 방지하고자 공사중 이미지를 띄운다.  </li><li>80포트(혹은 다른 포트)에 새롭게 배포할 서버를 띄운다.</li></ol><p>만약 서버가 뜨는데 30초가 걸린다고 하면 최소 30+@초만큼 다운타임(유저에게 서비스가 불가능한 시간)이 발생한다.<br>현대의 어플리케이션이라면 유저에게 최상의 경험을 제공해주기위해 이런 다운타임이 없는 무중단 배포를 지원해야한다.  </p><h3 id="필요-조건"><a href="#필요-조건" class="headerlink" title="필요 조건"></a>필요 조건</h3><p><strong>두 대 이상의 서버(혹은 서버 어플리케이션을 두 개)를 서비스해야한다.</strong><br>다운타임이 발생하지 않으려면 실제 서비스 중인 서버와 새롭게 배포한 서버가 동시에 존재해야한다.<br>비용을 줄이려면 배포할 때만 새롭게 서버를 띄우고 배포가 완료된 후에 기존 서버는 죽이면 된다.</p><h3 id="Rolling-Deployment"><a href="#Rolling-Deployment" class="headerlink" title="Rolling Deployment"></a>Rolling Deployment</h3><p><img src="elb-basic.png" alt="SPOF를 피하려면 어플리케이션 서버는 물론이고 로드 밸런서도 이중화해야한다."><br>HA(High Availability)을 위해 프로덕션 환경은 2대 이상의 서버로 구성한다.<br>이런 환경에서 무중단 배포하기 가장 간단한 방법이 바로 Rolling 배포이다.<br>시나리오는 다음과 같다.  </p><ol><li>서버 1을 로드 밸런서에서 뺀다.  </li><li>서버 1에 배포한다.  </li><li>서버 1을 다시 로드 밸런서에 넣는다.  </li><li>서버 2를 로드 밸런서에서 뺀다.  </li><li>서버 2에 배포한다.  </li><li>서버 2를 다시 로드 밸런서에 넣는다.</li></ol><p>위와 같이 하면 다운타임 없이 배포가 가능하다.<br>배포해야할 서버가 너무 많다면 1대씩 배포하면 너무 느리니 N대 단위로 배포하기도 한다.<br>하지만 배포가 끝나기 전까지는 누구는 이전 버전을 서비스 받고, 누구는 신규 버전을 서비스 받는 등의 문제가 존재한다.<br>또한 1대에 배포하는 거보다 최소 2배 이상 느리다. (아무리 못해도 2번 이상의 배포가 진행되기 때문에)</p><h3 id="Canary-Deployment"><a href="#Canary-Deployment" class="headerlink" title="Canary Deployment"></a>Canary Deployment</h3><p><img src="canary.png" alt=""><br>광부들이 광산에서 유독가스가 나오는 것을 알아내기 위해서 가스에 민감한 카나리아(조류)를 광산 안에서 키웠다고 해서 유래된 배포이다.<br>소수의 유저(혹은 사내)만 사용하는 환경(Canary 환경)에 신규 버전을 배포하고 문제가 없다고 판단됐을 때 다른 모든 서버에 배포한다.<br>Canary 환경은 뭐 QA Phase가 될 수도 있고, 랜덤하게 유저를 Canary 환경으로 라우팅시킬 수도 있고 구현하기 나름이다.  </p><h3 id="Blue-Green-Deployment"><a href="#Blue-Green-Deployment" class="headerlink" title="Blue/Green Deployment"></a>Blue/Green Deployment</h3><p><img src="thumbs.jpg" alt=""><br><strong>실제로 서비스 중인 환경(Blue)</strong>과 <strong>새롭게 배포할 환경(Green)</strong>을 세트로 준비해서 배포하는 방식을 말한다.<br>장점으로는 새롭게 배포할 환경에만 배포하면 되기 때문에 배포 속도가 매우 빠르다. (배포할 서버가 N대라 하더라도 N대의 Green 서버에 동시에 배포하면 되기 때문에)<br>또한 언제나 Green 환경이 떠있기 때문에 만약에 잘못된 버전으로 배포를 했을 경우에 신속하게 롤백이 가능하다. (수 백대의 서버에 거의 수 초 이내에 롤백이 가능함.)<br>물론 언제나 Green 환경이 떠있어야하기 때문에 비용이 두 배로 든다는 단점도 있다.<br>또한 Green 환경에서 Scheduler와 같은 배치성 Job이 도는 경우에 레거시 버전으로 돌기 때문에 장애가 발생할 가능성도 존재한다.<br>(이럴 때는 배포를 연속적으로 두 번 해서 Blue와 Green의 버전을 일치시키는 것 이외에는 딱히 떠오르지 않는다 ㅠㅠ…)</p><p>이렇게 설명하면 이해가 잘 안 가니 그림과 함께 이해해보자.<br>(그림에서는 Nginx를 프록시 서버로 사용했지만 Apache 등등을 사용해도 무방하다.<br>또한 하나의 서버에 두 대의 어플리케이션을 띄우는 걸로 설명했지만 별도의 서버에 하나의 어플리케이션만 각각 띄워서 구성해도 된다.)</p><h4 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h4><p><img src="blue-green-02.png" alt="젠킨스와 같은 CI를 사용해서 Green 환경에 배포를 완료한다."></p><p><img src="blue-green-03.jpg" alt="Nginx와 같은 프록시 서버에서 80포트로 들어오면 Green 환경으로 라우팅하도록 설정한다.">  </p><h4 id="Rollback"><a href="#Rollback" class="headerlink" title="Rollback"></a>Rollback</h4><p><img src="blue-green-04.jpg" alt="만약에 새로 배포한 Blue 환경에서 버그가 발생했다고 가정해보자.">  </p><p><img src="blue-green-05.jpg" alt="이 때 프록시 서버에서 80포트의 라우팅을 Green 환경으로만 옮겨서 Blue와 Green을 바꾸기만 하면 롤백이 끝난다.">  </p><p><img src="blue-green-06.jpg" alt="물론 Green 환경이 사망해계신 상태에서는 롤백이 불가능하다."></p><p>더 자세한 설명은 <a href="https://martinfowler.com/bliki/BlueGreenDeployment.html" rel="external nofollow noopener noreferrer" target="_blank">Martin Fowler가 쓴 블로그 글</a>을 참고하자.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;thumbs.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;실제로 우리가 간단하게 서버를 배포하는 시나리오를 생각해보자.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;80포트(혹은 다른 포트)에 우리의 서버를 띄운다.&lt;/li&gt;
&lt;li&gt;새롭게 배포할 내용이 있다
      
    
    </summary>
    
      <category term="Middle-end" scheme="https://perfectacle.github.io/categories/Middle-end/"/>
    
      <category term="DevOps" scheme="https://perfectacle.github.io/categories/Middle-end/DevOps/"/>
    
    
      <category term="Deployment" scheme="https://perfectacle.github.io/tags/Deployment/"/>
    
  </entry>
  
  <entry>
    <title>(Docker) Spring Boot Application Image 최적화하기</title>
    <link href="https://perfectacle.github.io/2019/04/16/spring-boot-docker-image-optimization/"/>
    <id>https://perfectacle.github.io/2019/04/16/spring-boot-docker-image-optimization/</id>
    <published>2019-04-15T18:19:58.000Z</published>
    <updated>2019-04-21T14:39:42.955Z</updated>
    
    <content type="html"><![CDATA[<p><img src="thumb.png" alt=""></p><h2 id="들어가기에-앞서"><a href="#들어가기에-앞서" class="headerlink" title="들어가기에 앞서"></a>들어가기에 앞서</h2><p>이 글에서 Docker와 Spring Boot, Gradle에 대한 기본적인 지식은 있다고 판단하고 설명한다.<br>프로젝트는 <a href="https://github.com/perfectacle/spring-boot-docker-demo" rel="external nofollow noopener noreferrer" target="_blank">spring-boot-docker-demo 저장소</a>에서 단계별로 브랜치를 확인해보면 된다.<br>이해를 돕기 위해 docker image tag 단위로 branch를 땄다.</p><p>프로젝트의 build.gradle은 아래와 같다.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">'org.springframework.boot'</span> version <span class="string">'2.1.4.RELEASE'</span></span><br><span class="line">    id <span class="string">'java'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'io.spring.dependency-management'</span></span><br><span class="line"></span><br><span class="line">archivesBaseName = <span class="string">'demo'</span></span><br><span class="line">group = <span class="string">'com.example'</span></span><br><span class="line">version = <span class="string">'0.0.1-SNAPSHOT'</span></span><br><span class="line">sourceCompatibility = <span class="string">'11'</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">'org.springframework.boot:spring-boot-starter-webflux'</span></span><br><span class="line">    testImplementation <span class="string">'org.springframework.boot:spring-boot-starter-test'</span></span><br><span class="line">    testImplementation <span class="string">'io.projectreactor:reactor-test'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="가장-간단한-Spring-Boot-Docker-Image-만들기"><a href="#가장-간단한-Spring-Boot-Docker-Image-만들기" class="headerlink" title="가장 간단한 Spring Boot Docker Image 만들기"></a>가장 간단한 Spring Boot Docker Image 만들기</h2><p>이 상태에서 gradle wrapper를 이용해 build를 수행해보자.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew build</span><br></pre></td></tr></table></figure></p><p>그렇다면 build/libs 디렉토리에 <strong>demo-0.0.1-SNAPSHOT.jar</strong>란 파일이 만들어진다.<br>(build.gradle의 archivesBaseName과 version 값에 의해 위와 같은 이름으로 생성된다.)</p><p>이제 실행 가능한 jar 파일이 생성됐으니 Docker 이미지를 만들어서 해당 jar 파일을 실행하게 만들어보기 위해서 Dockerfile을 생성하자.<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">11</span>-jre-slim</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /root</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">COPY build/libs/demo-0.0.1-SNAPSHOT.jar .</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">CMD java -jar demo-0.0.1-SNAPSHOT.jar</span></span><br></pre></td></tr></table></figure></p><p>이제 이미지를 빌드해보자.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker build -t $&#123;imageName&#125;:$&#123;tagName&#125; .</span></span><br><span class="line"><span class="comment"># 예제에서는 이해를 돕기 위해 임의로 이미지와 태그 이름을 임의로 설정함.</span></span><br><span class="line"><span class="comment"># perfectacle은 글쓴이의 docker hub 아이디이므로 본인의 docker hub 아이디를 입력해야 docker hub repository 충돌이 일어나지 않는다.</span></span><br><span class="line"></span><br><span class="line">docker build -t perfectacle/spring-boot-demo:basic .</span><br></pre></td></tr></table></figure></p><p>이제 이미지를 통해 컨테이너를 띄워보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker run --rm -d -p $&#123;hostPort&#125;:$&#123;containerPort&#125; --name $&#123;containerName&#125; $&#123;imageName&#125;:$&#123;tagName&#125;</span></span><br><span class="line"><span class="comment"># --rm 옵션은 컨테이너를 stop 하면 자동으로 컨테이너를 죽여버린다.</span></span><br><span class="line"><span class="comment"># -d 옵션은 백그라운드에서 컨테이너를 실행한다는 옵션이다.</span></span><br><span class="line"><span class="comment"># 예제에서는 이해를 돕기 위해 포트나 컨테이너 이름 등등의 값을 임의로 설정함.</span></span><br><span class="line"></span><br><span class="line">docker run --rm -d -p 80:8080 --name demo perfectacle/spring-boot-demo:basic</span><br></pre></td></tr></table></figure><p>실제로 어플리케이션이 잘 떴는지 확인해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 프로젝트의 com.example.demo.Router 파일에서 GET / 에 대한 라우터, 핸들러를 만들어두었다.</span></span><br><span class="line">curl localhost</span><br><span class="line"></span><br><span class="line"><span class="comment"># ok</span></span><br></pre></td></tr></table></figure><p>ok라는 텍스트가 출력이 됐다면 성공적으로 컨테이너가 뜬 것이다.<br>혹시나 <code>curl: (52) Empty reply from server</code>란 오류가 뜬다면 서버가 아직 뜨지 않은 것이니 10초 정도 기다렸다가 다시 시도해보자.</p><p>이제 <a href="https://hub.docker.com/" rel="external nofollow noopener noreferrer" target="_blank">Docker Hub</a>에 우리가 작업한 이미지를 올려보자.<br>(물론 Docker Hub에 Repository가 존재하는 상태로 시작해야한다.)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker push $&#123;repositoryName&#125;:$&#123;tagName&#125;</span></span><br><span class="line">docker push perfectacle/spring-boot-demo:basic</span><br><span class="line"></span><br><span class="line"><span class="comment"># The push refers to repository [docker.io/perfectacle/spring-boot-demo]</span></span><br><span class="line"><span class="comment"># b61d0959344e: Pushing [================&gt;                                  ]  6.096MB/18.22MB</span></span><br><span class="line"><span class="comment"># 4bbad98352e9: Mounted from library/openjdk </span></span><br><span class="line"><span class="comment"># 9f6ec1d0a99c: Mounted from library/openjdk </span></span><br><span class="line"><span class="comment"># 8eb822456baf: Mounted from library/openjdk </span></span><br><span class="line"><span class="comment"># 0d59dc1d96ca: Mounted from library/openjdk </span></span><br><span class="line"><span class="comment"># 93df8ce6d131: Mounted from library/openjdk </span></span><br><span class="line"><span class="comment"># 5dacd731af1b: Mounted from library/openjdk</span></span><br></pre></td></tr></table></figure></p><p>Docker Image는 여러 레이어로 겹겹이 쌓여있다.<br>우리가 Dockerfile에 선언한 <code>FROM openjdk:11-jre-slim</code> 부분에 의해 openjdk:11-jre-slim 이미지의 레이어에서부터 쌓아가는 것이다.<br>4bbad98352e9 ~ 5dacd731af1b까지가 openjdk:11-jre-slim 이미지의 레이어를 사용한 것이다.<br>그리고 제일 윗 라인에 b61d0959344e 이 부분이 Dockerfile의 <code>COPY build/libs/demo-0.0.1-SNAPSHOT.jar .</code>에 의해 생긴 레이어이다.<br>바로 저 jar 파일이 하나의 레이어를 차지하고 있는 것이다.<br>그럼 이 레이어란 건 어떻게 쓰이는지는 좀이따 살펴보자.</p><p>이제 어플리케이션 코드를 한 번 수정해보자.<br><code>com.example.demo.Router</code> 파일을 아래와 같이 수정해보자.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.BodyInserters;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.RouterFunction;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.RouterFunctions;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.ServerResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.web.reactive.function.server.RequestPredicates.GET;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Router</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RouterFunction&lt;ServerResponse&gt; <span class="title">route</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RouterFunctions.route(GET(<span class="string">""</span>),</span><br><span class="line">                                     serverRequest -&gt; ServerResponse.ok()</span><br><span class="line">                                                                    .contentType(MediaType.TEXT_PLAIN)</span><br><span class="line">                                                                    .body(BodyInserters.fromObject(<span class="string">"ok!"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>ok</code>에서 <code>ok!</code>로 바꿨을 뿐이다.  </p><p>이제 다시 소스 코드를 빌드해주자.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew build</span><br></pre></td></tr></table></figure></p><p>바뀐 소스 코드를 토대로 도커 이미지를 만들자.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t perfectacle/spring-boot-demo:basic-change-app .</span><br></pre></td></tr></table></figure></p><p>이제 새롭게 빌드한 이미지를 통해 컨테이너를 띄워보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 포트 및 컨테이너 이름 충돌을 방지하고자 전에 띄워놨던 컨테이너를 멈추자.</span></span><br><span class="line"><span class="comment"># 이전에 --rm 옵션을 줬기 때문에 stop을 하면 자동으로 컨테이너까지 죽여버린다.</span></span><br><span class="line">docker stop demo</span><br><span class="line">docker run --rm -d -p 80:8080 --name demo perfectacle/spring-boot-demo:basic-change-app</span><br></pre></td></tr></table></figure><p>실제로 어플리케이션이 잘 떴는지 확인해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl localhost</span><br><span class="line"></span><br><span class="line"><span class="comment"># ok!</span></span><br></pre></td></tr></table></figure><p>이제 Docker Hub에 좀 전에 새로 생성한 이미지를 올려보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker push perfectacle/spring-boot-demo:basic-change-app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 54f0c4fe51ff: Pushing [=&gt;                                                 ]  590.8kB/18.22MB</span></span><br><span class="line"><span class="comment"># 4bbad98352e9: Layer already exists </span></span><br><span class="line"><span class="comment"># 9f6ec1d0a99c: Layer already exists </span></span><br><span class="line"><span class="comment"># 8eb822456baf: Layer already exists </span></span><br><span class="line"><span class="comment"># 0d59dc1d96ca: Layer already exists </span></span><br><span class="line"><span class="comment"># 93df8ce6d131: Layer already exists </span></span><br><span class="line"><span class="comment"># 5dacd731af1b: Layer already exists</span></span><br></pre></td></tr></table></figure><p>레이어의 진가가 여기서 나온다.<br>4bbad98352e9 ~ 5dacd731af1b까지가 openjdk:11-jre-slim 이미지의 레이어이고,<br>perfectacle/spring-boot-demo:basic 이미지에서 이미 사용했고 해당 이미지는 이미 Docker Hub에 올려두었다.<br>따라서 해당 레이어를 <strong>재활용</strong>하는 것이다.<br>이건 push 뿐만 아니라 pull에도 해당하는 내용이다.<br>실제 디스크에서 차지하는 용량도 해당 레이어를 재활용하기 때문에 이미지 push/pull 속도 및 용량 측면에서도 매우 효율적이다.  </p><h2 id="Spring-Boot-Docker-Image-최적화하기"><a href="#Spring-Boot-Docker-Image-최적화하기" class="headerlink" title="Spring Boot Docker Image 최적화하기"></a>Spring Boot Docker Image 최적화하기</h2><p>이렇게 레이어를 잘 구성해서 재활용할 수 있는 부분을 최대한 늘리는 게 이번 포스트에서 진행할 최적화의 한 방법이다.<br>하지만 우리는 레이어를 잘 활용하고 있지 못하고 있다.  </p><p>basic 태그의 이미지를 올릴 때도 <code>b61d0959344e: 18.22MB</code>를 업로드 했고,<br>basic-change-app 태그의 이미지를 올릴 때도 <code>54f0c4fe51ff: 590.8kB/18.22MB</code>를 업로드 했다.<br>우리가 변경한 부분은 매우 작은 것 같은데, 왜 이렇게 많은 용량을 업로드하는 것일까?<br>그건 우리가 jar 파일을 하나의 레이어로 구성했기 때문이다. </p><p>우선 jar 파일이 어떻게 구성돼있는지 한 번 까보자.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> build/libs</span><br><span class="line">tar -xvf demo-0.0.1-SNAPSHOT.jar</span><br><span class="line">ls</span><br><span class="line"><span class="comment"># 우리가 여기서 눈여겨 볼 것은 BOOT-INF 디렉토리이다.</span></span><br><span class="line"><span class="comment"># BOOT-INF META-INF demo-0.0.1-SNAPSHOT.jar org</span></span><br><span class="line"></span><br><span class="line">ls BOOT-INF</span><br><span class="line"><span class="comment"># classes에는 우리가 작성한 어플리케이션 소스 코드가 들어있고, lib 디렉토리에는 라이브러리들(*.jar)이 들어있다.</span></span><br><span class="line"><span class="comment"># classes lib</span></span><br></pre></td></tr></table></figure></p><p>즉, 우리는 classes에 있는 파일만 수정했음에도 불구하고 lib에 있는 파일까지 같은 레이어로 묶어서 push하고 있던 것이다.<br>레이어를 재활용하기 위해선 jar 파일을 분해해서 이렇게 어플리케이션 레이어와 라이브러리 레이어를 쪼개야 최대한 레이어를 재활용할 수 있다.  </p><p>빌드 후에 매번 저렇게 jar 파일을 분해하기 귀찮으니 build task를 손 봐주자.<br>build.gradle에서 아래 내용을 추가해주자.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">task unpackJar(<span class="string">type:</span> Copy) &#123;</span><br><span class="line">    <span class="keyword">def</span> unpackDir = <span class="string">"$buildDir/unpack"</span></span><br><span class="line">    </span><br><span class="line">    delete unpackDir</span><br><span class="line">    from zipTree(jar.getArchiveFile())</span><br><span class="line">    into unpackDir</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">build &#123;</span><br><span class="line">    finalizedBy unpackJar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>그리고 Dockerfile에서 어플리케이션 레이어와 라이브러리 레이어를 분리시키자.<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">11</span>-jre-slim</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /root</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">ARG buildDir=build/unpack</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">COPY <span class="variable">$&#123;buildDir&#125;</span>/BOOT-INF/classes/ app</span></span><br><span class="line"><span class="bash">COPY <span class="variable">$&#123;buildDir&#125;</span>/BOOT-INF/lib/ lib</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">CMD java -cp app:lib/* com.example.demo.DemoApplication</span></span><br></pre></td></tr></table></figure></p><p>이제 바뀐 task로 빌드해보자.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew build</span><br></pre></td></tr></table></figure></p><p>jar 파일이 <code>build/libs/unpack</code>에 제대로 풀어졌는지 확인해보고 이제 새로운 도커 이미지를 빌드하자.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t perfectacle/spring-boot-demo:unpack-jar .</span><br></pre></td></tr></table></figure></p><p>이제 새롭게 빌드한 이미지를 통해 컨테이너를 띄워보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop demo</span><br><span class="line">docker run --rm -d -p 80:8080 --name demo perfectacle/spring-boot-demo:unpack-jar</span><br></pre></td></tr></table></figure><p>실제로 어플리케이션이 잘 떴는지 확인해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl localhost</span><br><span class="line"></span><br><span class="line"><span class="comment"># ok!</span></span><br></pre></td></tr></table></figure><p>이제 Docker Hub에 좀 전에 새로 생성한 이미지를 올려보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker push perfectacle/spring-boot-demo:unpack-jar</span><br><span class="line"></span><br><span class="line"><span class="comment"># aefdad4cf83c: Pushing [=&gt;                                                 ]  592.9kB/18.12MB</span></span><br><span class="line"><span class="comment"># c132ceeeb517: Pushing [==================================================&gt;]  9.728kB</span></span><br><span class="line"><span class="comment"># 4bbad98352e9: Layer already exists </span></span><br><span class="line"><span class="comment"># 9f6ec1d0a99c: Layer already exists </span></span><br><span class="line"><span class="comment"># 8eb822456baf: Layer already exists </span></span><br><span class="line"><span class="comment"># 0d59dc1d96ca: Layer already exists </span></span><br><span class="line"><span class="comment"># 93df8ce6d131: Layer already exists </span></span><br><span class="line"><span class="comment"># 5dacd731af1b: Layer already exists</span></span><br></pre></td></tr></table></figure><p>aefdad4cf83c는 라이브러리 레이어이고, c132ceeeb517는 어플리케이션 레이어이다.  </p><p>여기까지 문제가 없긴한데 Dockerfile에서 메인 클래스(com.example.demo.DemoApplication)를 하드코딩하는 게 매우 귀찮다.<br>JarLauncher를 이용해서 하드코딩 하는 부분을 없애보자! (물론 JarLauncher를 쓰면 main class를 하드코딩하는 거 보다 아주 조금 느리게 서버가 뜬다.)<br>Dockerfile을 아래와 같이 수정해주자.<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">11</span>-jre-slim</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /root</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">ARG buildDir=build/unpack</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">COPY <span class="variable">$&#123;buildDir&#125;</span>/BOOT-INF/classes BOOT-INF/classes</span></span><br><span class="line"><span class="bash">COPY <span class="variable">$&#123;buildDir&#125;</span>/BOOT-INF/lib BOOT-INF/lib</span></span><br><span class="line"><span class="bash">COPY <span class="variable">$&#123;buildDir&#125;</span>/META-INF META-INF</span></span><br><span class="line"><span class="bash">COPY <span class="variable">$&#123;buildDir&#125;</span>/org org</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">CMD java org.springframework.boot.loader.JarLauncher</span></span><br></pre></td></tr></table></figure></p><p>덕지덕지 클래스패스 붙던 게 사라지고, 메인 클래스 하드코딩하던 부분도 사라졌다.</p><p>이미 빌드는 했고, 소스코드에 변경된 건 없으므로 새로운 도커 이미지를 빌드하자.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t perfectacle/spring-boot-demo:unpack-jar-launcher .</span><br></pre></td></tr></table></figure></p><p>이제 새롭게 빌드한 이미지를 통해 컨테이너를 띄워보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop demo</span><br><span class="line">docker run --rm -d -p 80:8080 --name demo perfectacle/spring-boot-demo:unpack-jar-launcher</span><br></pre></td></tr></table></figure><p>실제로 어플리케이션이 잘 떴는지 확인해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl localhost</span><br><span class="line"></span><br><span class="line"><span class="comment"># ok!</span></span><br></pre></td></tr></table></figure><p>이제 Docker Hub에 좀 전에 새로 생성한 이미지를 올려보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker push perfectacle/spring-boot-demo:unpack-jar-launcher</span><br><span class="line"></span><br><span class="line"><span class="comment"># 55e024f80fff: Pushing [==================================================&gt;]  221.7kB</span></span><br><span class="line"><span class="comment"># fb71d1d0e2a1: Pushing [==================================================&gt;]  3.072kB</span></span><br><span class="line"><span class="comment"># 182065791613: Pushing [=&gt;                                                 ]  593.4kB/18.12MB</span></span><br><span class="line"><span class="comment"># b0d121a9a0fe: Pushing [==================================================&gt;]  9.728kB</span></span><br><span class="line"><span class="comment"># 4bbad98352e9: Layer already exists </span></span><br><span class="line"><span class="comment"># 9f6ec1d0a99c: Layer already exists </span></span><br><span class="line"><span class="comment"># 8eb822456baf: Layer already exists </span></span><br><span class="line"><span class="comment"># 0d59dc1d96ca: Layer already exists </span></span><br><span class="line"><span class="comment"># 93df8ce6d131: Layer already exists </span></span><br><span class="line"><span class="comment"># 5dacd731af1b: Layer already exists</span></span><br></pre></td></tr></table></figure><p>위 Dockerfile에도 단점이 존재한다.<br>바로 레이어가 4개나 존재한다는 것이다.<br>우리는 어플리케이션 레이어/라이브러리 레이어로만 구분하려고 했는데 <strong>메인 클래스 하드코딩, 클래스패스</strong> 두 가지 문제점 때문에 또 다른 문제점을 만들어냈다.<br>이제 레이어를 다시 두 개로 줄여보자.</p><p>먼저 Copy의 횟수를 줄여야 레이어를 줄일 수 있으니 Copy하기 좋게 BOOT-INF/lib 폴더만 다른 곳으로 빼야한다.<br>그러기 위해서는 build task와 관련된 task들을 아래와 같이 수정해야한다.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">task moveLib &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        <span class="keyword">def</span> unpackDir = <span class="string">"$buildDir/unpack"</span></span><br><span class="line">        ant.move(<span class="string">file:</span> <span class="string">"$&#123;unpackDir&#125;/app/BOOT-INF/lib"</span>, <span class="string">toFile:</span> <span class="string">"$&#123;unpackDir&#125;/lib"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task unpackJar(<span class="string">type:</span> Copy) &#123;</span><br><span class="line">    <span class="keyword">def</span> unpackDir = <span class="string">"$buildDir/unpack"</span></span><br><span class="line"></span><br><span class="line">    delete unpackDir</span><br><span class="line">    from zipTree(jar.getArchiveFile())</span><br><span class="line">    into <span class="string">"$unpackDir/app"</span></span><br><span class="line"></span><br><span class="line">    finalizedBy moveLib</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">build &#123;</span><br><span class="line">    finalizedBy unpackJar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>그리고 Dockerfile을 아래와 같이 수정해서 레이어를 두 개(어플리케이션, 라이브러리)로 만들자.<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">11</span>-jre-slim</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /root</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">ARG buildDir=build/unpack</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">COPY <span class="variable">$&#123;buildDir&#125;</span>/app .</span></span><br><span class="line"><span class="bash">COPY <span class="variable">$&#123;buildDir&#125;</span>/lib BOOT-INF/lib</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">CMD java org.springframework.boot.loader.JarLauncher</span></span><br></pre></td></tr></table></figure></p><p>이제 바뀐 task로 빌드해보자.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew build</span><br></pre></td></tr></table></figure></p><p>lib 폴더가 <code>build/libs/unpack/app/BOOT-INF</code>에 없고 <code>build/libs/unpack/</code>에 있는지 확인해보고<br>이제 새로운 도커 이미지를 빌드하자.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t perfectacle/spring-boot-demo:unpack-jar-launcher-decrease-layer .</span><br></pre></td></tr></table></figure></p><p>이제 새롭게 빌드한 이미지를 통해 컨테이너를 띄워보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop demo</span><br><span class="line">docker run --rm -d -p 80:8080 --name demo perfectacle/spring-boot-demo:unpack-jar-launcher-decrease-layer</span><br></pre></td></tr></table></figure><p>실제로 어플리케이션이 잘 떴는지 확인해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl localhost</span><br><span class="line"></span><br><span class="line"><span class="comment"># ok!</span></span><br></pre></td></tr></table></figure><p>이제 Docker Hub에 좀 전에 새로 생성한 이미지를 올려보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker push perfectacle/spring-boot-demo:unpack-jar-launcher-decrease-layer</span><br><span class="line"></span><br><span class="line"><span class="comment"># aeafcfee4d7d: Pushing [=&gt;                                                 ]  593.4kB/18.12MB</span></span><br><span class="line"><span class="comment"># f69cb2892736: Pushing [==================================================&gt;]  231.4kB</span></span><br><span class="line"><span class="comment"># 4bbad98352e9: Layer already exists </span></span><br><span class="line"><span class="comment"># 9f6ec1d0a99c: Layer already exists </span></span><br><span class="line"><span class="comment"># 8eb822456baf: Layer already exists </span></span><br><span class="line"><span class="comment"># 0d59dc1d96ca: Layer already exists </span></span><br><span class="line"><span class="comment"># 93df8ce6d131: Layer already exists </span></span><br><span class="line"><span class="comment"># 5dacd731af1b: Layer already exists</span></span><br></pre></td></tr></table></figure><p>다시 레이어가 두 개로 줄어들었다.</p><p>그럼 이제 어플레이션 코드만 수정하고 과연 라이브러리 레이어는 재활용하는지 살펴보자.<br><code>com.example.demo.Router</code> 파일을 아래와 같이 수정해보자.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.BodyInserters;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.RouterFunction;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.RouterFunctions;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.ServerResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.web.reactive.function.server.RequestPredicates.GET;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Router</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RouterFunction&lt;ServerResponse&gt; <span class="title">route</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RouterFunctions.route(GET(<span class="string">""</span>),</span><br><span class="line">                                     serverRequest -&gt; ServerResponse.ok()</span><br><span class="line">                                                                    .contentType(MediaType.TEXT_PLAIN)</span><br><span class="line">                                                                    .body(BodyInserters.fromObject(<span class="string">"ok!"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>ok!</code>에서 <code>ok!!</code>로 바꿨을 뿐이다.  </p><p>소스코드가 바뀌었으니 다시 빌드하자.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew build</span><br></pre></td></tr></table></figure></p><p>새로운 도커 이미지로 빌드하자.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t perfectacle/spring-boot-demo:unpack-jar-launcher-decrease-layer-change-app .</span><br></pre></td></tr></table></figure></p><p>이제 새롭게 빌드한 이미지를 통해 컨테이너를 띄워보자.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop demo</span><br><span class="line">docker run --rm -d -p 80:8080 --name demo perfectacle/spring-boot-demo:unpack-jar-launcher-decrease-layer-change-app</span><br></pre></td></tr></table></figure></p><p>실제로 어플리케이션이 잘 떴는지 확인해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl localhost</span><br><span class="line"></span><br><span class="line"><span class="comment"># ok!!</span></span><br></pre></td></tr></table></figure><p>이제 Docker Hub에 좀 전에 새로 생성한 이미지를 올려보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker push perfectacle/spring-boot-demo:unpack-jar-launcher-decrease-layer-change-app</span><br><span class="line"></span><br><span class="line"><span class="comment"># e5ff3f17bd79: Pushing [==&gt;                                                ]    790kB/18.12MB</span></span><br><span class="line"><span class="comment"># 6f4d8004dddf: Pushing [==================================================&gt;]  231.4kB</span></span><br><span class="line"><span class="comment"># 4bbad98352e9: Layer already exists </span></span><br><span class="line"><span class="comment"># 9f6ec1d0a99c: Layer already exists </span></span><br><span class="line"><span class="comment"># 8eb822456baf: Layer already exists </span></span><br><span class="line"><span class="comment"># 0d59dc1d96ca: Layer already exists </span></span><br><span class="line"><span class="comment"># 93df8ce6d131: Layer already exists </span></span><br><span class="line"><span class="comment"># 5dacd731af1b: Layer already exists</span></span><br></pre></td></tr></table></figure><p>엥? 어플리케이션 소스코드만 바꿨는데 왜 라이브러리 레이어는 재활용하지 못하는 거지?<br>그럼 혹시 라이브러리를 추가했을 때 어플리케이션 레이어는 재활용할까?</p><p>build.gradle에 modelmapper를 디펜던시로 추가해보자.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">'org.springframework.boot:spring-boot-starter-webflux'</span></span><br><span class="line">    testImplementation <span class="string">'org.springframework.boot:spring-boot-starter-test'</span></span><br><span class="line">    testImplementation <span class="string">'io.projectreactor:reactor-test'</span></span><br><span class="line">    implementation <span class="string">'org.modelmapper:modelmapper:2.3.3'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>디펜던시를 추가했으니 다시 빌드하자.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew build</span><br></pre></td></tr></table></figure></p><p>새로운 도커 이미지로 빌드하자.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t perfectacle/spring-boot-demo:unpack-jar-launcher-decrease-layer-change-lib .</span><br></pre></td></tr></table></figure></p><p>이제 새롭게 빌드한 이미지를 통해 컨테이너를 띄워보자.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop demo</span><br><span class="line">docker run --rm -d -p 80:8080 --name demo perfectacle/spring-boot-demo:unpack-jar-launcher-decrease-layer-change-lib</span><br></pre></td></tr></table></figure></p><p>실제로 어플리케이션이 잘 떴는지 확인해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl localhost</span><br><span class="line"></span><br><span class="line"><span class="comment"># ok!!</span></span><br></pre></td></tr></table></figure><p>이제 Docker Hub에 좀 전에 새로 생성한 이미지를 올려보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker push perfectacle/spring-boot-demo:unpack-jar-launcher-decrease-layer-change-lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1902203c1efa: Pushing [==&gt;                                                ]  921.1kB/21.94MB</span></span><br><span class="line"><span class="comment"># 6f4d8004dddf: Layer already exists</span></span><br><span class="line"><span class="comment"># 4bbad98352e9: Layer already exists </span></span><br><span class="line"><span class="comment"># 9f6ec1d0a99c: Layer already exists </span></span><br><span class="line"><span class="comment"># 8eb822456baf: Layer already exists </span></span><br><span class="line"><span class="comment"># 0d59dc1d96ca: Layer already exists </span></span><br><span class="line"><span class="comment"># 93df8ce6d131: Layer already exists </span></span><br><span class="line"><span class="comment"># 5dacd731af1b: Layer already exists</span></span><br></pre></td></tr></table></figure><p>어플리케이션 레이어는 재활용이 잘 되고 변경된 라이브러리 레이어만 push 하는 걸 볼 수 있다.</p><p>근데 통상적으로 라이브러리 레이어보다 어플리케이션 레이어의 변경이 잦고,<br>라이브러리 레이어의 용량이 더 커서 라이브러리 레이어를 재활용하는 게 훨씬 효율적이다.</p><p>혹시 Dockerfile에 선언한 레이어의 순서에 뭔가 연관이 있지 않을까 싶어 Dockerfile을 아래와 같이 수정해보았다.<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">11</span>-jre-slim</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /root</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">ARG buildDir=build/unpack</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">COPY <span class="variable">$&#123;buildDir&#125;</span>/lib BOOT-INF/lib</span></span><br><span class="line"><span class="bash">COPY <span class="variable">$&#123;buildDir&#125;</span>/app .</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">CMD java org.springframework.boot.loader.JarLauncher</span></span><br></pre></td></tr></table></figure></p><p>COPY 구문의 순서만 뒤바꾼 것이다. (lib 먼저, 그 다음에 app 레이어를 쌓게 끔)  </p><p>이미 빌드는 했고, 소스코드에 변경된 건 없으므로 새로운 도커 이미지를 빌드하자.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t perfectacle/spring-boot-demo:change-layer-order .</span><br></pre></td></tr></table></figure></p><p>이제 새롭게 빌드한 이미지를 통해 컨테이너를 띄워보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop demo</span><br><span class="line">docker run --rm -d -p 80:8080 --name demo perfectacle/spring-boot-demo:change-layer-order</span><br></pre></td></tr></table></figure><p>실제로 어플리케이션이 잘 떴는지 확인해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl localhost</span><br><span class="line"></span><br><span class="line"><span class="comment"># ok!!</span></span><br></pre></td></tr></table></figure><p>이제 Docker Hub에 좀 전에 새로 생성한 이미지를 올려보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker push perfectacle/spring-boot-demo:change-layer-order</span><br><span class="line"></span><br><span class="line"><span class="comment"># 43e70d9a1e7a: Pushing [==================================================&gt;]  231.4kB</span></span><br><span class="line"><span class="comment"># 44d3b0d75158: Pushing [========&gt;                                          ]  3.919MB/21.94MB</span></span><br><span class="line"><span class="comment"># 4bbad98352e9: Layer already exists </span></span><br><span class="line"><span class="comment"># 9f6ec1d0a99c: Layer already exists </span></span><br><span class="line"><span class="comment"># 8eb822456baf: Layer already exists </span></span><br><span class="line"><span class="comment"># 0d59dc1d96ca: Layer already exists </span></span><br><span class="line"><span class="comment"># 93df8ce6d131: Layer already exists </span></span><br><span class="line"><span class="comment"># 5dacd731af1b: Layer already exists</span></span><br></pre></td></tr></table></figure><p>레이어 순서를 바꾼 후 첫 Push이기 때문에 어플리케이션/라이브러리 레이어 모두 push 하고 있다.</p><p>이제 어플리케이션 코드를 바꿔보자.<br><code>com.example.demo.Router</code> 파일을 아래와 같이 수정해보자.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.BodyInserters;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.RouterFunction;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.RouterFunctions;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.ServerResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.web.reactive.function.server.RequestPredicates.GET;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Router</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RouterFunction&lt;ServerResponse&gt; <span class="title">route</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RouterFunctions.route(GET(<span class="string">""</span>),</span><br><span class="line">                                     serverRequest -&gt; ServerResponse.ok()</span><br><span class="line">                                                                    .contentType(MediaType.TEXT_PLAIN)</span><br><span class="line">                                                                    .body(BodyInserters.fromObject(<span class="string">"ok!!!!"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>ok!!</code>에서 <code>ok!!!!</code>로 바꿨을 뿐이다.</p><p>소스코드가 바뀌었으니 다시 빌드하자.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew build</span><br></pre></td></tr></table></figure></p><p>새로운 도커 이미지로 빌드하자.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t perfectacle/spring-boot-demo:change-layer-order-and-app .</span><br></pre></td></tr></table></figure></p><p>이제 새롭게 빌드한 이미지를 통해 컨테이너를 띄워보자.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop demo</span><br><span class="line">docker run --rm -d -p 80:8080 --name demo perfectacle/spring-boot-demo:change-layer-order-and-app</span><br></pre></td></tr></table></figure></p><p>실제로 어플리케이션이 잘 떴는지 확인해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl localhost</span><br><span class="line"></span><br><span class="line"><span class="comment"># ok!!!!</span></span><br></pre></td></tr></table></figure><p>이제 Docker Hub에 좀 전에 새로 생성한 이미지를 올려보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker push perfectacle/spring-boot-demo:change-layer-order-and-app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 13f989ce91ed: Pushing [==================================================&gt;]  231.4kB</span></span><br><span class="line"><span class="comment"># 44d3b0d75158: Layer already exists</span></span><br><span class="line"><span class="comment"># 4bbad98352e9: Layer already exists </span></span><br><span class="line"><span class="comment"># 9f6ec1d0a99c: Layer already exists </span></span><br><span class="line"><span class="comment"># 8eb822456baf: Layer already exists </span></span><br><span class="line"><span class="comment"># 0d59dc1d96ca: Layer already exists </span></span><br><span class="line"><span class="comment"># 93df8ce6d131: Layer already exists </span></span><br><span class="line"><span class="comment"># 5dacd731af1b: Layer already exists</span></span><br></pre></td></tr></table></figure><p>우리가 바라던대로 용량이 큰 라이브러리 레이어는 재활용하고 있고, 용량이 작은 어플리케이션 레이어는 변경했기 때문에 push하고 있다. </p><p>그럼 혹시 라이브러리 레이어를 수정했을 때 어플리케이션 레이어는 재활용할지 한 번 실험을 해보자.<br>build.gradle에 modelmapper의 버전을 바꿔보.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">'org.springframework.boot:spring-boot-starter-webflux'</span></span><br><span class="line">    testImplementation <span class="string">'org.springframework.boot:spring-boot-starter-test'</span></span><br><span class="line">    testImplementation <span class="string">'io.projectreactor:reactor-test'</span></span><br><span class="line">    implementation <span class="string">'org.modelmapper:modelmapper:2.3.2'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>디펜던시를 변경했으니 다시 빌드하자.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew build</span><br></pre></td></tr></table></figure></p><p>새로운 도커 이미지로 빌드하자.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t perfectacle/spring-boot-demo:change-layer-order-and-lib .</span><br></pre></td></tr></table></figure></p><p>이제 새롭게 빌드한 이미지를 통해 컨테이너를 띄워보자.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop demo</span><br><span class="line">docker run --rm -d -p 80:8080 --name demo perfectacle/spring-boot-demo:change-layer-order-and-lib</span><br></pre></td></tr></table></figure></p><p>실제로 어플리케이션이 잘 떴는지 확인해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl localhost</span><br><span class="line"></span><br><span class="line"><span class="comment"># ok!!!!</span></span><br></pre></td></tr></table></figure><p>이제 Docker Hub에 좀 전에 새로 생성한 이미지를 올려보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker push perfectacle/spring-boot-demo:change-layer-order-and-lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7a3da3f26c6b: Pushing [==================================================&gt;]  231.4kB</span></span><br><span class="line"><span class="comment"># c67d124680cf: Pushing [&gt;                                                  ]  265.7kB/25.75MB</span></span><br><span class="line"><span class="comment"># 6f4d8004dddf: Layer already exists</span></span><br><span class="line"><span class="comment"># 4bbad98352e9: Layer already exists </span></span><br><span class="line"><span class="comment"># 9f6ec1d0a99c: Layer already exists </span></span><br><span class="line"><span class="comment"># 8eb822456baf: Layer already exists </span></span><br><span class="line"><span class="comment"># 0d59dc1d96ca: Layer already exists </span></span><br><span class="line"><span class="comment"># 93df8ce6d131: Layer already exists </span></span><br><span class="line"><span class="comment"># 5dacd731af1b: Layer already exists</span></span><br></pre></td></tr></table></figure><p>아쉽지만 라이브러리 레이어만 바꿨다고 해서 어플리케이션 레이어를 재활용 할 순 없다.<br>그래도 어플리케이션 레이어는 대부분 라이브러리 레이어 보다 용량이 적고,<br>라이브러리 레이어가 변경이 되는 거보다 어플리케이션 레이어가 변경될 확률이 훨씬 높다.<br>따라서 어플리케이션 레이어를 재활용하는 것보다 라이브러리 레이어를 재활용하는 것이 훨씬 낫다.</p><h2 id="레이어-순서에-따라서-재활용할-수-있는-레이어가-달라진다"><a href="#레이어-순서에-따라서-재활용할-수-있는-레이어가-달라진다" class="headerlink" title="레이어 순서에 따라서 재활용할 수 있는 레이어가 달라진다"></a>레이어 순서에 따라서 재활용할 수 있는 레이어가 달라진다</h2><p>우리의 Dockerfile을 보면 아래와 같다.<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> <span class="variable">$&#123;buildDir&#125;</span>/lib BOOT-INF/lib</span></span><br><span class="line"><span class="bash">COPY <span class="variable">$&#123;buildDir&#125;</span>/app .</span></span><br></pre></td></tr></table></figure></p><p>어플리케이션 레이어<br>ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ<br>라이브러리 레이어</p><p>위와 같이 라이브러리 레이어 위에 어플리케이션 레이어를 쌓고 있다.<br>이 상황에서 어플리케이션 레이어만 수정하면 아래 있는 라이브러리 레이어를 재활용 할 수 있다.<br>하지만 라이브러리 레이어를 바꾼다면 라이브러리 레이어를 쌓고 그 위에 다시 어플리케이션 레이어를 쌓아야한다.<br>따라서 어플리케이션 레이어를 재활용하지 못하는 것이다.<br>도커 이미지는 마치 스택 자료구조 안에 레이어들을 쌓아간다고 생각하면 좀 더 이해하기 쉬운 것 같다.</p><h2 id="참조-링크"><a href="#참조-링크" class="headerlink" title="참조 링크"></a>참조 링크</h2><ul><li><a href="https://spring.io/guides/topicals/spring-boot-docker" rel="external nofollow noopener noreferrer" target="_blank">TOPICAL GUIDE Spring Boot Docker</a>  </li><li><a href="https://toedter.com/2017/09/23/optimizing-docker-images-for-spring-boot/" rel="external nofollow noopener noreferrer" target="_blank">Optimizing Docker Images for Spring Boot</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;thumb.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;들어가기에-앞서&quot;&gt;&lt;a href=&quot;#들어가기에-앞서&quot; class=&quot;headerlink&quot; title=&quot;들어가기에 앞서&quot;&gt;&lt;/a&gt;들어가기에 앞서&lt;/h2&gt;&lt;p&gt;이 글에서 Dock
      
    
    </summary>
    
      <category term="Middle-end" scheme="https://perfectacle.github.io/categories/Middle-end/"/>
    
      <category term="DevOps" scheme="https://perfectacle.github.io/categories/Middle-end/DevOps/"/>
    
    
      <category term="Spring Boot" scheme="https://perfectacle.github.io/tags/Spring-Boot/"/>
    
      <category term="Docker" scheme="https://perfectacle.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>어떻게 웹플럭스는 적은 쓰레드만으로 많은 요청을 처리할 수 있을까?</title>
    <link href="https://perfectacle.github.io/2019/03/10/how-can-webflux-process-huge-requests-with-fewer-threads/"/>
    <id>https://perfectacle.github.io/2019/03/10/how-can-webflux-process-huge-requests-with-fewer-threads/</id>
    <published>2019-03-10T10:24:38.000Z</published>
    <updated>2019-03-10T10:44:08.266Z</updated>
    
    <content type="html"><![CDATA[<p><img src="thumb.png" alt=""></p><p>기본적으로 SpringMVC에서 많이 사용하는 WAS인 Tomcat의 경우에는 기본적으로 쓰레드 풀의 갯수가 200개이고,<br>Jetty의 경우에는 기본적으로 minimum 8개에서 maximum 200개로 설정돼있다.<br>쓰레드 생성 비용은 비싸므로(오래 걸리므로) 미리 생성해서 ThreadPool에 쌓아놓는 것이다.<br>여기서 말하는 Thread는 <a href="/2019/03/10/green-thread-vs-native-thread/">Green Thread vs Native Thread</a>에서 얘기하다 싶이 Native Thread(OS에서 관리하는 Thread)이다.<br>이 말은 동시에 요청을 최대 200개까지 처리 가능하단 얘기이다.</p><p>그에 반해 Webflux는 core * 2의 Thread만을 생성한다.<br>SpringMVC에 비해 턱없이 모자란 쓰레드 갯수이고 그럼 싱글 코어의 경우에는 동시에 2개의 요청밖에 처리하지 못할 것처럼 보인다.  </p><h2 id="SpringMVC는-어떻게-동작하는가"><a href="#SpringMVC는-어떻게-동작하는가" class="headerlink" title="SpringMVC는 어떻게 동작하는가?"></a>SpringMVC는 어떻게 동작하는가?</h2><ol><li>요청이 들어오면 ThreadPool에서 Thread를 하나 사용한다.  </li><li>그러다 I/O(File I/O, Network I/O 등등)가 발생하면 CPU를 block 시킨다. (idle 상태에 빠진다.)  </li><li>이 때 다른 요청이 들어오면 ThreadPool에서 Thread를 하나 사용한다.  </li><li>이런 식으로 쓰레드를 돌아가면서 요청을 처리하고 block이 풀리면 작업을 이어나간다.  </li></ol><h2 id="Webflux는-어떻게-동작하는가"><a href="#Webflux는-어떻게-동작하는가" class="headerlink" title="Webflux는 어떻게 동작하는가?"></a>Webflux는 어떻게 동작하는가?</h2><p>Webflux는 기본적으로 아래의 쓰레드로 이루어진다.  </p><ol><li>요청을 받는 쓰레드 (이하 A 쓰레드라 칭함)  </li><li>block 상태에서 풀린 쓰레드의 요청을 처리하는 쓰레드 (이하 B 쓰레드라 칭함)</li><li>block 상태가 풀렸는지 무한 루프 돌면서 감시하는 event loop를 위한 쓰레드 (몇 개의 쓰레드가 쓰이는지는 케바케, 이하 C 쓰레드라 칭함.)  </li></ol><p>통상적으로 event loop를 위한 쓰레드의 갯수는 정확하지 않으므로 Webflux에서는 core * 2개의 쓰레드를 사용한다고 한다.<br>그럼 어떻게 그 적은 쓰레드(리소스, 비용)로 수많은 요청을 동시에 처리할 수 있는 걸까?</p><ol><li>요청이 들어오면 A 쓰레드에서 요청을 처리한다.  </li><li>그러다 I/O(File I/O, Network I/O 등등)가 발생하면 CPU를 block 시킨다. (idle 상태에 빠진다.)  </li><li>이런 비동기 작업을 처리하기 위해 Queue에 넣는다.  </li><li>A 쓰레드는 계속해서 요청을 받아서 처리한다.  </li><li>동시에 C 쓰레드에서 Queue를 무한 루프 돌면서 감시를 한다.</li><li>Event Loop에서 감시를 하다가 작업이 끝난 이벤트가 있으면 B 쓰레드에서 해당 이벤트를 처리한다.</li></ol><p>이런 일련의 흐름으로 인해 CPU가 놀 틈 없이 열심히 돌릴 수 있다.</p><h2 id="Webflux는-왜-CPU-Core-2개의-쓰레드를-사용할까"><a href="#Webflux는-왜-CPU-Core-2개의-쓰레드를-사용할까" class="headerlink" title="Webflux는 왜 CPU Core * 2개의 쓰레드를 사용할까?"></a>Webflux는 왜 CPU Core * 2개의 쓰레드를 사용할까?</h2><p>단순히 쓰레드 생성 비용이 비싸니까 쓰레드를 적게 쓰는 Webflux가 성능 상 뛰어나다고 생각하면 안 된다.<br>조금만 더 인심 쓰지… 왜 2개만으로도 충분하다고 생각하는 걸까? 하나 더 생성하면 조금 더 좋아지는 것 아닐까?? </p><p>쓰레드가 많다는 건 뭔가?<br>결국 쓰레드 사이에서 공유 자원의 <a href="/2019/03/10/java-synchronized-note/">동기화</a> 이슈가 걸려있다.<br>쓰레드가 많으면 많을 수록 동기화 이슈로 인해 시간이 오래 걸리게 된다.<br>따라서 Thread가 적으면 적을 수록 동기화 이슈로 인한 문제에 덜 시달리게 된다.</p><p>또한 CPU는 한 번에 하나의 작업 밖에 수행하지 못한다.<br>따라서 CPU Core 갯수보다 더 많은 쓰레드를 생성하는 건 무의미하게 동기화 이슈를 늘리는 것에 불과하다.<br>하지만 Webflux에서 Core * 2개의 갯수를 만든 이유는 무엇일까?<br>아는 사람이 있다면 댓글로 남겨주길 바란다.  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;thumb.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;기본적으로 SpringMVC에서 많이 사용하는 WAS인 Tomcat의 경우에는 기본적으로 쓰레드 풀의 갯수가 200개이고,&lt;br&gt;Jetty의 경우에는 기본적으로 minimum 8개에
      
    
    </summary>
    
      <category term="Programming" scheme="https://perfectacle.github.io/categories/Programming/"/>
    
      <category term="Spring" scheme="https://perfectacle.github.io/categories/Programming/Spring/"/>
    
    
      <category term="Java" scheme="https://perfectacle.github.io/tags/Java/"/>
    
      <category term="Srping" scheme="https://perfectacle.github.io/tags/Srping/"/>
    
      <category term="Webflux" scheme="https://perfectacle.github.io/tags/Webflux/"/>
    
      <category term="Reactive" scheme="https://perfectacle.github.io/tags/Reactive/"/>
    
  </entry>
  
  <entry>
    <title>Green Thread vs Native Thread</title>
    <link href="https://perfectacle.github.io/2019/03/10/green-thread-vs-native-thread/"/>
    <id>https://perfectacle.github.io/2019/03/10/green-thread-vs-native-thread/</id>
    <published>2019-03-10T09:24:06.000Z</published>
    <updated>2019-03-10T10:30:54.334Z</updated>
    
    <content type="html"><![CDATA[<p><img src="thumb.png" alt=""></p><h2 id="Green-Thread"><a href="#Green-Thread" class="headerlink" title="Green Thread"></a><a href="https://en.wikipedia.org/wiki/Green_threads" rel="external nofollow noopener noreferrer" target="_blank">Green Thread</a></h2><p>Green Thread는 우리가 알고 있는 쓰레드를 흉내낸 짝퉁 쓰레드이다.<br>Green Thread는 VM(Virtual Machine)이나 Library 등등에서 관리되며 개발자가 통제할 수도 있어서 user-level 쓰레드라고도 불린다.<br>하지만 Green Thread는 Many to One(Many는 쓰레드, One은 CPU) 모델로 설계된 쓰레드이다.<br>따라서 CPU Core가 하나인 환경일 때 설계된 쓰레드이다보니 아무리 Green Thread가 많아도 Native Thread는 단 한 개 뿐이 만들어지지 않는다.<br>Native Thread가 하나라는 건 CPU를 하나 밖에 사용하지 못한다는 뜻이다.<br>따라서 CPU가 여러 개인 멀티 코어 환경에서는 그 장점을 전혀 살리지 못한다.  </p><p>싱글 코어 환경에서는 동시에 여러 작업을 잘 수행하던 Green Thread는 그럼 단점만이 존재하는 걸까?<br>아니다.<br>싱글 코어 환경에서 네이티브 쓰레드를 10개 사용할 때와 그린 쓰레드를 10개 사용할 때를 비교해보자.<br>네이티브 쓰레드를 10개 사용하면 네이티브 쓰레드가 10개 생성된다.<br>그린 쓰레드를 10개 사용하면 네이티브 쓰레드는 한 개만 생성된다.<br>CPU 입장에서는 10개의 네이티브 쓰레드를 사용하는 것보다 한 개의 네이티브 쓰레드만 사용하는 그린 쓰레드 쪽이 성능 이슈가 훨씬 잘 나온다.<br>이유는 멀티 쓰레드 환경에서는 공유 자원의 <a href="/2019/03/10/java-synchronized-note/">동기화</a> 문제가 매우 중요하다.<br>동기화가 제대로 이루어지지 않는다면 프로그램은 치명적 오류를 유발한다.<br>하지만 그린 쓰레드 환경에서는 네이티브 쓰레드가 1개 뿐이니 동기화할 공유 자원이 없게 된다.  </p><p>따라서 그린 쓰레드가 싱글 쓰레드 환경에서는 더 좋은 성능을 발휘하게 된다.<br>하지만 자바 환경에서는 멀티 코어 환경에서 그 강점을 발휘하지 못하기 때문에 자바 3부터 Native Thread로 전부 바뀌었다.</p><p>Node.js에서는 <a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" rel="external nofollow noopener noreferrer" target="_blank">Event Loop</a>를 구현하기 위해 사용하고 있는<br><a href="https://github.com/libuv/libuv" rel="external nofollow noopener noreferrer" target="_blank">libuv</a>에서 Green Thread를 사용하고 있지 않을까… <strong>추측</strong>을 해본다.</p><h2 id="Native-Thread"><a href="#Native-Thread" class="headerlink" title="Native Thread"></a>Native Thread</h2><p>우리가 진짜로 알고 있는 쓰레드 개념이다.<br>Green Thread와 달리 OS 단에서 쓰레드를 관리한다.<br>Native Thread Model은 non-green(kernel-level) thread라고도 불리며 Many to Many(Thread도 Many, CPU도 Many)로 설계됐다.<br>따라서 멀티 코어 환경에서 강점을 발휘한다.<br>하지만 위에 말했던 것과 같이 쓰레드가 여러 개 있다는 것은 각 쓰레드 사이에 공유 자원에 대해 동기화 이슈를 가지게 된다는 소리이다.<br>이는 네이티브 쓰레드를 1개만 가지는 Green Thread에 비해 훨씬 복잡한 동기화 문제를 가지고 있음을 뜻하며 그에 따라 성능도 좋지 못하단 소리다.</p><p>자바 1.3부터는 Green Thread 대신에 Native Thread를 사용하고 있다.  </p><h2 id="참조-링크"><a href="#참조-링크" class="headerlink" title="참조 링크"></a>참조 링크</h2><ul><li><a href="https://en.wikipedia.org/wiki/Green_threads" rel="external nofollow noopener noreferrer" target="_blank">Green threads Wikipedia</a></li><li><a href="https://stackoverflow.com/questions/5713142/green-threads-vs-non-green-threads" rel="external nofollow noopener noreferrer" target="_blank">Green Threads vs Non Green Threads</a>  </li><li><a href="https://softwareengineering.stackexchange.com/questions/120384/why-not-green-threads" rel="external nofollow noopener noreferrer" target="_blank">Why not Green Threads?</a>  </li><li><a href="https://www.geeksforgeeks.org/green-vs-native-threads-and-deprecated-methods-in-java/" rel="external nofollow noopener noreferrer" target="_blank">Green vs Native Threads and Deprecated Methods in Java</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;thumb.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Green-Thread&quot;&gt;&lt;a href=&quot;#Green-Thread&quot; class=&quot;headerlink&quot; title=&quot;Green Thread&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https
      
    
    </summary>
    
      <category term="기타" scheme="https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"/>
    
      <category term="등등" scheme="https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EB%93%B1%EB%93%B1/"/>
    
    
      <category term="Thread" scheme="https://perfectacle.github.io/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>(Java) synchronized 키워드가 가지는 의미</title>
    <link href="https://perfectacle.github.io/2019/03/10/java-synchronized-note/"/>
    <id>https://perfectacle.github.io/2019/03/10/java-synchronized-note/</id>
    <published>2019-03-10T08:45:29.000Z</published>
    <updated>2019-03-10T10:26:33.859Z</updated>
    
    <content type="html"><![CDATA[<p><img src="thumb.png" alt=""></p><p>synchronized 키워드를 사용하는 이유를 살펴보기 전에 쓰레드를 왜 여러 개 사용하는지부터 알아보자.  </p><h2 id="쓰레드를-여러-개-멀티-쓰레딩-사용하는-이유"><a href="#쓰레드를-여러-개-멀티-쓰레딩-사용하는-이유" class="headerlink" title="쓰레드를 여러 개(멀티 쓰레딩) 사용하는 이유"></a>쓰레드를 여러 개(멀티 쓰레딩) 사용하는 이유</h2><ol><li>CPU가 I/O(파일, 네트워크 등등) 작업에 의해 Blocking 돼서 놀고 있을 때<br>만약 DB를 호출하는 작업(네트워크 I/O)이 있다고 치자.<br>I/O가 발생하면 기본적으로 CPU는 Block된다. (idle 상태에 빠져 놀고 있다.)<br>이렇게 CPU가 놀고 있을 때 다른 쓰레드가 CPU를 점유한다면 CPU는 더 이상 놀지 않게 된다.<br>이렇게 CPU의 병목을 줄이다보면 성능을 개선할 수 있다.</li><li>시분할 다중화를 통해 동시에 여러 작업이 처리되게 끔 보이게 할 때<br>문서 작성을 하면서 동시에 웹 브라우저에서 파일을 다운로드 받을 수 있는 행위는 바로 CPU에서 쓰레드를 돌아가며 작업을 처리하기 때문이다.<br>만약 파일 다운로드가 다 끝나야지만 문서 작성을 할 수 있다고 하면 얼마나 불편하겠는가?<br>물론 그렇다고 해서 진짜 동시에 여러 작업이 수행되는 게 아니라 사람이 체감 못할 정도로 시간을 쪼개서 작업을 수행하는 것이다. </li></ol><h2 id="멀티-쓰레드-프로그래밍을-할-때-생기는-문제"><a href="#멀티-쓰레드-프로그래밍을-할-때-생기는-문제" class="headerlink" title="멀티 쓰레드 프로그래밍을 할 때 생기는 문제"></a>멀티 쓰레드 프로그래밍을 할 때 생기는 문제</h2><p>쓰레드는 프로세스 내부에 존재하기 때문에 프로세스 내부의 자원을 공유한다.<br>따라서 공유 자원에 대해서 동기화 이슈가 매우 중요하다.<br>A 쓰레드의 작업이 완전히 끝나기 전에 A’라는 자원이<br>다른 쓰레드에 의해 값이 바뀌게 되면 A 쓰레드는 원하는 값을 얻어낼 수 없다.</p><h2 id="synchronized-키워드"><a href="#synchronized-키워드" class="headerlink" title="synchronized 키워드"></a>synchronized 키워드</h2><p>위와 같은 문제를 해결하기 위해서는 synchronized 키워드를 사용하여 <strong>A 쓰레드의 작업이 끝날 때까지 대기해라!</strong>라고 명령을 내릴 수 있다.<br>더 나아가 <strong>synchronized 블럭 내에 있는 공유 자원을 점유하라!</strong>라고 이해를 하는 게 좀 더 정확하다.<br>하지만 여기서 멈추면 안 된다, 좀 더 자세하게 이해해야한다.  </p><h3 id="쓰레드-로컬-변수"><a href="#쓰레드-로컬-변수" class="headerlink" title="쓰레드 로컬 변수"></a>쓰레드 로컬 변수</h3><p>CPU에서 명령을 수행하기 위해서는 메모리에 있는 데이터를 CPU로 가져와야한다.<br>하지만 메모리에 있는 데이터를 CPU로 가져오는 행위는 매우 느리므로 CPU는 캐시 메모리가 있다. (L1 캐시, L2 캐시 등등)<br>그리고 이 캐시 메모리를 <strong>쓰레드 로컬 변수</strong>라고 부른다.<br>하지만 쓰레드 <strong>로컬</strong> 변수이기 때문에 다른 쓰레드에서는 메모리에 접근을 해도 해당 쓰레드 변수의 값을 얻어올 수 없다.<br>따라서 공유 자원 A’에 대해 각각 쓰레드가 로컬 변수를 가질 수 있게 된다.</p><p>여기서 synchronized 키워드가 가지는 진정한 의미가 나온다.<br>synchronized 키워드를 사용한다는 것은 해당 블럭 내에 있는<br><strong>공유 자원 A’가 쓰레드 로컬 변수에서 램으로 써지기 까지 다른 쓰레드는 대기(block)하라</strong>라는 의미를 가진다.<br>쓰레드 로컬 변수가 램에 써진 순간 다른 쓰레드가 램에서 해당 값을 가져와서 작업할 수 있게 된다.<br>즉 DB에서 커밋이 되기 전까지 해당 레코드를 조회하는 다른 커넥션은 lock에 빠지는 것과 비슷한 뉘앙스라고 받아들이면 된다.</p><p>synchronized 키워드를 남발하게 되면 쓰레드 로컬 변수가 램에 써지기 전까지 다른 쓰레드는 block이 되므로 조심해서 사용해야한다.<br>또한 잘못 쓴다면 무한한 block을 유발하는 dead lock 이슈도 조심해야할 것이다. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;thumb.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;synchronized 키워드를 사용하는 이유를 살펴보기 전에 쓰레드를 왜 여러 개 사용하는지부터 알아보자.  &lt;/p&gt;
&lt;h2 id=&quot;쓰레드를-여러-개-멀티-쓰레딩-사용하는-이유&quot;&gt;
      
    
    </summary>
    
      <category term="Programming" scheme="https://perfectacle.github.io/categories/Programming/"/>
    
      <category term="Java" scheme="https://perfectacle.github.io/categories/Programming/Java/"/>
    
    
      <category term="Java" scheme="https://perfectacle.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>(이펙티브 자바 3판) 3장 - 모든 객체의 공통 메서드, Comparable을 구현할지 고려하라</title>
    <link href="https://perfectacle.github.io/2018/12/21/effective-java-ch03-item14-comparable-interface/"/>
    <id>https://perfectacle.github.io/2018/12/21/effective-java-ch03-item14-comparable-interface/</id>
    <published>2018-12-21T02:00:45.000Z</published>
    <updated>2019-03-10T07:22:48.251Z</updated>
    
    <content type="html"><![CDATA[<p><img src="thumb.png" alt=""></p><p>이번 아이템은 모든 객체의 부모 클래스인 Object 클래스에 있는 메서드가 아니다.<br>아예 동떨어진 믹스인 인터페이스인 Comparable와 해당 인터페이스의 유일한 메서드인 compareTo에 대한 내용이다.<br>그럼에도 불구하고 이번 챕터인 ‘모든 객체의 공통 메서드’에 넣은 이유는 모든 객체에 유용하게 쓰일 수 있는 메서드이고<br>자바 플랫폼 라이브러리의 모든 값 클래스와 Enum에서 해당 인터페이스를 구현했기 때문이 아닐까 싶다.<br>또한 compareTo 메서드를 쓰는 자바 API들(Arrays, Collections, TreeSet, TreeMap 등등)이 있기 때문에<br>compareTo 메서드를 잘만 쓰면 좁살만한 노력으로 코끼리만 한 큰 효과를 누린다고 책에서 얘기하고 있으니 이 장을 주의 깊게 봐야한다.</p><h2 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h2><p>Comparable은 믹스인 인터페이스이다.<br>그럼 이 믹스인 인터페이스가 제공하는 <strong>선택적 기능</strong>은 무엇일까?<br>바로 인스턴스 사이에 <strong>순서를 비교</strong>해주는 기능을 제공해준다.  </p><h3 id="규약"><a href="#규약" class="headerlink" title="규약"></a>규약</h3><p><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Comparable.html#compareTo(T" rel="external nofollow noopener noreferrer" target="_blank">compareTo 메서드 명세서</a>에 더 자세한 내용이 나와있으니 참고해보면 된다.  </p><p>아래에서 나오는 sgn(표현식) 표기는 수학에서 말하는 부호 함수(signum function)을 뜻하고, 표현식의 값이 음수이면 -1, 0이면 0, 양수이면 1을 반환한다.  </p><ul><li>객체가 주어진 객체보다 작으면 음의 정수를, 같으면 0을, 크면 양의 정수를 반환한다.  </li><li>객체와 비교할 수 없는 타입의 객체가 주어지면 ClassCastException을 던진다.  </li><li>Comparable을 구현한 클래스는 <code>sgn(x.compareTo(y)) == -sgn(y.compareTo(x))</code>여야한다.<br>(따라서 x.compareTo(y)는 y.compareTo(x)가 예외를 던질 때에 한해 예외를 던져야한다.)<br>이는 대칭성을 가져야한다는 의미이다.  </li><li>Comparable을 구현한 클래스는 <code>x.compareTo(y) &gt; 0</code>이고, <code>y.compareTo(z) &gt; 0</code>일 때 <code>x.compareTo(z) &gt; 0</code>이어야한다.<br>이는 추이성을 가져야한다는 의미이다.  </li><li>Comparable을 구현한 클래스는 <code>x.compareTo(y) == 0</code>일 때 <code>sgn(x.compareTo(z)) == sgn(y.compareTo(z))</code>이다.  </li><li><strong>필수는 아니지만 권장하는 규약이다, 이 규약을 명시하지 않을 때는 주석으로라도 그 사실을 명시를 해둬야한다.</strong><br>Comparable을 구현한 클래스는 <code>(x.compareTo(y) == 0) == (x.equals(y))</code>이다.<br>두 객체의 순서가 동일하다면 equals 메서드로 논리적 동치성을 비교했을 때도 동일해야한다는 얘기이다.</li></ul><p>다른 건 다 이해가 잘 되는데 마지막 규약은 왜 필수가 아닌지 이해가 되지 않을 것이다.<br>동작은 잘 하지만 어딘가 이상한 부분이 있어서 지키라고 하는 것이다.<br>뭐가 이상한지 한 번 살펴보자.<br>다음은 <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Set.html" rel="external nofollow noopener noreferrer" target="_blank">Set 인터페이스 문서</a>에 나온 내용이다.  </p><blockquote><p>sets contain no pair of elements e1 and e2 such that e1.equals(e2)</p></blockquote><p><code>e1.equals(e2)</code>와 같은 논리적 동치성이 검증된 e1과 e2의 쌍은 Set 컬렉션에서 포함하지 않는다는 내용이다.<br>이 내용 때문에 Set에는 중복을 허용하지 않는 것이다.<br>그렇다면 Set 인터페이스를 구현했고, 순서도 보장한 <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/TreeSet.html" rel="external nofollow noopener noreferrer" target="_blank">SortedSet 인터페이스</a>의 경우에는 어떨까?  </p><blockquote><p>a sorted set performs all element comparisons using its compareTo (or compare) method</p></blockquote><p>SortedSet 인터페이스는 <strong>equals 메서드 대신에 compareTo(혹은 compare) 메서드를 통해 객체를 비교</strong>하고 있다.<br>이 내용이 위에 적혀있는 Set 인터페이스의 규약을 위반한 건지는 잘 모르겠다.<br>하지만 이렇게 Set 인터페이스를 준수한 SortedSet 인터페이스가 Set 인터페이스와 뭔가 엇박자가 있기 때문에 웬만하면<br>마지막 규약인 <code>(x.compareTo(y) == 0) == (x.equals(y))</code>을 지키라는 얘기이다.</p><p>실제로 equals와 compareTo의 결과가 다른 BigDecimal 클래스를 통해 어떻게 동작하는지 알아보자.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> var one1 = <span class="keyword">new</span> BigDecimal(<span class="string">"1.0"</span>);</span><br><span class="line">    <span class="keyword">final</span> var one2 = <span class="keyword">new</span> BigDecimal(<span class="string">"1.00"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// equals와 compareTo의 결과가 다르다.</span></span><br><span class="line">    assertNotEquals(one2, one1);</span><br><span class="line">    assertEquals(<span class="number">0</span>, one1.compareTo(one2));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> HashSet&lt;BigDecimal&gt; hashSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    hashSet.add(one1);</span><br><span class="line">    hashSet.add(one2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> TreeSet&lt;BigDecimal&gt; treeSet = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    treeSet.add(one1);</span><br><span class="line">    treeSet.add(one2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 동일한 요소를 넣었지만 hashSet과 treeSet의 크기가 다르다.</span></span><br><span class="line">    assertNotEquals(hashSet.size(), treeSet.size());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// treeSet의 크기는 1이다.</span></span><br><span class="line">    assertEquals(<span class="number">1</span>, treeSet.size());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// compareTo 메서드를 사용하기 때문에 "1.0"과 "1.00"을 double로 바꾸면 중복이므로 처음 집어넣은 one1만 들어있다. </span></span><br><span class="line">    assertEquals(one1, treeSet.first());</span><br><span class="line">    assertNotEquals(one2, treeSet.first());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 하지만 contains 메서드를 사용하면 내부적으로 compareTo 메서드를 사용하기 때문에 둘 다 포함한다고 나온다.</span></span><br><span class="line">    assertTrue(treeSet.contains(one1));</span><br><span class="line">    assertTrue(treeSet.contains(one2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>또한 자식 클래스에 필드를 추가한 경우에는 compareTo 메서드 규약을 지킬 수 없다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Type</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Type</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Type</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(<span class="keyword">final</span> Type t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(number, t.number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildType</span> <span class="keyword">extends</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChildType</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> number, <span class="keyword">final</span> <span class="keyword">int</span> number2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(number);</span><br><span class="line">        <span class="keyword">this</span>.number2 = number2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(<span class="keyword">final</span> Type t)</span> </span>&#123;</span><br><span class="line">        var result = <span class="keyword">super</span>.compareTo(t);</span><br><span class="line">        <span class="keyword">if</span>(result == <span class="number">0</span> &amp;&amp; (t <span class="keyword">instanceof</span> ChildType)) &#123;</span><br><span class="line">            <span class="keyword">final</span> var child = (ChildType) t;</span><br><span class="line">            result = Integer.compare(number2, child.number2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위와 같이 부모 클래스 Type과 필드를 추가한 자식 클래스 ChildType이 있다고 해보자.<br>이 때 이 클래스들은 compareTo 메서드 규약을 지킬 수 있을까?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> var x = <span class="keyword">new</span> ChildType(<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">final</span> var y = <span class="keyword">new</span> Type(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">final</span> var z = <span class="keyword">new</span> ChildType(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 다음 규약을 준수하는지 검증해봤는데 준수하지 못한다.</span></span><br><span class="line">    <span class="comment">// Comparable을 구현한 클래스는 `x.compareTo(y) == 0`일 때 `sgn(x.compareTo(z)) == sgn(y.compareTo(z))`이다.</span></span><br><span class="line">    assertEquals(<span class="number">0</span>, x.compareTo(y));</span><br><span class="line">    assertNotEquals(sgn(x.compareTo(z)), sgn(y.compareTo(z)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">sgn</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(number &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(number &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>따라서 이를 위한 해결 방법은 상속 대신에 컴포지션을 쓰면 된다는 것이다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildType</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ChildType</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Type type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChildType</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> number, <span class="keyword">final</span> <span class="keyword">int</span> number2)</span> </span>&#123;</span><br><span class="line">        type = <span class="keyword">new</span> Type(number);</span><br><span class="line">        <span class="keyword">this</span>.number2 = number2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 부모 클래스의 기능을 쓰고 싶다면 이 메서드를 통해 접근하면 된다.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Type <span class="title">asType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(<span class="keyword">final</span> ChildType child)</span> </span>&#123;</span><br><span class="line">        var result = type.compareTo(child.type);</span><br><span class="line">        result = Integer.compare(number2, child.number2);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위의 규약들을 지키지 못한다면 compareTo 메서드를 활용하는 TreeSet, TreeMap, Collections, Arrays 등등과 어울리지 못한다.<br>즉, 좁쌀만 한 노력으로 코끼리만 한 큰 효과를 얻는 기회를 상실하게 되는 것이다!  </p><h3 id="구현"><a href="#구현" class="headerlink" title="구현"></a>구현</h3><p>Comparable 인터페이스의 compareTo 메서드를 구현하는 방법은 어렵지 않다.<br>equals 처럼 Object를 인자로 받지 않고 타입을 받기 때문에 Type 체크나 형변환이 필요치 않다.  </p><ol><li>primitive type인 경우에는 <strong>&lt;</strong>, <strong>&gt;</strong>, <strong>=</strong> 등등의 비교 연산자를 쓰기보다는<br>Wrapper Class의 compare 클래스를 이용하는 게 오류도 줄이고, 코드의 가독성도 높이는 길이다.<br>아래와 같이 해당 클래스들은 Comparable 인터페이스를 구현했기 때문이다.<br><code>public final class Integer extends Number implements Comparable&lt;Integer&gt;</code>  </li><li>참조 클래스 같은 경우에는 재귀적으로 compareTo 메서드를 호출해야한다.  </li><li>비교해야할 필드가 여러 개라면 변경 가능성이 높은 필드부터 검사를 해서 성능을 높일 수 있다.  </li></ol><h3 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h3><p>아래의 경우에 순서를 비교할 때 사용하는 인터페이스이다.</p><ol><li>Comparable을 구현하지 않은 클래스의 순서를 비교</li><li>Comparable을 구현한 클래스의 compareTo 메서드 대신에 커스텀한 로직으로 순서를 비교하고 싶은 경우<br>String 클래스의 compareTo 메서드를 보면 아래와 같이 우리가 알고 있는 기본적인 알파벳(혹은 가나다) 순으로 비교하고 있다.<br>&nbsp;     <ol><li>비교하려는 두 문자열이 latin1인지 UTF16인지 Character Set을 비교 후 compareTo 메서드 호출  </li><li>두 문자열의 길이를 구함.  <ol><li>두 문자열 중에 길이가 짧은 문자열의 길이까지만 비교(그 이후에는 비교할 문자열이 없으므로 비교가 불가능)  </li><li>비교 대상의 문자열 중 다른 값이 있으면 알파벳(혹은 가나다) 순으로 비교  </li></ol></li><li>비교 대상의 문자열이 모두 같다면 길이가 짧은 문자열이 더 작다고 판단  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> v1[] = value;</span><br><span class="line">      <span class="keyword">byte</span> v2[] = anotherString.value;</span><br><span class="line">      <span class="keyword">if</span> (coder() == anotherString.coder()) &#123;</span><br><span class="line">          <span class="keyword">return</span> isLatin1() ? StringLatin1.compareTo(v1, v2)</span><br><span class="line">                            : StringUTF16.compareTo(v1, v2);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> isLatin1() ? StringLatin1.compareToUTF16(v1, v2)</span><br><span class="line">                        : StringUTF16.compareToLatin1(v1, v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(<span class="keyword">byte</span>[] value, <span class="keyword">byte</span>[] other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = value.length;</span><br><span class="line">    <span class="keyword">int</span> len2 = other.length;</span><br><span class="line">    <span class="keyword">return</span> compareTo(value, other, len1, len2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(<span class="keyword">byte</span>[] value, <span class="keyword">byte</span>[] other, <span class="keyword">int</span> len1, <span class="keyword">int</span> len2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lim = Math.min(len1, len2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; lim; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value[k] != other[k]) &#123;</span><br><span class="line">            <span class="keyword">return</span> getChar(value, k) - getChar(other, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len1 - len2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">getChar</span><span class="params">(<span class="keyword">byte</span>[] val, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// &amp; 0xff는 unsigned value로 만들기 위함이라고 함.</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>)(val[index] &amp; <span class="number">0xff</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><p>위의 경우에는 대소문자 비교까지 하고 있는데 우리는 대소문자를 비교하지 않고 싶다면 어떻게 해야할까?  </p><ol><li>compareTo 메서드를 호출하기 전에 두 문자열을 대문자 혹은 소문자로 변환 후 compareTo 메서드 호출</li><li>Comparator 인터페이스 사용</li></ol><p>여기서는 후자를 다룰 것인데, Comparator는 인터페이스이기 때문에 대소문자를 가리지 않은 Comparator를 만들어도 되지만<br>자바에서 기본적으로 이런 기본적인 내용을 구현한 Comparator에 대한 구현체들이 있기 때문에 아래와 같이 해당 클래스를 사용하면 편하다.<br><code>String.CASE_INSENSITIVE_ORDER.compare(string1, string2)</code> </p><p>또한 자바 8부터는 인터페이스가 디폴트 메서드를 가질 수 있기 때문에 같이 간편한 기능들도 제공한다.<br>만약 아래와 같이 integer들을 가진 클래스를 비교한다고 가정했을 때 여태까지는 이렇게 해왔을 것이다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Type</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Type</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number4;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(<span class="keyword">final</span> Type t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = Integer.compare(number, t.number);</span><br><span class="line">        result = result == <span class="number">0</span> ? Integer.compare(number2, t.number2) : result;</span><br><span class="line">        result = result == <span class="number">0</span> ? Integer.compare(number3, t.number3) : result;</span><br><span class="line">        result = result == <span class="number">0</span> ? Integer.compare(number4, t.number4) : result;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>하지만 Comparator를 사용한다면 아래와 같이 간단하게 만들 수 있다. (약간의 성능 저하가 따라온다고 한다.)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Type</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Type</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number4;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(<span class="keyword">final</span> Type t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 자바의 타입 추론의 한계 때문에 처음에는 타입을 명시해줘야한다.</span></span><br><span class="line">        <span class="comment">// 이렇게 해주는 것만으로 Comparator를 구현한 것이고 이 구현체를 통해 순서를 비교할 수 있다.</span></span><br><span class="line">        <span class="keyword">return</span> Comparator.comparingInt((Type t2) -&gt; t2.number)</span><br><span class="line">                         .thenComparingInt(t2 -&gt; t2.number2)</span><br><span class="line">                         .thenComparingInt(t2 -&gt; t2.number3)</span><br><span class="line">                         .thenComparingInt(t2 -&gt; t2.number4)</span><br><span class="line">                         .compare(<span class="keyword">this</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>기본 타입을 비교하는 comparingInt(int보다 작은 short, byte 등등도 이 메서드를 사용), comparingLong, comparingDouble(double 보다 작은 float도 이 메서드 사용)<br>등등이 있고, Collection의 순서를 거꾸로 뒤집는 reversed 메서드 등등 편의성을 제공해주는 메서드들이 있다.<br>또한 기본 타입 이외에 참조 타입 비교를 위한 comparing 메서드도 제공해준다.  </p><p>또한 <strong>값의 차</strong>로 순서를 비교하는 경우에는 정수 오버플로우나 부동 소수점계산 방식에 따라서 오류를 낼 수 있다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Comparator&lt;Object&gt; comparator = <span class="keyword">new</span> Comparator&lt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">final</span> Object o1, <span class="keyword">final</span> Object o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.hashCode() - o2.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>따라서 직접 값의 차를 이용해 순서를 비교하기 보다는 Wrapper Class에서 제공해주는 compare 메서드를 사용하거나<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Comparator&lt;Object&gt; comparator = <span class="keyword">new</span> Comparator&lt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">final</span> Object o1, <span class="keyword">final</span> Object o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(o1.hashCode(), o2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>아니면 Comparator에서 제공해주는 메서드를 사용하는 게 더 안전하다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Comparator&lt;Object&gt; comparator = Comparator.comparingInt(Object::hashCode);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;thumb.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;이번 아이템은 모든 객체의 부모 클래스인 Object 클래스에 있는 메서드가 아니다.&lt;br&gt;아예 동떨어진 믹스인 인터페이스인 Comparable와 해당 인터페이스의 유일한 메서드인 
      
    
    </summary>
    
      <category term="Note" scheme="https://perfectacle.github.io/categories/Note/"/>
    
      <category term="Java" scheme="https://perfectacle.github.io/categories/Note/Java/"/>
    
    
      <category term="Java" scheme="https://perfectacle.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>(이펙티브 자바 3판) 3장 - 모든 객체의 공통 메서드, clone 재정의는 주의해서 진행해라</title>
    <link href="https://perfectacle.github.io/2018/12/16/effective-java-ch03-item13-clone-method/"/>
    <id>https://perfectacle.github.io/2018/12/16/effective-java-ch03-item13-clone-method/</id>
    <published>2018-12-16T12:50:10.000Z</published>
    <updated>2019-03-10T07:22:48.250Z</updated>
    
    <content type="html"><![CDATA[<p><img src="thumb.png" alt=""></p><p>Object 클래스는 인스턴스가 생성 가능한 Concrete class이지만 기본적으로 상속해서 사용하도록 설계됐다고 한다.<br>(그 이유는 모르겠지만… 그걸 찾으려면 또 이 장의 범위를 넘어서니 나중에 찾아보자.)<br>따라서 final이 아닌 메서드(<a href="/2018/11/26/effective-java-ch03-item10-equals-method">equals</a>, <a href="/2018/12/03/effective-java-ch03-item11-hashCode-method">hashCode</a>, toString, clone, finalize는)는 모두 메서드 오버라이딩을 염두하고 설계된 메서드이다.<br>따라서 해당 메서드를 오버라이딩 할 때는 각 메서드마다 지켜야할 규칙들이 존재한다.<br>이 규칙을 지키지 않았을 때 뻑나는 경우가 있다.<br>일반적인 클래스들(Collection Framework 등등)은 이러한 규칙들은 지켰겠지~ 하고 작성된 코드들이 많다.<br>따라서 위와 같은 규칙을 지키지 않은 채 오버라이딩을 한 클래스를 사용하면 제대로 동작하지 않을 가능성이 존재한다.</p><h2 id="믹스인-인터페이스"><a href="#믹스인-인터페이스" class="headerlink" title="믹스인 인터페이스"></a>믹스인 인터페이스</h2><p>Cloneable이 믹스인 인터페이스라고 책에서 소개하고 있는데 그럼 믹스인 인터페이스는 뭔지부터 살펴보도록 하자.<br>아이템 20: 추상 클래스 보다는 인터페이스를 우선하라(130P)를 보면 다음과 같이 정의하고 있다.  </p><blockquote><p>믹스인이란 클래스가 구현할 수 있는 타입을 말한다.<br>  믹스인을 구현한 클래스에 원래의 ‘주된 타입’ 외에도 특정 선택적 행위를 제공한다고 선언하는 효과를 준다.</p></blockquote><p>간단하게 말하서 믹스인 == 클래스가 구현할 수 있는 <strong>타입(클래스, 함수, 인터페이스 등등)</strong>이다.<br>예를 들어서 <code>Comparable</code>이란 인터페이스를 토대로 살펴보자.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>그리고 Point라는 클래스가 있다고 생각해보자.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"x: %d\ny: %d"</span>, x, y));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>그럼 Point의 믹스인(Point라는 클래스가 구현할 수 있는 타입)은 무엇일까?<br>아주 여러가지 믹스인들이 있겠지만 그 중에 하나는 Comparable이라고 말할 수 있다.<br>왜냐하면 아래와 같이 Point 클래스를 Comparable 인터페이스(타입)를 구현한 구현체로 만들 수 있기 때문이다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Point</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"x: %d\ny: %d"</span>, x, y));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(<span class="keyword">final</span> Point o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>클래스가 구현할 수 있는 타입을 왜 믹스인이라고 부르는 걸까?<br>바로 대상 타입(Point)의 주된 기능(점의 위치를 표시, print 메서드)에 선택적 기능(순서를 정함, Comparable)을 <code>혼합(mixed in)</code>한다고 해서 믹스인이라고 부른다.<br>또한 믹스인에는 함수나 클래스 등등의 타입이 있기 때문에 그냥 믹스인이라고 부르면 헷갈리기 때문에 믹스인 성격을 가진 인터페이스를 <code>믹스인 인터페이스</code>라고 부르는 것 같다.  </p><h2 id="Cloneable"><a href="#Cloneable" class="headerlink" title="Cloneable"></a>Cloneable</h2><p>Cloneable 인터페이스는 믹스인 인터페이스이다.<br>하지만 믹스인의 용도를 제대로 사용하지 않고 있다.<br>이유는 Cloneable 인터페이스를 직접 보면 알 수 있다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위에서 얘기했던 Comparable과의 차이점이 뭘까?<br>인터페이스만 있을 뿐, 구현해야하는 메서드가 아무것도 없다.<br>믹스인 인터페이스라면 선택적 기능을 제공해야하는데 제공하는 게 아무것도 없다.<br>즉, 구현해봤자 아무짝에 쓸모없는 인터페이스처럼 보인다.<br>그럼 clone 메서드의 위치는 어디일까?<br>바로 쌩뚱맞게도 Object 클래스에 clone 메서드가 있다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure></p><p>원본 메서드가 감춰져있어서 소스코드를 볼 수는 없지만 일단 객체를 복사해주는 메서드 같아 보인다.<br>또 여태까지 살펴봤던 다른 메서드와 달리 protected 메서드이다.<br>따라서 아래와 같이 리플렉션을 쓰지 않는 이상은 오버라이딩한 메서드에 접근할 수 있다는 게 보장되지 않는다.<br>하지만 리플렉션을 사용한다 하더라도 해당 메서드를 오버라이딩 하지 않은 경우에는 NoSuchMethodException 예외를 던지기 때문에 리플렉션으로도 메서드에 접근할 수 있다는 걸 100% 보장할 수 없다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyTest</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> var cloneMethod = Point.class.getDeclaredMethod(<span class="string">"clone"</span>);</span><br><span class="line">    cloneMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> var instance = <span class="keyword">new</span> Point();</span><br><span class="line">    <span class="keyword">final</span> var copy = cloneMethod.invoke(instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>오버라이딩 할 때 public으로 오버라이딩 할 수 있지만, 실수로라도 protected로 오버라이딩 할 여지가 존재하는 매우 부실한 프로토콜이다.  </p><p>그럼 아무짝에 쓸모 없어보이는 Cloneable 인터페이스는 내비두고, Object 클래스의 clone 메서드를 바로 오버라이딩 하면 될 것 같다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> x, <span class="keyword">final</span> <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 자바 5에 추가된 covariant return typing(공변 반환 타이핑, 리턴 타입이 서브 클래스의 범위 안에 있으면 된다는 내용) 덕분에 </span></span><br><span class="line">    <span class="comment">// 해당 메서드를 사용하는 사용자가 직접 형변환을 할 필요가 사라졌다.  </span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Point <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Point) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>공변성(covariant)과 반공변성(contravariant)에 대해서는 이 글의 주제를 넘어서므로 <a href="https://edykim.com/ko/post/what-is-coercion-and-anticommunism/" rel="external nofollow noopener noreferrer" target="_blank">공변성과 반공변성은 무엇인가?</a>에 들어가서 보면 된다.  </p><p>위 clone 메서드를 보면 public으로 오버라이딩 했고 전부 잘 작성한 것 같은데 컴파일이 안 된다.<br>바로 checked exception인 CloneNotSupportedException이 발생하기 때문이다.<br>이유는 해당 예외 클래스를 보면 나온다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Thrown to indicate that the clone method in class Object has been called to clone an object,</span></span><br><span class="line"><span class="comment"> * but that the object's class does not implement the Cloneable interface.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p><p>clone 메서드가 호출 됐는데 클래스가 Cloneable 인터페이스를 구현하지 않았을 때 던지는 예외란다.<br>아무런 쓸모도 없어보이던 녀석이 드디어 쓸모가 있어보인다.<br>그럼 위 예외를 없애버리기 위해 Cloneable 인터페이스를 구현해보자.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> x, <span class="keyword">final</span> <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Point <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Point) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Cloneable 인터페이스는 아무런 메서드가 없기 때문에 구현해야할 것도 아무것도 없다.<br>하지만 이럼에도 불구하고 컴파일은 되지 않고, CloneNotSupportedException이 발생한다.<br>따라서 다소 귀찮지만 아래와 같이 처리를 해주어야한다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> x, <span class="keyword">final</span> <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Point <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Point) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="comment">// Cloneable 인터페이스를 구현한 이상 이 코드는 절대 실행되지 않는다.</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같은 불편함을 초래하기 때문에 CloneNotSupportedException은 unchecked exception으로 만들었으면 더 좋았을 것 같다.<br>unchecked exception이었다면 Cloneable 인터페이스를 구현하지 않은 경우에는 런타임 에러를 뱉겠지만,<br>checked exception으로 만들어버려서 정상적으로 인터페이스를 구현한 경우에도 모두 불필요한 코드를 추가해야하는 불편함을 감수해야한다.<br>또한 Cloneable 인터페이스는 특정 클래스(Object)의 메서드(clone) 동작 방식을 결정한다는 아주 요상한 방식이니 절대 따라하면 안 되고 따라하기 힘들 것 같다.<br>우리가 위에서 선언한 clone 메서드는 <code>super.clone()</code>라는 코드로 인해 부모 클래스인 Object의 clone메서드의 결과값을 반환하는데<br>그 객체의 필드들을 하나하나 복사한 객체를 반환한다.<br>물론 primitive type만 제대로 복사하는 shallow copy이다.<br>참조 타입은 reference value를 복사하기 때문에 불변 객체가 아닌 이상은 직접 deep copy를 구현해줘야한다.  </p><p>Object.clone() 메서드의 명세서에 적혀있는 규약을 정리해보자면 다음과 같다.  </p><ul><li>x.clone() != x;</li><li>x.clone().getClass() == x</li><li>x.clone().equals(x)</li><li>이 메서드가 반환하는 객체는 super.clone()을 호출해서 얻어야한다.  </li><li>하지만 위 조건이 모두 <strong>필수는 아니다</strong>. 즉, 권장사항일 뿐이며 <strong>선택사항</strong>이다.</li></ul><p>하지만 우리는 <code>super.clone()</code>, 즉 Object 클래스의 clone 메서드를 신뢰하지 못해서 아래와 같이 직접 생성자를 사용해서 객체를 복사한다고 가정해보자.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object의 clone 메서드를 호출하는 게 아니므로 CloneNotSupportedException을 던지지 않기 때문에 Cloneable 인터페이스를 구현할 필요가 없다.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> x, <span class="keyword">final</span> <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Point <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 좀 더 메서드가 깔끔해진 것 같다.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 실제로 객체가 잘 복사됐는지 비교하기 위해 equals 메서드를 오버라이딩</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">final</span> Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Point)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> var point = (Point) o;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.x != point.x) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.y != point.y) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>테스트 코드를 통해 객체가 제대로 복사가 됐는지 알아보자.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> var point = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">final</span> var clone = point.clone();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 내부적으로 동일 연산자를 통해 다른 인스턴스인지 비교 </span></span><br><span class="line">    assertNotSame(point, clone);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 클래스 정보도 똑같다.</span></span><br><span class="line">    assertEquals(point.getClass(), clone.getClass());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 내부적으로 동등 연산자인 equals 메서드를 통해 논리적 동치성을 보장하는지 비교</span></span><br><span class="line">    assertEquals(point, clone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이번엔 Point 클래스를 상속하는데 super.clone 메서드를 사용하는 클래스가 있다고 가정해보자.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ColorPoint</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> x, <span class="keyword">final</span> <span class="keyword">int</span> y, <span class="keyword">final</span> String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(x, y);</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// java.lang.ClassCastException을 유발한다.</span></span><br><span class="line">        <span class="comment">// super.clone() 메서드로 얻어온 메서드의 반환 타입은 Point 생성자를 통해 생성된 Point 클래스 인스턴스이다. </span></span><br><span class="line">        <span class="comment">// 부모 클래스를 가지고 자식 클래스로 형변환 했을 때 자식 클래스에 필요한 필수 필드들이 들어가있지 않을 가능성이 존재해서</span></span><br><span class="line">        <span class="comment">// 변환된 클래스가 제대로 작동하리란 보장이 없기 때문에 위와 같이 예외를 던지는 게 아닐까?</span></span><br><span class="line">        <span class="comment">// 따라서 형 변환을 할 수 없기 때문에 자식 클래스에서 필드가 추가된 경우에는 제대로 clone 조차 하지 못한다.</span></span><br><span class="line">        <span class="comment">// return (ColorPoint) super.clone();</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">final</span> Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> ColorPoint)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">super</span>.equals(o)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> var colorPoint = (ColorPoint) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(color, colorPoint.color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>그럼 다시 테스트 클래스를 통해 올바르게 복사가 됐는지 확인해보자.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testColorClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> var colorPoint = <span class="keyword">new</span> ColorPoint(<span class="number">1</span>, <span class="number">2</span>, <span class="string">"red"</span>);</span><br><span class="line">    <span class="keyword">final</span> var clone = colorPoint.clone();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 내부적으로 동일 연산자를 통해 다른 인스턴스인지 비교</span></span><br><span class="line">    assertNotSame(colorPoint, clone);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 클래스 정보도 부모의 생성자를 통해서 만들었기 때문에 자식 클래스의 정보를 가지지 못한다.</span></span><br><span class="line">    assertNotEquals(colorPoint.getClass(), clone.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 내부적으로 동등 연산자인 equals 메서드를 통해 논리적 동치성을 보장하는지 비교하는데 red는 제대로 복사되지 않았음</span></span><br><span class="line">    assertNotEquals(colorPoint, clone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>자식 클래스를 구현할 필요 없는 final 클래스 등등의 경우에는 상관 없겠지만 위와 같은 사유 때문에 웬만하면 Object.clone() 메서드 명세서의 규약은 준수하는 게 좋다.</p><p>그럼 가변 객체가 있을 때는 어떻게 구현해야할까?<br>우선 간단하게 배열을 필드로 가지고 있는 객체를 예로 들어보자.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Type</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">private</span> Type[] children;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Type</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> number, <span class="keyword">final</span> Type[] children)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">        <span class="keyword">this</span>.children = children;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Type[] getChildren() &#123;</span><br><span class="line">        <span class="keyword">return</span> children;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setChildren</span><span class="params">(<span class="keyword">final</span> Type[] children)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.children = children;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Type <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Type) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">final</span> Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Type)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> var type = (Type) o;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.number != type.number) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(!Arrays.equals(<span class="keyword">this</span>.children, type.children)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>그럼 clone 메서드가 우리가 생각하는대로 동작하는지 알아보자.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> var original = <span class="keyword">new</span> Type(<span class="number">3</span>, <span class="keyword">new</span> Type[]&#123;<span class="keyword">new</span> Type(<span class="number">1</span>, <span class="keyword">null</span>), <span class="keyword">new</span> Type(<span class="number">2</span>, <span class="keyword">null</span>)&#125;);</span><br><span class="line">    <span class="keyword">final</span> var clone = original.clone();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 원본 객체에서 첫 번째 자식을 다른 자식으로 대체</span></span><br><span class="line">    original.getChildren()[<span class="number">0</span>] = <span class="keyword">new</span> Type(<span class="number">4</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clone과 original이 완전 독립된 객체라면 이 테스트는 통과해선 안 된다.</span></span><br><span class="line">    assertEquals(original, clone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>우리가 의도한 대로 동작하지 않음(둘이 완전히 독립된 객체이길 원함)을 볼 수 있다.<br>그렇다면 우리의 의도대로 동작하게 끔 clone 메서드를 변경해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Type <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> var clone = (Type) <span class="keyword">super</span>.clone();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 배열의 clone 메서드는 공변 반환 타이핑도 제대로 적용했고 unchecked exception인 CloneNotSupportedException도 제대로 처리한 유일한 예라고 책에서 설명하고 있다.</span></span><br><span class="line">        <span class="comment">// 하지만 가변 객체를 참조하는 필드는 final로 선언하라는 용법과는 상반된다.  </span></span><br><span class="line">        <span class="comment">// final로 선언해도 완전 불변 객체를 만드는 것은 아니지만 적어도 레퍼런스 값이 바뀌는 경우는 막을 수 있으니까 final로 선언하라는 용법이 있는 것으로 알고 있는데</span></span><br><span class="line">        <span class="comment">// 이 용법을 사용하면 가변 객체의 clone을 할당할 수 없다.</span></span><br><span class="line">        clone.children = <span class="keyword">this</span>.children.clone();</span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 변경했다면 위 테스트는 통과하지 못하고 <code>assertNotEquals(original, clone);</code>와 같이 변경해야 테스트를 통과시킬 수 있고 우리의 의도대로 동작한다.  </p><p>하지만 이마저도 얕은 복사이고 아래의 경우에는 객체의 완벽한 독립을 보장하지 못한다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> var original = <span class="keyword">new</span> Type(<span class="number">3</span>, <span class="keyword">new</span> Type[]&#123;<span class="keyword">new</span> Type(<span class="number">1</span>, <span class="keyword">null</span>), <span class="keyword">new</span> Type(<span class="number">2</span>, <span class="keyword">null</span>)&#125;);</span><br><span class="line">    <span class="keyword">final</span> var clone = original.clone();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 자식을 재할당하는 게 아니라 자식의 필드를 변경</span></span><br><span class="line">    original.getChildren()[<span class="number">0</span>].setNumber(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clone과 original이 완전 독립된 객체라면 이 테스트는 통과해선 안 된다.</span></span><br><span class="line">    assertEquals(original, clone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>아래와 같이 재귀를 통해 깊은 복사를 하면 우리가 원하는 문제를 해결할 수 있다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Type <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> var clone = (Type) <span class="keyword">super</span>.clone();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 배열의 clone 메서드는 공변 반환 타이핑도 제대로 적용했고 unchecked exception인 CloneNotSupportedException도 제대로 처리한 유일한 예라고 책에서 설명하고 있다.</span></span><br><span class="line">        clone.children = childrenDeepCopy(clone.children);</span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Type[] childrenDeepCopy(<span class="keyword">final</span> Type[] parent) &#123;</span><br><span class="line">    <span class="keyword">final</span> var shallowClone = parent.clone();</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(shallowClone)</span><br><span class="line">                 .map(origin -&gt; <span class="keyword">new</span> Type(origin.number, origin.hasChildren() ? childrenDeepCopy(origin.children) : <span class="keyword">null</span>))</span><br><span class="line">                 .toArray(Type[]::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> children != <span class="keyword">null</span> &amp;&amp; children.length != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>하지만 재귀 함수의 단점은 자식의 깊이가 깊을 수록 재귀 호출을 통해 스택 프레임을 사용하기 때문에 스택 오버플로우를 유발할 수도 있다는 점이다.<br>따라서 깊은 복사는 반복을 통해 풀 수 있다면 반복으로 푸는 것이 좋다.  </p><p>또한 상속용으로 설계된 부모 클래스에서 clone을 재정의할 경우, 해당 메서드에서는 다른 재정의 가능한 메서드를 호출하면 안 된다.<br>이유는 자식 클래스에서 clone을 재정의 했을 경우 연쇄적으로 <code>super.clone();</code>을 호출하기 때문에 부모의 clone 메서드를 호출하게 된다.<br>그 과정에서 부모의 clone 메서드에서 재정의 가능한 어떤 메서드를 호출한다면 부모 클래스의 메서드를 호출하는 게 아니라 자식 클래스에서 재정의한 메서드를 호출하기 때문이다.<br>정확하게 어떻게 예를 들어야할지 모르겠다… (다소 억지스러운 것들 밖에 안 떠올라서…)</p><p>위와 같은 오동작을 불러일으킬 수 있기 때문인지 책(84P)에서는 상속해서 쓰기 위한 클래스 설계 방식 두 가지<br>(재정의 할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남긴 클래스,<br>내부 동작 과정 중간에 끼어들 수 있는 hook을 잘 선별하여 protected 메서드 형태로 공개한 클래스)<br>에서도 Cloneable 구현 자체를 하지 말라고 하고 있다.<br>clone 메서드를 깊은 복사까지 구현만 해놓고 Cloneable 인터페이스는 구현하지 않아서 하위 클래스에게 Cloneable 구현 여부를 선택하게 끔 하거나,<br>아래와 같이 clone 메서드를 재정의하는데 하위 클래스에서 재정의하지 못하게 하는 것이다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Type <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    <span class="comment">// 자식 클래스에서는 super.clone()을 통해 clone 메서드를 재정의 하니까 무조건 부모 클래스의 clone 메서드를 호출하게 돼있다.</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> CloneNotSupportedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>또한 clone 메서드는 동기화(멀티 쓰레드로 돌아가는 환경에서 공유 자원에 대해 일관성 유지)도 고려돼있지 않기 때문에 동기화도 적절히 해줘야한다.</p><p>이러한 허술한 메커니즘 기반인 clone 보다는 아래와 같은 방법 중 하나를 추천한다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 복사 생성자</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Type</span><span class="params">(<span class="keyword">final</span> Type type)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 복사 팩터리 (복사 생성자를 모방한 정적 팩터리)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Type <span class="title">newInstance</span><span class="params">(<span class="keyword">final</span> Type type)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></p><p>위와 같은 방법을 쓰면 허술한 메커니즘 뿐만 아니라 불필요한 checked exception 처리, final 필드 용법, 형변환 등등에서 자유로워 질 수 있다.<br>또한 인자로 해당 클래스가 구현한 인터페이스 타입도 받을 수 있기 때문에 원본 클래스의 타입에 얽매이지 않고 사용할 수도 있다는 장점이 존재한다.   </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;thumb.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Object 클래스는 인스턴스가 생성 가능한 Concrete class이지만 기본적으로 상속해서 사용하도록 설계됐다고 한다.&lt;br&gt;(그 이유는 모르겠지만… 그걸 찾으려면 또 이 장의
      
    
    </summary>
    
      <category term="Note" scheme="https://perfectacle.github.io/categories/Note/"/>
    
      <category term="Java" scheme="https://perfectacle.github.io/categories/Note/Java/"/>
    
    
      <category term="Java" scheme="https://perfectacle.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>(이펙티브 자바 3판) 3장 - 모든 객체의 공통 메서드, equals를 재정의하려거든 hashCode도 재정의하라</title>
    <link href="https://perfectacle.github.io/2018/12/03/effective-java-ch03-item11-hashCode-method/"/>
    <id>https://perfectacle.github.io/2018/12/03/effective-java-ch03-item11-hashCode-method/</id>
    <published>2018-12-03T11:42:39.000Z</published>
    <updated>2019-03-10T07:22:48.248Z</updated>
    
    <content type="html"><![CDATA[<p><img src="thumb.png" alt=""></p><p>Object 클래스는 인스턴스가 생성 가능한 Concrete class이지만 기본적으로 상속해서 사용하도록 설계됐다고 한다.<br>(그 이유는 모르겠지만… 그걸 찾으려면 또 이 장의 범위를 넘어서니 나중에 찾아보자.)<br>따라서 final이 아닌 메서드(<a href="/2018/11/26/effective-java-ch03-item10-equals-method">equals</a>, <a href="#hashCode">hashCode</a>, toString, <a href="/2018/12/16/effective-java-ch03-item13-clone-method">clone</a>, finalize는)는 모두 메서드 오버라이딩을 염두하고 설계된 메서드이다.<br>따라서 해당 메서드를 오버라이딩 할 때는 각 메서드마다 지켜야할 규칙들이 존재한다.<br>이 규칙을 지키지 않았을 때 뻑나는 경우가 있다.<br>일반적인 클래스들(Collection Framework 등등)은 이러한 규칙들은 지켰겠지~ 하고 작성된 코드들이 많다.<br>따라서 위와 같은 규칙을 지키지 않은 채 오버라이딩을 한 클래스를 사용하면 제대로 동작하지 않을 가능성이 존재한다.</p><h2 id="들어가기에-앞서…"><a href="#들어가기에-앞서…" class="headerlink" title="들어가기에 앞서…"></a>들어가기에 앞서…</h2><p>equals 메서드와 마찬가지로 hashCode를 오버라이딩 할 경우는 거의 없다.<br>대부분 hashCode를 쓰는 쪽은 HashMap, HashSet 등등이다.<br>이 마저도 키에다가 equals를 오버라이딩 한 클래스를 사용할 때이다.<br>실무에서 대부분 키로 String, Integer를 쓰지, 해당 클래스를 써본 적은 한 번도 없다.<br>(물론 특수한 경우에는 존재할 수도 있지만, 아주 특수할 것이다.)<br>따라서 이런 아주 특수한 경우를 제외하고는 딱히 hashCode를 오버라이딩 할 이유가 없으니 이 글도 딱히 읽을 필요도 없다.<br>그래도 혹여나 실무에서 당장 hashCode를 오버라이딩 하려면 세 가지 방법이 존재한다.<br><del>내가 당신의 시간을 아껴주겠다.</del><br>그래도 공부 측면 등등에서 꼭 알아야하는 내용임에는 틀림이 없는 것 같다.</p><ol><li>구글에서 만든 <a href="https://github.com/google/auto/tree/master/value" rel="external nofollow noopener noreferrer" target="_blank">AutoValue</a> 사용하기. (권장)<br>아주 사용하기가 간단하다.<br>바로 클래스 위에 <code>@AutoValue</code> 어노테이션만 달아주면 끝이다.<br>(물론 equals, hashCode, toString 메서드까지 다 오버라이딩 해준다.)<br>클래스가 변경돼도 hashCode 쪽 소스코드를 수정할 필요가 없다.<br>얘는 자바 6부터 지원한다.  </li><li>IDEA가 생성해준 소스 코드 사용하기.<br>여러가지 규칙을 직접 찾아보며 구현하기 귀찮으니까 생성해주는 코드를 사용하면 된다.<br>인텔리제이 IDEA가 생성한 코드니 신뢰하고 써도 될 것이다.<br>단점으로 클래스가 변경될 때마다 hashCode 쪽 소스도 넣어줘야해서 귀찮다.    </li><li>직접 구현하기<br>이 글을 보고 직접 구현해보면 될 것 같다.</li></ol><h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h2><blockquote><p>Returns a hash code value for the object.<br>  This method is supported for the benefit of hash tables such as those provided by HashMap.<br>  <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#hashCode()" rel="external nofollow noopener noreferrer" target="_blank">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#hashCode()</a></p></blockquote><p>object의 해시 값을 반환하는 메서드이다.<br>key를 해싱해서 인덱스를 만들고, 해당 인덱스의 버킷(저장 공간)에 값을 저장하는 자료구조인 <a href="https://en.wikipedia.org/wiki/Hash_table" rel="external nofollow noopener noreferrer" target="_blank">Hash Table</a>에서 사용된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드는 <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/HashMap.html" rel="external nofollow noopener noreferrer" target="_blank">HashMap</a> 클래스의 get 메서드인데 내부적으로 타고들어가다보면 Object의 hashCode 메서드를 사용해서 key의 hashCode를 구해서 원하는 value를 구하고 있다.    </p><p>이제 hashCode의 규약을 알아보자.  </p><ol><li>Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified.<br>This integer need not remain consistent from one execution of an application to another execution of the same application.<br>equals 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 그 객체의 hashCode 메서드는 몇 번을 호출해도 일관되게 항상 같은 값을 반환해야 한다.<br>단, 어플리케이션을 다시 실행한다면 이 값이 달라져도 상관없다.</li><li>If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result.<br>equals(Object)가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환해야한다.  </li><li>It is not required that if two objects are unequal according to the equals(java.lang.Object) method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hash tables.<br>equals(Object)가 두 객체를 다르다고 판단했더라도, 두 객체의 hashCode가 서로 다른 값을 반환할 필요는 없다.<br>단, 다른 객체에 대해서는 다른 값을 반환해야 해시 테이블의 성능이 좋아진다.</li></ol><p>어, 지루하게 hashCode의 규약에 대해 살펴봤으니 우리가 간단하게 만든 클래스가 hashCode의 규약을 준수하는지 알아보자.<br>우선 간단한 클래스를 만들어보자.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> x, <span class="keyword">final</span> <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Point)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> var obj = (Point) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(obj.x != <span class="keyword">this</span>.x) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(obj.y != <span class="keyword">this</span>.y) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이 클래스가 동치 관계를 준수하면서 equals 메서드를 구현했는지 간단하게 검증해보자.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// reflexive</span></span><br><span class="line">    <span class="keyword">final</span> var x = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    assertEquals(x, x);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// symmetric</span></span><br><span class="line">    <span class="keyword">final</span> var y = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    assertEquals(x, y);</span><br><span class="line">    assertEquals(y, x);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// transitive</span></span><br><span class="line">    <span class="keyword">final</span> var z = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    assertEquals(y, z);</span><br><span class="line">    assertEquals(x, z);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// consistent</span></span><br><span class="line">    assertEquals(x, x);</span><br><span class="line">    assertEquals(x, y);</span><br><span class="line">    assertEquals(y, x);</span><br><span class="line">    assertEquals(y, z);</span><br><span class="line">    assertEquals(x, z);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// For any non-null reference value x, x.equals(null) should return false.</span></span><br><span class="line">    assertNotEquals(x, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>5가지 규칙을 모두 지킨 참된 equals 메서드이다.<br>그럼 이 클래스가 HashMap에서도 key로써 제대로 역할을 수행하는지 알아보자.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 두 인스턴스가 같다고 판단(내부적으로 equals 메서드 사용)</span></span><br><span class="line">    assertEquals(<span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">1</span>), <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1번 규칙에 의하면 몇 번을 호출하더라도 동일한 hashCode가 나와야하는데 동일한 값이 나오지 않았음.</span></span><br><span class="line">    <span class="comment">// 사실 이 스트림은 한 번만 호출되더라도 !h.equals(hashCode) 조건을 만족하기 때문에 한 번 밖에 돌지 않음.</span></span><br><span class="line">    <span class="keyword">final</span> var hashCode = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">1</span>).hashCode();</span><br><span class="line">    <span class="keyword">final</span> var result = IntStream.range(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">                                .mapToObj(i -&gt; <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">1</span>).hashCode())</span><br><span class="line">                                .anyMatch(h -&gt; !h.equals(hashCode));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 단 두 번만 호출했는데도 불구하고 둘이 다른 해시코드가 나옴.</span></span><br><span class="line">    assertNotEquals(<span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">1</span>).hashCode(), <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">1</span>).hashCode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 서로 다른 해시코드를 내뱉기 때문에 키의 역할을 제대로 수행하지 못하고 있음.</span></span><br><span class="line">    <span class="keyword">final</span> var map = <span class="keyword">new</span> HashMap&lt;Point, Integer&gt;();</span><br><span class="line">    map.put(<span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line">    assertNull(map.get(<span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>제대로 규칙을 이행하는 게 하나도 없다.<br>그렇다면 기본 메서드인 Object.hashCode()는 어떻게 구현이 돼있길래 저런 결과가 나온 걸까…?  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>내부 구현이 다 숨겨져 있다.<br>주석을 살펴보면 아래와 같이 나와있다.  </p><blockquote><p>As much as is reasonably practical, the hashCode method defined by class Object does return distinct integers for distinct objects.<br>  (The hashCode may or may not be implemented as some function of an object’s memory address at some point in time.)<br>  <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#hashCode()" rel="external nofollow noopener noreferrer" target="_blank">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#hashCode()</a></p></blockquote><p><strong>object’s memory address</strong>가 핵심인 것 같다.<br>객체의 참조값을 가지고 해싱을 한다는 것 같은데, 모든 객체 인스턴스는 싱글턴이 아닌 이상 각각 고유한 참조값을 가지고 있으므로<br>hashCode의 기본 메서드로를 모든 인스턴스마다 고유한 hashCode를 생산한다.<br>하지만 우리가 구현한 equals 메서드에 따르면 각 인스턴스마다 equals 값이 true로 나오고 있으므로 hashCode도 동일한 값이 나와야하는데<br>그러고 있지 않으므로, 우리가 만든 클래스는 hashCode의 규약을 준수하지 못한 경우이다.<br>따라서 equals 메서드를 오버라이딩 했으면 거의 hashCode도 같이 오버라이딩 해줘야 hashCode의 규약을 준수해서 hashMap 등등에서 key로써 제대로 된 역할을 수행한다고 말할 수 있다.  </p><p>아주 간단하게 해시 코드를 작성해보면 다음과 같다.<del>(실무에서 절대 쓰면 안된다.)</del><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이렇게 구현하면 물론 <code>equals 비교에 사용되는 정보가 변경됐는데도 똑같은 해시 값을 반환</code>하므로 1번 규약을 지키지는 못한다.<br>또한 모두 같은 해시 값을 반환하기 때문에 충돌이 발생하게 되는데 이 경우에는 index가 가리키고 있는 LinkedList 혹은 Tree에 값을 추가해서 데이터의 유실을 방지한다.<br>따라서 해시 테이블의 단 하나의 버킷에 저장하기 때문에 평균 수행 시간이 O(n)으로 느려진다.<br>이상적인 해시 값이라면 hashCode 규약을 준수하고, O(1)의 수행속도를 가져야한다. (각기 다른 버킷에 값을 저장하고, 따라서 충돌이 아주 적은…)  </p><p>책에 나와있는 hashCode 작성법을 글로만 읽으면 이해가 안 되니 코드와 함께 이해해보자.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> String y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] z;</span><br><span class="line">    <span class="keyword">private</span> Type t;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Type)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> var obj = (Type) o;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 첫 번째 핵심 필드 x</span></span><br><span class="line">        <span class="keyword">if</span>(obj.x != <span class="keyword">this</span>.x) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(obj.y.equals(<span class="keyword">this</span>.y)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(Arrays.equals(obj.z, <span class="keyword">this</span>.z)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 필드 t는 아예 equals 메서드에서 제외하였다.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 첫 번째 핵심 필드 x의 해시값을 구함.</span></span><br><span class="line">        <span class="comment">// primitive type이기 때문에 WrapperClass.hashCode() 메서드를 통해 해시값을 구함.</span></span><br><span class="line">        var result = Integer.hashCode(x);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 그 다음 핵심필드 y는 참조 타입이기 때문에 참조 타입의 hashCode() 메서드 사용.</span></span><br><span class="line">        result = result * <span class="number">31</span> + y.hashCode();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 그 다음 핵심필드 z는 배열이고, 그 내부 원소가 모두 equals에 사용된 핵심 원소이므로 Arrays.hashCode() 메서드를 통해 구현.</span></span><br><span class="line">        <span class="comment">// 만약 특정 원소만 핵심 원소라면 해당 원소들에 대해서 for-loop 돌면서 hashCode를 구하면 됨.</span></span><br><span class="line">        result = result * <span class="number">31</span> + Arrays.hashCode(z);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// equals 메서드에 사용되지 않은, 핵심필드가 아닌 t는 hashCode에서 사용하면 안 됨.</span></span><br><span class="line">        <span class="comment">// equals 메서드를 통해 같다고 판단한 객체가 서로 다른 hashCode를 내뱉는 현상이 발생해 hashCode 규약을 지키지 못할 수 있음.</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 위에서 구한 result를 반환.</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Q: 왜 기존 값에 해시코드를 더하지 않고, 31을 곱한 후에 더하는가?</strong><br>A: 아래의 예제를 통해 알아보자.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Type)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> var obj = (Type) o;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 첫 번째 핵심 필드 x</span></span><br><span class="line">        <span class="keyword">if</span>(obj.x != <span class="keyword">this</span>.x) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(obj.y != <span class="keyword">this</span>.y) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 첫 번째 핵심 필드 x의 해시값을 구함.</span></span><br><span class="line">        <span class="comment">// primitive type이기 때문에 WrapperClass.hashCode() 메서드를 통해 해시값을 구함.</span></span><br><span class="line">        var result = Integer.hashCode(x);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 그 다음 핵심필드 y도 primitive type이기 때문에 WrapperClass.hashCode() 메서드를 통해 해시값을 구함.</span></span><br><span class="line">        result += Integer.hashCode(y);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 위에서 구한 result를 반환.</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>여기서 {x=1, y=2}와 {x=2, y=1}은 동등(equals)하지 않다.<br>하지만 각 원소의 집합은 {1, 2}로 동일하기 때문에 해시코드를 구하면 일치하게 된다.<br>이런 충돌을 줄이고자 31을 곱하는 것이다. (이는 String의 hashCode 메서드를 봐도 마찬가지다.)  </p><p><strong>Q: 왜 31을 곱하는가?</strong><br>A: 31이 소수이기 때문이란다.  </p><p><strong>Q: 왜 소수를 곱하는가?</strong><br>A: Modulo operation(나머지 연산)에서 충돌을 줄이기 위함이라고 한다.<br>해시 함수의 예제를 구글링해보면 나머지 연산을 통해 해시 값을 구하는 예제가 참 많다.<br>실제로 나머지 연산을 통해 해시값을 구할 때는 소수로 나누는 것이 훨씬 충돌 횟수가 적다. (입력값이 균일하게 분포돼있지 않다는 전제 하에…)<br>그래서인지 곱하는 수도 소수를 곱하는 것 같다.<br>하지만 명확하게 왜 소수를 곱하는지는 아직 찾지 못했다.</p><p><strong>Q: 충돌이 일어나면 어떻게 동작하는가?</strong><br><a href="https://d2.naver.com/helloworld/831311" rel="external nofollow noopener noreferrer" target="_blank">Java HashMap은 어떻게 동작하는가?</a>에 자세히 설명돼있다.<br>우선 데이터의 유실을 막기 위해 어디다가 저장하긴 해야한다.<br>이를 위한 여러가지 동작 방식이 있는데 자바에서는 Separate Chaining 방식을 채택해서 버킷을 Linked List로 구현했다.<br>자바 8에서는 <strong>데이터의 개수가 일정 이상일 때에는 링크드 리스트 대신 트리를 사용하는 것이 성능상 이점</strong>이 있다는 점을 토대로<br>동일한 버킷에 데이터가 8개가 되면 Tree로 변경하고, 다시 6개로 줄어들면 LinkedList로 변경한다.<br>8과 6 사이에 2라는 차이를 둔 것은 삽입과 삭제가 빈번하게 일어났을 때 Tree <-> LinkedList의 잦은 변환을 막고자 그렇게 구현했다고 한다.<br>또한 Tree가 메모리를 더 많이 먹고, 데이터 갯수가 적을 때는 Worst Case가 LinkedList와 큰 차이가 없기 때문에 처음에는 LinkedList로 만든다고 한다.<br>따라서 해시 코드가 충돌되더라도 일단 데이터는 저장되니 데이터의 유실은 막는다.<br>하지만 충돌이 잦을 수록 검색 성능은 나빠지니 최대한 충돌이 적은 알고리즘을 찾아야한다.<br>그리고 충돌이 발생하더라도 해당 키값에 대한 동등(equals) 비교가 일치하는 키 값이 없으면 null을 반환하게 된다.</-></p><p><strong>Q: 그 많은 소수 중에 왜 31인가? (추측)</strong><br>31은 2⁵ - 1이다.<br>이를 비트 연산자로 표기하면 2 &lt;&lt; 5 - 1이다.<br>왼쪽으로 n칸 이동하면 2ⁿ만큼 곱했다고 보면 된다.<br>cpu는 비트 연산에 매우 최적화 돼있다.<br>그리고 31은 1만 빼면 되는데, 37((2 &lt;&lt; 5) + 6)은 6을 더해야하니 31이 더 빠르지 않을까?<br>31보다는 37이 더 충돌 횟수가 적긴 할텐데, 아마 31만으로도 충분히 충돌 횟수를 많이 줄일 수 있어서 굳이 37을 안 쓰는 게 아닐까 싶다…<br>즉, 성능과 충돌 사이의 밸런스를 찾다보니 31이 나온 건 아닌가 싶다.  </p><p>그리고 해시값을 구하는데 소수를 이용하는 거 보다 더 나은 알고리즘들이 있다고 하니 직접 찾아보는 것도 좋을 것 같다.</p><p>또한 위와 같이 일일이 귀찮게 hashCode를 계산하기 보다는 아래와 같이 할 수 있다.<br>하지만 박싱/언박싱 및 입력값을 담기 위한 배열 생성 비용 등등으로 인해 성능 측면에서는 조금 아쉽긴 하다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Array가 아닌 타입은 모두 Objects.hash() 메서드로 해시값을 구할 수 있다.</span></span><br><span class="line">    <span class="keyword">int</span> result = Objects.hash(x, y, t);</span><br><span class="line">    result = <span class="number">31</span> * result + Arrays.hashCode(z);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 어차피 Objects.hash() 메서드를 따라들어가보면 Arrays.hashCode()를 사용하고 있다.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.hashCode(values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>혹은 클래스가 불변인 경우에는 생성 당시에 해시코드 값을 미리 캐싱해놓는 것도 좋다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Type</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> x, <span class="keyword">final</span> String y, <span class="keyword">final</span> <span class="keyword">double</span>[] z, <span class="keyword">final</span> Type t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">    <span class="keyword">this</span>.z = z;</span><br><span class="line">    <span class="keyword">this</span>.t = t;</span><br><span class="line">    <span class="keyword">this</span>.hash = hashCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>하지만 해시코드 생성 비용이 큰 경우에는 해시코드 값을 사용하기 전까지는 지연 초기화를 시켜놓으면 된다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(hash != <span class="number">0</span>) <span class="keyword">return</span> hash;</span><br><span class="line">    </span><br><span class="line">    var result = Objects.hash(x, y, t);</span><br><span class="line">    result = <span class="number">31</span> * result + Arrays.hashCode(z);</span><br><span class="line">    hash = result;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;thumb.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Object 클래스는 인스턴스가 생성 가능한 Concrete class이지만 기본적으로 상속해서 사용하도록 설계됐다고 한다.&lt;br&gt;(그 이유는 모르겠지만… 그걸 찾으려면 또 이 장의
      
    
    </summary>
    
      <category term="Note" scheme="https://perfectacle.github.io/categories/Note/"/>
    
      <category term="Java" scheme="https://perfectacle.github.io/categories/Note/Java/"/>
    
    
      <category term="Java" scheme="https://perfectacle.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>(이펙티브 자바 3판) 3장 - 모든 객체의 공통 메서드, equals는 일반 규약을 지켜 재정의하라</title>
    <link href="https://perfectacle.github.io/2018/11/26/effective-java-ch03-item10-equals-method/"/>
    <id>https://perfectacle.github.io/2018/11/26/effective-java-ch03-item10-equals-method/</id>
    <published>2018-11-25T16:16:30.000Z</published>
    <updated>2019-03-10T07:22:48.245Z</updated>
    
    <content type="html"><![CDATA[<p><img src="thumb.png" alt=""></p><p>Object 클래스는 인스턴스가 생성 가능한 Concrete class이지만 기본적으로 상속해서 사용하도록 설계됐다고 한다.<br>(그 이유는 모르겠지만… 그걸 찾으려면 또 이 장의 범위를 넘어서니 나중에 찾아보자.)<br>따라서 final이 아닌 메서드(<a href="#equals">equals</a>, <a href="/2018/12/03/effective-java-ch03-item11-hashCode-method">hashCode</a>, toString, <a href="/2018/12/16/effective-java-ch03-item13-clone-method">clone</a>, finalize는)는 모두 메서드 오버라이딩을 염두하고 설계된 메서드이다.<br>따라서 해당 메서드를 오버라이딩 할 때는 각 메서드마다 지켜야할 규칙들이 존재한다.<br>이 규칙을 지키지 않았을 때 뻑나는 경우가 있다.<br>일반적인 클래스들(Collection Framework 등등)은 이러한 규칙들은 지켰겠지~ 하고 작성된 코드들이 많다.<br>따라서 위와 같은 규칙을 지키지 않은 채 오버라이딩을 한 클래스를 사용하면 제대로 동작하지 않을 가능성이 존재한다.  </p><h2 id="들어가기에-앞서…"><a href="#들어가기에-앞서…" class="headerlink" title="들어가기에 앞서…"></a>들어가기에 앞서…</h2><p>equals 메서드를 오버라이딩 할 경우는 거의 없다.<br>대부분 핵심 필드의 값이 일치하는지 파악하기 위해서 오버라이딩 할 것이다.<br>그런 경우를 제외하고는 대부분 기본적인 레퍼런스 값 비교만으로도 충분히 비교가 가능하기 때문이다.<br>equals 메서드를 오버라이딩 하는 건 그렇게 어렵지 않지만 몇가지 원칙이 있고, 글의 길이가 짧은 편도 아니고 얻는 수확이 크지 않다. (애초에 오버라이딩 할 일이 거의 없으니…)<br>그래서 <code>지금 당장 오버라이딩을 해야한다!</code> 싶을 때는 두 가지 방법이 있다.<br><del>내가 당신의 시간을 아껴주겠다.</del><br>그래도 공부 측면 등등에서 꼭 알아야하는 내용임에는 틀림이 없는 것 같다.</p><ol><li>구글에서 만든 <a href="https://github.com/google/auto/tree/master/value" rel="external nofollow noopener noreferrer" target="_blank">AutoValue</a> 사용하기. (권장)<br>아주 사용하기가 간단하다.<br>바로 클래스 위에 <code>@AutoValue</code> 어노테이션만 달아주면 끝이다.<br>(물론 equals, hashCode, toString 메서드까지 다 오버라이딩 해준다.)<br>클래스가 변경돼도 hashCode 쪽 소스코드를 수정할 필요가 없다.<br>얘는 자바 6부터 지원한다.  </li><li>IDEA가 생성해준 소스 코드 사용하기.<br>사람이라면 실수를 하게 되니 IDE의 도움을 절실히 원하게 된다.<br>하지만 클래스가 변하는 경우에 equals 코드도 계속해서 변경해줘야하니 구찮다…<br>또 잘 짰는지 테스트 코드도 짜야하고… 테스트 코드도 변경해야하고…  </li></ol><h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><p>equals 메서드는 오버라이딩 하기 쉬워보이지만 자칫했다가는 규칙을 어길 가능성도 곳곳에 존재한다.<br>따라서 책에서 이런 가능성을 없애는 가장 좋은 방법은 오버라이딩 하지 않는 것이라고 한다.<br>나도 내가 딱히 이런 equals 메서드를 직접 정의해본 기억은 거의 없다.  </p><p>우선 우리가 오버라이딩 하지 않았을 때는 어떤 비즈니스 로직을 수행하고 있는지 모든 클래스의 부모 격인 Object 클래스의 equals 메서드를 까보자.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>정말 별 거 없다.<br>그냥 == 연산을 통해 레퍼런스를 비교하는 정도이다.<br>만약 클래스의 논리적 동치성(같은 레퍼런스가 아닐지라도 특정 필드의 값이 같다던지… 등등)을 확인하고 싶다면 equals 메서드를 오버라이딩 해야한다.<br>가장 좋은 예가 Integer, String 클래스 등등이다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">        <span class="keyword">return</span> value == ((Integer)obj).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위 예는 Integer 클래스의 equals 메서드이다.<br>레퍼런스를 가지고 비교하는 게 아니라 인스턴스가 가지고 있는 value(primitive type인 int)들끼리 비교하고 있다.<br>혹은 인스턴스가 하나 뿐이라고 보장된 클래스(싱글턴)는 레퍼런스 비교만으로도 논리적 동치성을 보장하니 굳이 equals 메서드를 오버라이딩 할 필요가 없다.</p><p>그렇다면 equals에 어떤 규칙이 있는지는 아래 문서를 참고해 하나씩 알아보자.<br><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object" rel="external nofollow noopener noreferrer" target="_blank">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)</a>)  </p><h3 id="equivalence-relation-동치-관계"><a href="#equivalence-relation-동치-관계" class="headerlink" title="equivalence relation(동치 관계)"></a>equivalence relation(동치 관계)</h3><blockquote><p>The equals method implements an equivalence relation on non-null object references<br>  euqals 메서드는 non-null object 레퍼런스에 대해 equivalence relation(동치 관계)를 구현해야한다.<br>  <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)" rel="external nofollow noopener noreferrer" target="_blank">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)</a></p></blockquote><p>아까부터 논리적 동치성이니, 동치 관계니, 계속 동치 동치 거리는데 일단 동치가 뭔지 알아보자.<br><del>동치미도 아니고…</del>~</p><p>책에서는 <code>동치 관계</code>에 대해 아래와 같이 설명하고 있다.  </p><blockquote><p>집합을 서로 같은 원소들로 이뤄진 부분집합으로 나누는 연산이다.<br>  이 부분집합을 동치류(equivalence class; 동치 클래스)라 한다.<br>  equals 메서드가 쓸모 있으려면 모든 원소가 같은 동치류에 속한 어떤 원소와도 서로 교환할 수 있어야한다.</p></blockquote><p>그냥 읽어선 뭔 소린지 모르겠다.<br>그림으로 이해를 해보자. (마우스 없는 환경에서 그리려니까 너무 힘들다…)<br><img src="01.png" alt=""><br>위 그림은 아래와 같은 기호를 통해 표현할 수 있다.<br><code>X = {a, b, c, a, b, c}</code><br>이제 이 집합 X를 서로 같은 원소들로 이뤄진 부분집합으로 나눠보자.<br><img src="02.png" alt=""><br>위 그림은 아래와 같은 기호를 통해 표현할 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X = &#123;a, b, c, a, b, c&#125;</span><br><span class="line">A = &#123;a, a&#125;</span><br><span class="line">B = &#123;b, b&#125;</span><br><span class="line">C = &#123;c, c&#125;</span><br></pre></td></tr></table></figure></p><p>이제 이 부분집합 A, B, C는 서로 같은 원소들끼리 뭉쳐있으므로 동치류(equivalence class; 동치 클래스)라고 부를 수 있다.<br>equals 메서드가 쓸모 있으려면 동치류에 속한 어떤 원소와도 서로 교환할 수 있어야한다고 한다.  </p><p>그냥 뭔소린지 모르겠고 그냥 둘이 같아야한다는 걸 뭘 어렵게 풀어쓴 거 같다.<br><del>수학을 모르니 ㅠㅠ…</del><br>그럼 동치 관계가 가지는 특성에 대해 하나씩 알아보자.</p><h4 id="Reflexive-반사성"><a href="#Reflexive-반사성" class="headerlink" title="Reflexive(반사성)"></a>Reflexive(반사성)</h4><blockquote><p>for any non-null reference value x, x.equals(x) should return true.<br>  <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)" rel="external nofollow noopener noreferrer" target="_blank">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)</a></p></blockquote><p>null이 아니고, 참조값 x에 대해서 x.equals(x)는 true를 반환해야한다.<br>위 규칙을 어기는 코드를 바로 작성해보자.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotReflexive</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">final</span> Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>그리고 아래와 같이 테스트 코드를 작성해서 위 규칙을 어겼는지 검증해보자.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> var x = <span class="keyword">new</span> NotReflexive();</span><br><span class="line">    assertNotEquals(x, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>테스트는 깔끔하게 통과한다.  </p><p>그럼 이제 위 규칙을 어겼을 때 어떤 오동작을 유발하는지 살펴보자.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> var x = <span class="keyword">new</span> NotReflexive();</span><br><span class="line">    <span class="keyword">final</span> var list = List.of(x);</span><br><span class="line">    assertFalse(list.contains(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>reflexive 하지 못한 인스턴스는 List(및 다른 Collection)에 포함돼었는지 제대로 파악할 수 없다.<br>이유는 아래 보다싶이 List 클래스의 contains 메서드는 인스턴스의 equals 메서드를 활용하기 때문이다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(o);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, s = size(); i &lt; s; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o.equals(get(i))) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런 경우에는 딱히 필드도 없고(극단적인 경우지만) 하니 메서드 오버라이딩 자체를 하지 않으면 문제가 해결된다.</p><h4 id="Symmetric-대칭성"><a href="#Symmetric-대칭성" class="headerlink" title="Symmetric(대칭성)"></a>Symmetric(대칭성)</h4><blockquote><p>for any non-null reference values x and y, x.equals(y) should return true if and only if y.equals(x) returns true.<br>  <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)" rel="external nofollow noopener noreferrer" target="_blank">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)</a></p></blockquote><p>null이 아니고, 참조값 x와 y에 대해서 x.equals(y)가 true를 반환하면 y.equals(x)도 true를 반환해야한다.<br>위 규칙을 어기는 코드를 바로 작성해보자.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotSymmetric</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">final</span> Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> NotSymmetric) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> o <span class="keyword">instanceof</span> String;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>그리고 아래와 같이 테스트 코드를 작성해서 위 규칙을 어겼는지 검증해보자.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> var x = <span class="keyword">new</span> NotSymmetric();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// reflexive!!</span></span><br><span class="line">    assertEquals(x, x);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> var y = <span class="string">""</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// not symmetric!!</span></span><br><span class="line">    assertEquals(x, y);</span><br><span class="line">    assertNotEquals(y, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>테스트가 깔끔하게 통과한다.<br>NotSymmetric은 String을 알지만, String은 NotSymmetric을 알지 못하기 때문이다.  </p><p>그럼 이제 위 규칙을 어겼을 때 어떤 오동작을 유발하는지 살펴보자.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> var x = <span class="keyword">new</span> NotSymmetric();</span><br><span class="line">    <span class="keyword">final</span> var y = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> var list = List.of(y);</span><br><span class="line">    assertTrue(list.contains(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>대칭성이 없는 인스턴스 역시 List(및 다른 Collection)에 포함돼었는지 제대로 파악할 수 없다.<br>이유는 위에서 얘기했다싶이 List 클래스의 contains 메서드는 인스턴스의 equals 메서드를 활용하기 때문이다.<br>x(NotSymmetric)의 잘못 구현된 equals 메서드를 사용하기 때문에 포함되지도 않았는데 포함됐다고 판단하고 있다.  </p><p>이런 경우에는 String에 대해 비교하는 구문을 아예 없애버리면 해결이된다.</p><h4 id="Transitive-추이성"><a href="#Transitive-추이성" class="headerlink" title="Transitive(추이성)"></a>Transitive(추이성)</h4><blockquote><p>for any non-null reference values x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true.<br>  <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)" rel="external nofollow noopener noreferrer" target="_blank">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)</a>  </p></blockquote><p>null이 아니고, 참조값 x와 y, z에 대해서 x.equals(y)가 true를 반환하고 y.equals(z)가 true를 반환하면, x.equals(z)도 true를 반환해야한다.<br>마치 3단 논법같은 이 명제를 부셔버리는 예제를 작성해보자.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">final</span> Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o <span class="keyword">instanceof</span> Parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotTransitive</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NotTransitive</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">final</span> Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">super</span>.equals(o)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Parent 인스턴스 경우</span></span><br><span class="line">        <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> NotTransitive)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// NotTransitive 인스턴스인 경우</span></span><br><span class="line">        <span class="keyword">return</span> a == ((NotTransitive) o).a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 테스트 코드로 검증을 해보자.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> var x = <span class="keyword">new</span> NotTransitive(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reflexive!!</span></span><br><span class="line">    assertEquals(x, x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> var y = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// symmetric!!</span></span><br><span class="line">    assertEquals(x, y);</span><br><span class="line">    assertEquals(y, x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> var z = <span class="keyword">new</span> NotTransitive(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// not transitive!!</span></span><br><span class="line">    assertEquals(x, y);</span><br><span class="line">    assertEquals(y, z);</span><br><span class="line">    assertNotEquals(x, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위와 같이 transitive하지 못한 경우에도 아래와 같이 당연히 오작동하기 마련이다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> var x = <span class="keyword">new</span> NotTransitive(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">final</span> var y = <span class="keyword">new</span> Parent();</span><br><span class="line">    <span class="keyword">final</span> var list = List.of(x);</span><br><span class="line">    </span><br><span class="line">    assertTrue(list.contains(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이를 해결하기 위해서는 Parent 클래스에 equals 메서드에서 instanceof 연산자 대신에 getClass() 메서드를 쓰면 해결된다. (정말?)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">final</span> Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (o != <span class="keyword">null</span>) &amp;&amp; (o.getClass() == <span class="keyword">this</span>.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>테스트 코드로 검증을 해보자.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> var x = <span class="keyword">new</span> NotTransitive(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// reflexive!!</span></span><br><span class="line">    assertEquals(x, x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> var y = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// symmetric!!</span></span><br><span class="line">    assertEquals(x, y);</span><br><span class="line">    assertEquals(y, x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> var z = <span class="keyword">new</span> NotTransitive(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// transitive!!</span></span><br><span class="line">    assertNotEquals(x, y);</span><br><span class="line">    assertNotEquals(y, z);</span><br><span class="line">    assertNotEquals(x, z);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> var list = List.of(x);</span><br><span class="line"></span><br><span class="line">    assertFalse(list.contains(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위 테스트에서 문제가 됐던 x.equals(y), y.equals(z), !x.equals(z) 문제는 발생하지 않았고,<br>list.contains() 메서드에서 말썽이 발생했던 문제도 해결됐다.</p><p>하지만 이는 논리적 동치성을 검증하지 못했고, <strong>리스코프 치환 원칙</strong>을 위배했기 때문에 올바르게 해결했다고 하기 거시기하다…</p><blockquote><p>LSP(Liskov substitution principle, 바바라 리스코프란 사람이 만들었다고 함.)<br>  어떤 타입에 있어 중요한 속성이라면 그 하위 타입에서도 마찬가지로 중요하고,<br>  따라서 그 타입의 메서드가 하위 타입에서도 똑같이 잘 동작해야한다.</p></blockquote><p>간단한 예를 통해 알아보자.<br>우선 Parent 클래스를 다음과 같이 바꿔보자.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Parent&gt; z = List.of(<span class="keyword">new</span> Parent());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">final</span> Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (o != <span class="keyword">null</span>) &amp;&amp; (o.getClass() == <span class="keyword">this</span>.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> Parent p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> z.contains(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>그리고 간단한 테스트 클래스를 통해 의도한 대로 동작하는지 보자.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> var x = <span class="keyword">new</span> Parent();</span><br><span class="line">    assertTrue(x.test(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>무슨 일을 하는 코드인지는 모르겠지만 우리가 의도한 대로 잘 동작한다.<br>리스코프 치환 원칙을 준수했다면 Parent의 하위 클래스인 NotTransitive 클래스로 타입을 <strong>치환</strong>해도 정상 동작해야한다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> var x = <span class="keyword">new</span> NotTransitive(<span class="number">1</span>);</span><br><span class="line">    assertTrue(x.test(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>상위 타입(Parent)에서 하위 타입(NotTransitive)로 치환했는데 테스트가 깨진다.<br>이는 하위 타입인 NotTransitive 클래스를 리스코프 치환 원칙에 위배했다는 증거가 된다.<br>리스코프 치환 원칙은 객체 지향의 5대 원칙 중 하나이므로 이는 객체 지향적으로 설계하지 못했다는 증거가 된다.  </p><p>그럼 하위 클래스에 필드를 추가하면서 equals 메서드를 오버라이딩 하는데 동치 관계를 준수하면서 객체 지향적으로 설계까지 하는 방법은 없는 걸까?<br>답은 없다.<br>그럼 어떻게 해야할까?<br>하위 클래스(상속)로 만드는 대신에 Composition을 활용하는 것이다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotTransitive</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 상속을 쓰지 않으니 부모 클래스로 접근할 수 있는 루트를 필드로써 제공하면 된다.</span></span><br><span class="line">    <span class="keyword">private</span> Parent p;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NotTransitive</span><span class="params">(<span class="keyword">final</span> Parent p, <span class="keyword">final</span> <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.p = p;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 부모 클래스의 기능을 쓰고 싶다면 이 메서드를 통해 접근하면 된다.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Parent <span class="title">asParent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 논리적 동치성을 검증.</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">final</span> Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> NotTransitive)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> a == ((NotTransitive) o).a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>하지만 자바 라이브러리를 보면 하위 클래스에 필드를 추가하면서 equals를 재정의한 경우가 있다.<br>바로 <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Date.html" rel="external nofollow noopener noreferrer" target="_blank">java.util.Date</a> 클래스를 상속 받은 <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.sql/java/sql/Timestamp.html" rel="external nofollow noopener noreferrer" target="_blank">java.sql.Timestamp</a>가 그 예이다.<br>따라서 Timestamp API 문서에는 아래와 같은 문구가 적혀있다.  </p><blockquote><p>This type is a composite of a java.util.Date and a separate nanoseconds value.<br>  Only integral seconds are stored in the java.util.Date component.<br>  The fractional seconds - the nanos - are separate.<br>  The Timestamp.equals(Object) method never returns true when passed an object that isn’t an instance of java.sql.Timestamp, because the nanos component of a date is unknown.<br>  As a result, the Timestamp.equals(Object) method is not symmetric with respect to the java.util.Date.equals(Object) method.<br>  Also, the hashCode method uses the underlying java.util.Date implementation and therefore does not include nanos in its computation.</p></blockquote><p>위 클래스는 대칭성을 준수하지 못하고 있다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> epochMilli = Instant.now().toEpochMilli();</span><br><span class="line">    <span class="keyword">final</span> var date = <span class="keyword">new</span> Date(epochMilli);</span><br><span class="line">    <span class="keyword">final</span> var timestamp = <span class="keyword">new</span> Timestamp(epochMilli);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// not symmetric!!</span></span><br><span class="line">    assertEquals(date, timestamp);</span><br><span class="line">    assertNotEquals(timestamp, date);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>물론 하위 클래스에 필드를 추가하면서 equals 메서드를 오버라이딩 하는데 동치 관계를 준수하면서 객체 지향적으로 설계하는 경우도 있긴 하다.<br>바로 부모 클래스가 추상 클래스인 경우이다.<br>추상 클래스는 인스턴스를 만들 수 없으므로 위에 얘기했던 문제가 발생하지 않는다.  </p><h4 id="Consistent-일관성"><a href="#Consistent-일관성" class="headerlink" title="Consistent(일관성)"></a>Consistent(일관성)</h4><blockquote><p>for any non-null reference values x and y, multiple invocations of x.equals(y) consistently return true or consistently return false, provided no information used in equals comparisons on the objects is modified.<br>  <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)" rel="external nofollow noopener noreferrer" target="_blank">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)</a></p></blockquote><p>equals 메서드의 결과가</p><ol><li>가변 클래스의 경우에는 수정되기 전까지 항상 똑같아야한다.</li><li>불변 클래스의 경우에는 항상 똑같아야한다.</li></ol><p>equals 판단에 신뢰할 수 없는 자원이 끼어있는 경우 일관성을 해칠 수 있다.</p><p>그럼 일관성을 준수하지 못하는 경우를 작성해보자. (물론 Reflexive, 대칭성, Transitive도 준수하지 못하지만…)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotConsistent</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">final</span> Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> NotConsistent)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> Instant.now().toEpochMilli() % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>equals 판단에 신뢰할 수 없는 자원으로 <strong>시간</strong>을 넣었다.<br>과연 이 경우에 일관성을 해치는지 검증해보자.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> var x = <span class="keyword">new</span> NotConsistent();</span><br><span class="line">    <span class="keyword">final</span> var y = <span class="keyword">new</span> NotConsistent();</span><br><span class="line">    <span class="comment">// 숫자를 너무 작게하거나 운이 나쁘면 원하는 결과가 안 나올 수도...</span></span><br><span class="line">    <span class="keyword">final</span> var resultSet = IntStream.range(<span class="number">1</span>, <span class="number">1000000</span>).mapToObj(i -&gt; x.equals(y)).collect(toSet());</span><br><span class="line">    assertNotEquals(resultSet.size(), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>하지만 이런 일관성을 깨뜨리면서 equals를 오버라이딩한 경우가 자바 라이브러리에도 존재한다.<br>바로 <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/URL.html" rel="external nofollow noopener noreferrer" target="_blank">java.net.URL</a> 클래스가 그 예이다.<br>java.net.URL의 equals 메서드는 URL과 매핑된 IP 주소를 이용해 비교한다.<br>URL을 통해 매핑된 IP 주소를 알아내려면 네트워크를 이용해야한다.<br>하지만 이 <strong>네트워크</strong>도 <strong>equals 판단에 신뢰할 수 없는 자원</strong> 중 하나이다.<br>하지만 이 경우에는 하위 호환성 때문에 문제를 고치지 못하고 있다고 한다.</p><h3 id="null이-아닌-객체는-null과-같지-않아야한다"><a href="#null이-아닌-객체는-null과-같지-않아야한다" class="headerlink" title="null이 아닌 객체는 null과 같지 않아야한다."></a>null이 아닌 객체는 null과 같지 않아야한다.</h3><blockquote><p>For any non-null reference value x, x.equals(null) should return false.<br>  <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)" rel="external nofollow noopener noreferrer" target="_blank">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)</a></p></blockquote><p>이름만 들어도 뭔소린지 바로 파악이 된다.<br>이 지키기 어려운 경우도 바로 아래와 같이 예제를 구현해보자.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotNull</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">final</span> Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> o <span class="keyword">instanceof</span> NotNull;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>바로 비교하려는 대상이 null일 때 true를 리턴하면 된다.  </p><p>그럼 이 규칙을 잘 어겼는지 검증해보자.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// reflexive!</span></span><br><span class="line">    <span class="keyword">final</span> var x = <span class="keyword">new</span> NotNull();</span><br><span class="line">    assertEquals(x, x);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// symmetric!</span></span><br><span class="line">    <span class="keyword">final</span> var y = <span class="keyword">new</span> NotNull();</span><br><span class="line">    assertEquals(x, y);</span><br><span class="line">    assertEquals(y, x);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// transitive!</span></span><br><span class="line">    <span class="keyword">final</span> var z = <span class="keyword">new</span> NotNull();</span><br><span class="line">    assertEquals(y, z);</span><br><span class="line">    assertEquals(x, z);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// consistent!</span></span><br><span class="line">    assertEquals(x, x);</span><br><span class="line">    assertEquals(x, y);</span><br><span class="line">    assertEquals(y, x);</span><br><span class="line">    assertEquals(y, z);</span><br><span class="line">    assertEquals(x, z);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// x is null!!</span></span><br><span class="line">    assertEquals(x, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>모든 규칙을 지켰는데 <code>null이 아닌 객체는 null과 같지 않아야한다</code>를 지키지 못했으니 위의 경우에는 동치 관계를 준수하면서 equals 메서드를 구현한 게 아니다.<br>간단하게 첫 번째 줄인 <code>if(o == null) return true;</code>만 삭제하면 모든 조건을 만족시키게 되는 것이다.<br>instansof는 null safe한 연산자이기 때문에 굳이 null 체크를 안 해도 NullPointerException을 유발하지 않는다.</p><h3 id="Best-Practice"><a href="#Best-Practice" class="headerlink" title="Best Practice"></a>Best Practice</h3><ol><li><p>가장 처음에는 레퍼런스 비교를 하자.<br>애초에 같은 레퍼런스 값을 가진다면 동일한 객체(논리적으로도)로 봐도 무방하다.<br>따라서 뒤에 있을 로직들을 쓸 데 없이 처리하지 않아도 돼서 성능 측면에서 좋아질 것이다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">final</span> Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> o == <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>instanceof 연산자로 올바른 타입인지 확인한다.<br>올바른 타입인지 확인하지 않으면 뒤에 나오는 핵심 필드의 값을 비교할 수 없다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">final</span> Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// instanceof 연산자는 null safe 하기 때문에 아래 구문은 필요 없다.</span></span><br><span class="line">    <span class="comment">// if(o == null) return false;</span></span><br><span class="line">    <span class="comment">// 혹은 인터페이스를 구현한 것이면 클래스 대신에 인터페이스를 넣어서 비교할 수도 있다.</span></span><br><span class="line">    <span class="keyword">return</span> o <span class="keyword">instanceof</span> Type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>올바른 타입으로 형변환 하고, <strong>핵심</strong> 필드의 값만 비교하자.<br>모든 필드의 값이 일치하지 않아도 되는 경우에는 모든 필드를 비교하면 성능 상에 좋지 않다.<br>혹은 인터페이스의 구현체라면 인터페이스의 메서드를 사용해서 필드에 접근해야할 것이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">final</span> Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 올바른 타입인지 비교하지 않으면 ClassCastException을 면치 못할 것이다.</span></span><br><span class="line">    <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> Type)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> var obj = (Type) o;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 모든 필드를 비교할 필요는 없고 핵심적인 필드만 비교하면 된다.</span></span><br><span class="line">    <span class="keyword">if</span>(!obj.a.equals(<span class="keyword">this</span>.a)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>float과 double을 제외한 primitive type은 == 연산자를 통해 값을 비교하고,<br>float과 double은 Float.NaN, -0.0D 등등의 특수한 경우 때문에 == 연산자로는 비교가 불가능하다.<br>그렇다고 equals 메서드를 통해 비교하면 오토박싱 때문에 성능상 좋지 않을 수도 있으니 compare 메서드를 통해 비교하도록 하자.<br>그 외에 자바가 제공해주는 라이브러리의 경우에는 대부분 동치관계를 준수했을 것이므로 equals 메서드로 비교하자. (이 마저도 주의해서 사용하긴 해야한다.)<br>혹은 특정 타입의 경우에는 <code>null이 아닌 객체는 null과 같지 않아야한다</code>는 원칙을 준수하지 않고 equals 메서드를 오버라이딩 했을 수 있기 때문에 Objects.equals를 쓰는 게 좀 더 안전하긴 하다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">final</span> Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> var obj = (Type) o;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(obj.a != <span class="keyword">this</span>.a) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(Double.compare(obj.b, <span class="keyword">this</span>.b) != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(!(obj.c.equals(<span class="keyword">this</span>.c))) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(!Objects.equals(obj.d, <span class="keyword">this</span>.d)) <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>특정 필드로부터 값이 추론되는 필드는 검증하지 말자.<br>사각형은 너비(width), 높이(height)만으로 넓이(area)가 결정되기 때문에 너비와 높이만 비교했으면 넓이는 비교할 필요가 없다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> width;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> height;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> area;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">(<span class="keyword">final</span> <span class="keyword">double</span> width, <span class="keyword">final</span> <span class="keyword">double</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">        <span class="keyword">this</span>.height = height;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// width(너비)와 height(높이)를 통해 area(너비)가 결정된다.</span></span><br><span class="line">        <span class="keyword">this</span>.area = width * height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">final</span> Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> var obj = (Rectangle) o;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(obj.width != <span class="keyword">this</span>.width) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(obj.height != <span class="keyword">this</span>.height) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// width와 height만 알면 area 값은 자동으로 알 수 있으니 굳이 비교할 필요가 없다.</span></span><br><span class="line">        <span class="comment">// if(obj.area != this.area) return false;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>변경 가능성이 높은 필드부터 비교하자.<br>변경 가능성이 높은 필드부터 비교하면 더 빠르게 해당 타입의 논리적 동치성을 검출할 수 있다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Type</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> b, <span class="keyword">final</span> <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setB</span><span class="params">(<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">final</span> Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> var obj = (Type) o;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 변경이 불가능한 a를 먼저 검사하기 보단 변경이 가능한 b를 검사해야 더 빠르게 논리적 동치성을 검출할 수 있다.</span></span><br><span class="line">        <span class="keyword">if</span>(obj.b != <span class="keyword">this</span>.b) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(obj.a != <span class="keyword">this</span>.a) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@Override 어노테이션을 사용하자.<br>잘못 오버라이딩 한 경우 컴파일 에러를 내주기 때문에 버그를 최대한 빨리 찾을 수 있다.<br>만약 해당 어노테이션이 없다면 메서드 오버라이딩(재정의)가 아니라 메서드 오버로딩 취급해서 새로운 메서드를 추가한 거라고 생각한다.<br>그리고 새로 추가한 메서드를 통해 equals 메서드를 호출하는 게 아니라 부모 클래스에 있는 원본 클래스의 equals 메서드를 호출하게 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// method does not override or implement a method from a supertype</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">final</span> Type o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>위 규칙들을 준수해서 간단하게 equals 메서드를 구현해보자면 아래와 같다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> center;</span><br><span class="line">    <span class="keyword">private</span> Color color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> x, <span class="keyword">final</span> <span class="keyword">int</span> y, <span class="keyword">final</span> <span class="keyword">double</span> center, <span class="keyword">final</span> Color color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        <span class="keyword">this</span>.center = center;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Point)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> var obj = (Point) o;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(obj.x != <span class="keyword">this</span>.x) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(obj.y != <span class="keyword">this</span>.y) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(Double.compare(obj.center, <span class="keyword">this</span>.center) != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(!Objects.equals(obj.color, <span class="keyword">this</span>.color)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;thumb.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Object 클래스는 인스턴스가 생성 가능한 Concrete class이지만 기본적으로 상속해서 사용하도록 설계됐다고 한다.&lt;br&gt;(그 이유는 모르겠지만… 그걸 찾으려면 또 이 장의
      
    
    </summary>
    
      <category term="Note" scheme="https://perfectacle.github.io/categories/Note/"/>
    
      <category term="Java" scheme="https://perfectacle.github.io/categories/Note/Java/"/>
    
    
      <category term="Java" scheme="https://perfectacle.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>(Java8) 날짜와 시간 API</title>
    <link href="https://perfectacle.github.io/2018/09/26/java8-date-time/"/>
    <id>https://perfectacle.github.io/2018/09/26/java8-date-time/</id>
    <published>2018-09-26T04:36:45.000Z</published>
    <updated>2019-03-10T07:22:48.308Z</updated>
    
    <content type="html"><![CDATA[<p><img src="thumb.png" alt=""></p><p>부끄럽게도 Java8에 나온 날짜와 시간 API를 제대로 모르고 계속해서 사용해왔다.<br>늦었지만 지금이라도 정리를 해봤다.  </p><h2 id="들어가기에-앞서"><a href="#들어가기에-앞서" class="headerlink" title="들어가기에 앞서"></a>들어가기에 앞서</h2><p>먼저 날짜와 시간 API는 JSR-310이라고도 불린다.<br>이걸 풀어서 설명하면 <a href="https://www.jcp.org/en/home/index" rel="external nofollow noopener noreferrer" target="_blank">JCP(Java Community Process)</a>에서 관리하는 <a href="https://jcp.org/en/jsr/overview" rel="external nofollow noopener noreferrer" target="_blank">JSR(Java Specification Requests)</a>의 <a href="https://jcp.org/en/jsr/detail?id=310" rel="external nofollow noopener noreferrer" target="_blank">310번 째</a> Request(?)로<br>Date and Time API이다.  </p><p>이 API는 현재 표준으로 자리잡았고, 날짜와 시간 관련 라이브러리인 <a href="http://www.joda.org/joda-time/" rel="external nofollow noopener noreferrer" target="_blank">Joda-Time</a>의 창시자인 Joda도 이 API를 만드는데 동참했다.</p><p>기존 Date, Calander와 달리 Thread Safe하고, 날짜 연산 관련된 편의 기능이 많고, TimeOffset/TimeZone 관련된 기능들도 있어서 글로벌 서비스에서도 적합하다.</p><h2 id="LocalTime-LocalDate-LocalDateTime"><a href="#LocalTime-LocalDate-LocalDateTime" class="headerlink" title="LocalTime/LocalDate/LocalDateTime"></a>LocalTime/LocalDate/LocalDateTime</h2><p>시간대(Zone Offset/Zone Region)에 대한 정보가 전혀 없는 API이다.<br>따라서 한국에서 2018-09-07T08:00:04였으면 미국으로 들고가도 2018-09-07T08:00:04이다.<br>이러한 경우는 생일 같은 경우 제일 적합하다.<br>나는 1993-05-30T01:05:30 <a href="https://www.timeanddate.com/time/zones/kst" rel="external nofollow noopener noreferrer" target="_blank">KST</a>(1993-05-29T06:05:30 <a href="https://www.timeanddate.com/time/zones/hast" rel="external nofollow noopener noreferrer" target="_blank">HST</a>)에 태어났고, KST(Korea Standard Time)를 사용하는 한국에서 매년 5월 30일에 생일 파티를 했다.<br>하지만 HST(Hawaii Standard Time)를 쓰는 하와이로 갔다고 해서 내 생일 파티를 매년 5월 29일에 하지 않는다.<br>여전히 내 생일 파티는 매년 5월 30일에 할 것이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalDateTimeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 1993-05-30T01:05:30는 아래와 같이 나타낼 수 있다.  </span></span><br><span class="line">        <span class="keyword">final</span> var birthDateTime = LocalDateTime.of(<span class="number">1993</span>, <span class="number">5</span>, <span class="number">30</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">30</span>);</span><br><span class="line">        <span class="keyword">final</span> var birthDate = LocalDate.of(<span class="number">1993</span>, <span class="number">5</span>, <span class="number">30</span>);</span><br><span class="line">        <span class="keyword">final</span> var birthTime = LocalTime.of(<span class="number">1</span>, <span class="number">5</span>, <span class="number">30</span>);</span><br><span class="line">        <span class="keyword">final</span> var birthDay = LocalDateTime.of(birthDate, birthTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ZoneOffset"><a href="#ZoneOffset" class="headerlink" title="ZoneOffset"></a>ZoneOffset</h2><p>UTC 기준으로 시간(Time Offset)을 나타낸 것이라고 보면 된다.<br>우리나라는 KST를 사용하는데 KST는 <a href="/2018/09/26/date-and-time/#UTC-Coordinated-Universal-Time">UTC</a>보다 9시간이 빠르므로 UTC +09:00으로 표기한다.<br>ZoneOffset은 ZoneId의 자식 클래스이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.ZoneOffset;</span><br><span class="line"><span class="keyword">import</span> java.time.ZoneId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZoneOffsetTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// UTC +09:00은 아래와 같이 나타낼 수 있다.  </span></span><br><span class="line">        <span class="keyword">final</span> var zoneOffset = ZoneOffset.of(<span class="string">"+9"</span>);</span><br><span class="line">        <span class="keyword">final</span> var zoneOffset2 = ZoneOffset.of(<span class="string">"+09"</span>);</span><br><span class="line">        <span class="keyword">final</span> var zoneOffsetIso8601Format = ZoneOffset.of(<span class="string">"+09:00"</span>);</span><br><span class="line">        <span class="keyword">final</span> var zoneOffset3 = ZoneOffset.of(<span class="string">"+09:00:00"</span>);</span><br><span class="line">        <span class="keyword">final</span> var zoneOffset4 = ZoneId.of(<span class="string">"+9"</span>);</span><br><span class="line">        <span class="keyword">final</span> var zoneOffset5 = ZoneId.of(<span class="string">"+09"</span>);</span><br><span class="line">        <span class="keyword">final</span> var zoneOffsetIso8601Format2 = ZoneId.of(<span class="string">"+09:00"</span>);</span><br><span class="line">        <span class="keyword">final</span> var zoneOffset6 = ZoneId.of(<span class="string">"+09:00:00"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// UTC ±00:00은 아래와 같이 나타낼 수 있다.</span></span><br><span class="line">        <span class="keyword">final</span> var zoneOffset7 = ZoneOffset.of(<span class="string">"+0"</span>);</span><br><span class="line">        <span class="keyword">final</span> var zoneOffset8 = ZoneOffset.of(<span class="string">"-0"</span>);</span><br><span class="line">        <span class="keyword">final</span> var zoneOffset9 = ZoneOffset.of(<span class="string">"+00"</span>);</span><br><span class="line">        <span class="keyword">final</span> var zoneOffset10 = ZoneOffset.of(<span class="string">"-00"</span>);</span><br><span class="line">        <span class="keyword">final</span> var zoneOffsetIso8601Format3 = ZoneOffset.of(<span class="string">"+00:00"</span>);</span><br><span class="line">        <span class="keyword">final</span> var zoneOffsetIso8601Format4 = ZoneOffset.of(<span class="string">"-00:00"</span>);</span><br><span class="line">        <span class="keyword">final</span> var zoneOffsetIso8601Format5 = ZoneOffset.of(<span class="string">"Z"</span>); <span class="comment">// Zulu Time</span></span><br><span class="line">        <span class="keyword">final</span> var zoneOffset11 = ZoneOffset.of(<span class="string">"+00:00:00"</span>);</span><br><span class="line">        <span class="keyword">final</span> var zoneOffset12 = ZoneOffset.of(<span class="string">"-00:00:00"</span>);</span><br><span class="line">        <span class="keyword">final</span> var zoneOffset13 = ZoneId.of(<span class="string">"+0"</span>);</span><br><span class="line">        <span class="keyword">final</span> var zoneOffset14 = ZoneId.of(<span class="string">"-0"</span>);</span><br><span class="line">        <span class="keyword">final</span> var zoneOffset15 = ZoneId.of(<span class="string">"+00"</span>);</span><br><span class="line">        <span class="keyword">final</span> var zoneOffset16 = ZoneId.of(<span class="string">"-00"</span>);</span><br><span class="line">        <span class="keyword">final</span> var zoneOffsetIso8601Format6 = ZoneId.of(<span class="string">"+00:00"</span>);</span><br><span class="line">        <span class="keyword">final</span> var zoneOffsetIso8601Format7 = ZoneId.of(<span class="string">"-00:00"</span>);</span><br><span class="line">        <span class="keyword">final</span> var zoneOffsetIso8601Format8 = ZoneId.of(<span class="string">"Z"</span>); <span class="comment">// Zulu Time</span></span><br><span class="line">        <span class="keyword">final</span> var zoneOffset17 = ZoneId.of(<span class="string">"+00:00:00"</span>);</span><br><span class="line">        <span class="keyword">final</span> var zoneOffset18 = ZoneId.of(<span class="string">"-00:00:00"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ZoneRegion"><a href="#ZoneRegion" class="headerlink" title="ZoneRegion"></a>ZoneRegion</h2><p>Time Zone을 나타낸 것이라고 보면 된다.<br>KST는 타임존의 이름이고 이를 나타내는 ZoneRegion은 Asia/Seoul이다.<br>ZoneRegion은 ZoneId의 자식 클래스이다.<br>하지만 public 클래스가 아니라 외부에서 직접적인 접근은 하지 못해 ZoneId 클래스를 통해서만 생성이 가능하다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.ZoneId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZoneIdTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// KST는 아래와 같이 나타낼 수 있다.  </span></span><br><span class="line">        <span class="keyword">final</span> var zoneId = ZoneId.of(<span class="string">"Asia/Seoul"</span>);</span><br><span class="line">        <span class="keyword">final</span> var zoneId2 = ZoneId.of(<span class="string">"UTC+9"</span>);</span><br><span class="line">        <span class="keyword">final</span> var zoneId3 = ZoneId.of(<span class="string">"UTC+09"</span>);</span><br><span class="line">        <span class="keyword">final</span> var zoneId4 = ZoneId.of(<span class="string">"UTC+09:00"</span>);</span><br><span class="line">        <span class="keyword">final</span> var zoneId5 = ZoneId.of(<span class="string">"UTC+09:00:00"</span>);</span><br><span class="line">        <span class="keyword">final</span> var zoneId6 = ZoneId.of(<span class="string">"GMT+9"</span>);</span><br><span class="line">        <span class="keyword">final</span> var zoneId7 = ZoneId.of(<span class="string">"GMT+09"</span>);</span><br><span class="line">        <span class="keyword">final</span> var zoneId8 = ZoneId.of(<span class="string">"GMT+09:00"</span>);</span><br><span class="line">        <span class="keyword">final</span> var zoneId9 = ZoneId.of(<span class="string">"GMT+09:00:00"</span>);</span><br><span class="line">        <span class="keyword">final</span> var zoneId10 = ZoneId.of(<span class="string">"UT+9"</span>);</span><br><span class="line">        <span class="keyword">final</span> var zoneId11 = ZoneId.of(<span class="string">"UT+09"</span>);</span><br><span class="line">        <span class="keyword">final</span> var zoneId12 = ZoneId.of(<span class="string">"UT+09:00"</span>);</span><br><span class="line">        <span class="keyword">final</span> var zoneId13 = ZoneId.of(<span class="string">"UT+09:00:00"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ZoneRules"><a href="#ZoneRules" class="headerlink" title="ZoneRules"></a>ZoneRules</h2><p>ZoneOffset의 UTC +09:00과 ZoneRegion의 Asia/Seoul을 보면 전혀 차이가 없다.<br>그럼 ZoneOffset과 ZoneRegion은 왜 따로 분리돼있는 걸까?<br>좀 더 지역에 특화된, 지명 등등을 넣어서 그 의미를 살리고자 분리가 되거나 한 걸까?<br>이 차이는 DST(Daylight saving time, 서머타임)와 같은 Time Transition Rule을 포함하느냐, 포함하지 않느냐로 갈린다.<br>ZoneOffset은 Time Transition Rule을 포함하지 않는 ZoneRules를 가진다.<br>ZoneRegion은 Time Transition Rule을 포함할 수도, 포함하지 않을 수도 있다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.ZoneOffset;</span><br><span class="line"><span class="keyword">import</span> java.time.ZoneId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZoneRulesTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// ZoneOffset이기 때문에 Time Transition Rule이 없기 때문에 아무것도 찍히지 않는다.</span></span><br><span class="line">        ZoneOffset.of(<span class="string">"+1"</span>).getRules().getTransitionRules().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ZoneRegion이지만, Time Transition Rule이 없기 때문에 아무것도 찍히지 않는다.</span></span><br><span class="line">        ZoneId.of(<span class="string">"Africa/Brazzaville"</span>).getRules().getTransitionRules().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ZoneRegion이고, Time Transition Rule이 있기 때문에 내용이 찍힌다.</span></span><br><span class="line">        <span class="comment">// TransitionRule[Gap +01:00 to +02:00, SUNDAY on or after MARCH 25 at 02:00 STANDARD, standard offset +01:00]</span></span><br><span class="line">        <span class="comment">// TransitionRule[Overlap +02:00 to +01:00, SUNDAY on or after OCTOBER 25 at 02:00 STANDARD, standard offset +01:00]</span></span><br><span class="line">        ZoneId.of(<span class="string">"CET"</span>).getRules().getTransitionRules().forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그럼 UTC+01:00인 <a href="https://www.timeanddate.com/time/zones/cet" rel="external nofollow noopener noreferrer" target="_blank">CET(Central European Time)</a>와 UTC+02:00인 <a href="https://www.timeanddate.com/time/zones/cest" rel="external nofollow noopener noreferrer" target="_blank">CEST(Central European Summer Time)</a>를 왜 구분하지 않는 것일까?<br>그 이유는 CET와 CEST가 동시에 사용되지 않기 때문이다.<br>CET를 사용하는 모든 나라는 CEST도 사용하고 있고, 겨울에는 CET를, 여름에는 CEST를 사용하기 때문에 절대 동시에 사용하지 않는다.  </p><p>이런 ZoneRules는 ZonedDateTime과 사용했을 때 진가를 발휘한다. </p><h2 id="OffsetDateTime"><a href="#OffsetDateTime" class="headerlink" title="OffsetDateTime"></a>OffsetDateTime</h2><p>LocalDateTime + ZoneOffset에 대한 정보까지 포함한 API이다.<br>이러한 경우는 축구 경기 생중계 등등에 적합하다.  </p><p>레알 마드리드와 바르셀로나의 경기인 엘 클라시코 더비의 경우를 살펴보자.<br><img src="el-clasico-cest.png" alt="바르셀로나 홈 구장인 Camp Nou(바르셀로나에 위치)에서 2018-05-06T20:45:00+02:00에 경기가 시작했다."><br><img src="el-clasico-kst.png" alt="똑같은 경기를 한국 사람이 보려면 2018-05-07T03:45:00+09:00에 경기가 시작했다."></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.OffsetDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.ZoneOffset;</span><br><span class="line"><span class="keyword">import</span> java.time.ZoneId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OffsetTimeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> var barca = OffsetDateTime.of(LocalDateTime.of(<span class="number">2018</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">20</span>, <span class="number">45</span>, <span class="number">0</span>), ZoneOffset.of(<span class="string">"+2"</span>));</span><br><span class="line">        <span class="comment">// 2018-05-06T20:45+02:00</span></span><br><span class="line">        System.out.println(barca);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> var seoul = OffsetDateTime.of(LocalDateTime.of(<span class="number">2018</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">0</span>), ZoneOffset.of(<span class="string">"+9"</span>));</span><br><span class="line">        <span class="comment">// 2018-05-07T03:45+09:00</span></span><br><span class="line">        System.out.println(seoul);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 둘을 UTC로 변환했을 때 같은 시간이기 때문에 둘은 같은 시간이라고 볼 수 있다.</span></span><br><span class="line">        <span class="comment">// 2018-05-06T18:45Z</span></span><br><span class="line">        System.out.println(barca.atZoneSameInstant(ZoneId.of(<span class="string">"Z"</span>)));</span><br><span class="line">        <span class="comment">// 2018-05-06T18:45Z</span></span><br><span class="line">        System.out.println(seoul.atZoneSameInstant(ZoneId.of(<span class="string">"Z"</span>)));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1970-01-01T00:00Z</span></span><br><span class="line">        <span class="keyword">final</span> var unixTimeOfUTC = OffsetDateTime.of(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, ZoneOffset.UTC);</span><br><span class="line">        <span class="comment">// 1970-01-01T00:00+09:00</span></span><br><span class="line">        <span class="keyword">final</span> var unixTimeOfUTC9 = OffsetDateTime.of(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, ZoneOffset.of(<span class="string">"+9"</span>));</span><br><span class="line">        <span class="comment">// false, 둘은 다른 ZoneOffset을 가진다.</span></span><br><span class="line">        System.out.println(unixTimeOfUTC.equals(unixTimeOfUTC9));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1970-01-01T00:00</span></span><br><span class="line">        <span class="keyword">final</span> var unixTimeOfUTCLocalDateTime = unixTimeOfUTC.toLocalDateTime();</span><br><span class="line">        <span class="comment">// 1970-01-01T00:00</span></span><br><span class="line">        <span class="keyword">final</span> var unixTimeOfUTCL9ocalDateTime = unixTimeOfUTC9.toLocalDateTime();</span><br><span class="line">        <span class="comment">// true, LocalDateTime은 ZoneOffset이 없기 때문에 둘 다 똑같은 걸로 취급한다.</span></span><br><span class="line">        System.out.println(unixTimeOfUTCLocalDateTime.equals(unixTimeOfUTCL9ocalDateTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ZonedDateTime"><a href="#ZonedDateTime" class="headerlink" title="ZonedDateTime"></a>ZonedDateTime</h2><p>OffsetDateTime + ZoneRegion에 대한 정보까지 포함한 API이다.<br>UTC +09:00의 Time Offset을 가지는 Time Zone도 여러가지이다.  </p><ul><li>Asia/Seoul  </li><li>Asia/Tokyo</li><li>등등</li></ul><p>하지만 시간을 나타내는데 있어서 Asia/Seoul을 쓰던 Asia/Tokyo를 쓰던 큰 차이점이 없다.<br>OffsetDateTime과의 차이점은 DST(Daylight Saving Time)와 같은 Time Transition Rule을 포함하는 ZoneRegion을 갖고 있는 ZoneRules의 유무이다.<br>독일 등등에서 사용하는 CET(겨울), CEST(여름)는 서머타임을 사용하지 않는 나라에 사는 나 같은 경우에는 굉장히 생소하다.<br>그래서 어떤 때는 CET를 사용해야하고, 어떤 때는 CEST를 사용해야할지 매우 애매하고 계산하기도 까다롭다.<br>자바에서는 이 두 Time Zone을 하나의 Time Zone(CET)로 통일하고 Time Transition Rule을 가지는 ZoneRules를 통해 알아서 내부적으로 계산해준다.    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.ZonedDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.OffsetDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.ZoneId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZonedDateTimeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 2018-03-25T01:59:59+01:00[CET]</span></span><br><span class="line">        System.out.println(ZonedDateTime.of(LocalDateTime.of(<span class="number">2018</span>, <span class="number">3</span>, <span class="number">25</span>, <span class="number">1</span>, <span class="number">59</span>, <span class="number">59</span>), ZoneId.of(<span class="string">"CET"</span>)));</span><br><span class="line">        <span class="comment">// 2018-03-25T03:00+02:00[CET]</span></span><br><span class="line">        System.out.println(ZonedDateTime.of(LocalDateTime.of(<span class="number">2018</span>, <span class="number">3</span>, <span class="number">25</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>), ZoneId.of(<span class="string">"CET"</span>)));</span><br><span class="line">        <span class="comment">// 2018-10-28T02:59:59+02:00[CET]</span></span><br><span class="line">        System.out.println(ZonedDateTime.of(LocalDateTime.of(<span class="number">2018</span>, <span class="number">10</span>, <span class="number">28</span>, <span class="number">2</span>, <span class="number">59</span>, <span class="number">59</span>), ZoneId.of(<span class="string">"CET"</span>)));</span><br><span class="line">        <span class="comment">// 2018-10-28T03:00+01:00[CET]</span></span><br><span class="line">        System.out.println(ZonedDateTime.of(LocalDateTime.of(<span class="number">2018</span>, <span class="number">10</span>, <span class="number">28</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>), ZoneId.of(<span class="string">"CET"</span>)));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// DST 등등의 Time Transition Rule을 사용하지 않는 ZoneRegion이나 ZoneOffset 같은 경우에는 겨울이나 여름이나 UTC 기준 시간이 동일하다.</span></span><br><span class="line">        <span class="comment">// 2018-06-01T00:00+09:00[Asia/Seoul]</span></span><br><span class="line">        System.out.println(ZonedDateTime.of(LocalDateTime.of(<span class="number">2018</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), ZoneId.of(<span class="string">"Asia/Seoul"</span>)));</span><br><span class="line">        <span class="comment">// 2018-12-01T00:00+09:00[Asia/Seoul]</span></span><br><span class="line">        System.out.println(ZonedDateTime.of(LocalDateTime.of(<span class="number">2018</span>, <span class="number">12</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), ZoneId.of(<span class="string">"Asia/Seoul"</span>)));</span><br><span class="line">        <span class="comment">// 2018-06-01T00:00+09:00</span></span><br><span class="line">        System.out.println(ZonedDateTime.of(LocalDateTime.of(<span class="number">2018</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), ZoneId.of(<span class="string">"+9"</span>)));</span><br><span class="line">        <span class="comment">// 2018-12-01T00:00+09:00</span></span><br><span class="line">        System.out.println(ZonedDateTime.of(LocalDateTime.of(<span class="number">2018</span>, <span class="number">12</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), ZoneId.of(<span class="string">"+9"</span>)));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> var zonedDateTimeOfSeoul = ZonedDateTime.of(<span class="number">2018</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, ZoneId.of(<span class="string">"Asia/Seoul"</span>));</span><br><span class="line">        <span class="keyword">final</span> var zonedDateTimeOfTokyo = ZonedDateTime.of(<span class="number">2018</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, ZoneId.of(<span class="string">"Asia/Tokyo"</span>));</span><br><span class="line">        <span class="comment">// false, 둘은 다른 Region에서 사용하는 TimeZone을 사용하고 있기 때문이다.</span></span><br><span class="line">        System.out.println(zonedDateTimeOfSeoul.equals(zonedDateTimeOfTokyo));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> var offsetDateTimeOfSeoul = zonedDateTimeOfSeoul.toOffsetDateTime();</span><br><span class="line">        <span class="keyword">final</span> var offsetDateTimeOfTokyo = zonedDateTimeOfTokyo.toOffsetDateTime();</span><br><span class="line">        <span class="comment">// true, 둘은 같은 Offset에 다른 Region이지만, OffsetDateTime은 ZoneRegion에 대한 정보는 없고 ZoneOffset에 대한 정보만 있기 때문에 동일한 것으로 취급한다.</span></span><br><span class="line">        <span class="comment">// 같은 Region에서 사용하는 형식인지 아닌지는 알 수 없다.</span></span><br><span class="line">        System.out.println(offsetDateTimeOfSeoul.equals(offsetDateTimeOfTokyo));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> var zonedDateTimeOfWinter = ZonedDateTime.of(<span class="number">2018</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, ZoneId.of(<span class="string">"CET"</span>));</span><br><span class="line">        <span class="keyword">final</span> var zonedDateTimeOfSummer = ZonedDateTime.of(<span class="number">2018</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, ZoneId.of(<span class="string">"CET"</span>));</span><br><span class="line">        <span class="comment">// true, 둘 다 CET라는 ZoneRegion이다.</span></span><br><span class="line">        System.out.println(zonedDateTimeOfWinter.getZone().equals(zonedDateTimeOfSummer.getZone()));</span><br><span class="line">        <span class="comment">// false, Offset은 겨울에는 +01:00, 여름에는 +02:00이다.</span></span><br><span class="line">        System.out.println(zonedDateTimeOfWinter.getOffset().equals(zonedDateTimeOfSummer.getOffset()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> var offsetDateTimeOfWinter = zonedDateTimeOfWinter.toOffsetDateTime();</span><br><span class="line">        <span class="keyword">final</span> var offsetDateTimeOfSummer = zonedDateTimeOfSummer.toOffsetDateTime();</span><br><span class="line">        <span class="comment">// false, ZoneRegion이 없어서 ZoneOffset을 갖고 구분해야하는데 둘은 같은 Region에서 사용하는 것인데도 불구하고 다른 Offset을 가진다고 판단해서 </span></span><br><span class="line">        <span class="comment">// OffsetDateTime만으로는 두 날짜가 같은 Region에서 사용하는 건지 아닌지를 알 수 없다.</span></span><br><span class="line">        System.out.println(offsetDateTimeOfWinter.getOffset().equals(offsetDateTimeOfSummer.getOffset()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Instant"><a href="#Instant" class="headerlink" title="Instant"></a>Instant</h2><p>어느 순간을 나타내는 클래스이다.<br><a href="/2018/09/26/date-and-time/">Unix Timestamp</a>를 구할 때 사용한다.<br>0 ~ 999,999,999의 integer 범위(Integer는 10억 단위를 전부 제대로 표시하지 못하기 때문에)의 Unix Timestamp Nanosecond와<br>long의 자료형을 가지는 Unix Timestamp Second(2038년 문제를 해결하기 위해 long을 택한 듯)를 가진다.  </p><p>Unix Timestamp를 사용하는 이유는 기본적으로 integer, long 등등의 숫자 자료형을 가지고 연산을 하기 때문에<br>Local/Offset/ZonedDateTime과 비교했을 때 연산 속도가 훨씬 빠를 것이다.<br>그리고 다양한 NumberUtils의 기능들도 사용할 수 있고, UTC 기준이기 때문에 글로벌한 서비스에서도 매우 적합할 것이다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.ZonedDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.OffsetDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.ZoneId;</span><br><span class="line"><span class="keyword">import</span> java.time.ZoneOffset;</span><br><span class="line"><span class="keyword">import</span> java.time.Instant;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstantTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 2018-09-26T11:41:56.281466</span></span><br><span class="line">        <span class="keyword">final</span> var localDateTimeNow = LocalDateTime.now();</span><br><span class="line">        <span class="comment">// Unix Timestamp는 UTC 기준인데 LocalDateTime은 이런 정보가 하나도 없기 때문에 어떤 Time Zone인지 알려줘야 Unix Timestamp를 구할 수 있다.</span></span><br><span class="line">        <span class="comment">// Unix Timestamp는 UTC(+00:00)이기 때문에 UTC+09:00인 KST(Asia/Seoul)에서는 9시간을 뺀 시간이 나온다.</span></span><br><span class="line">        <span class="comment">// 2018-09-26T02:41:56.281466Z</span></span><br><span class="line">        <span class="keyword">final</span> var instantFromAsiaSeoulLocalDateTime = localDateTimeNow.atZone(ZoneId.of(<span class="string">"Asia/Seoul"</span>)).toInstant();</span><br><span class="line">        <span class="comment">// 2018-09-26T02:41:56.281466Z</span></span><br><span class="line">        <span class="keyword">final</span> var instantFromAsiaSeoulLocalDateTime2 = Instant.from(localDateTimeNow.atZone(ZoneId.of(<span class="string">"Asia/Seoul"</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Unix Timestamp는 UTC(+00:00)이기 때문에 UTC(+00:00)인 GMT에서는 동일한 시간이 나온다.</span></span><br><span class="line">        <span class="comment">// 2018-09-26T11:41:56.281466Z</span></span><br><span class="line">        <span class="keyword">final</span> var instantFromGMTLocalDateTime = localDateTimeNow.atZone(ZoneId.of(<span class="string">"GMT"</span>)).toInstant();</span><br><span class="line">        <span class="comment">// 2018-09-26T11:41:56.281466Z</span></span><br><span class="line">        <span class="keyword">final</span> var instantFromGMTLocalDateTime2 = Instant.from(localDateTimeNow.atZone(ZoneId.of(<span class="string">"GMT"</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ZonedDateTime은 Time Zone을 가지지만 Unix Timestamp는 UTC 기준이기 때문에 어떤 Time Zone으로 세팅해도 알아서 UTC로 변환한다.</span></span><br><span class="line">        <span class="comment">// 시스템의 기본 시간이 KST(UTC+09:00)이기 때문에 9시간을 뺀 시간이 나온다.</span></span><br><span class="line">        <span class="comment">// 2018-09-26T02:41:56.281834Z</span></span><br><span class="line">        <span class="keyword">final</span> var instantFromZonedDateTime = ZonedDateTime.now().toInstant();</span><br><span class="line">        <span class="comment">// 2018-09-26T02:41:56.281933Z</span></span><br><span class="line">        <span class="keyword">final</span> var instantFromAsiaSeoulZonedDateTime = ZonedDateTime.now(ZoneId.of(<span class="string">"Asia/Seoul"</span>)).toInstant();</span><br><span class="line">        <span class="comment">// 2018-09-26T02:41:56.281884Z</span></span><br><span class="line">        <span class="keyword">final</span> var instantFromGMTZonedDateTime = ZonedDateTime.now(ZoneId.of(<span class="string">"GMT"</span>)).toInstant();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// OffsetDateTime은 Time Offset을 가지지만 Unix Timestamp는 UTC 기준이기 때문에 어떤 Time Offset으로 세팅해도 알아서 UTC로 변환한다.</span></span><br><span class="line">        <span class="comment">// 시스템의 기본 시간이 KST(UTC+09:00)이기 때문에 9시간을 뺀 시간이 나온다.</span></span><br><span class="line">        <span class="comment">// 2018-09-26T02:41:56.281834Z</span></span><br><span class="line">        <span class="keyword">final</span> var instantFromOffsetDateTime = OffsetDateTime.now().toInstant();</span><br><span class="line">        <span class="comment">// 2018-09-26T02:41:56.281834Z</span></span><br><span class="line">        <span class="keyword">final</span> var instantFromUTC9OffsetDateTime = OffsetDateTime.now(ZoneOffset.of(<span class="string">"+9"</span>)).toInstant();</span><br><span class="line">        <span class="comment">// 2018-09-26T02:41:56.281834Z</span></span><br><span class="line">        <span class="keyword">final</span> var instantFromUTCOffsetDateTime = OffsetDateTime.now(ZoneOffset.UTC).toInstant();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 가장 쉽게 시스템의 Unix Timestamp를 구하는 방법이다.</span></span><br><span class="line">        <span class="comment">// 2018-09-26T02:41:56.281834Z</span></span><br><span class="line">        <span class="keyword">final</span> var instantNow = Instant.now();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// true, LocalDateTime UTC를 빼고 모두 동일하다(시스템 Time Offset이 UTC+09:00인 가정 하에)</span></span><br><span class="line">        <span class="keyword">final</span> var allAreSame = <span class="keyword">new</span> HashSet&lt;&gt;((List.of(instantFromAsiaSeoulLocalDateTime.getEpochSecond(),</span><br><span class="line">                                                      instantFromAsiaSeoulLocalDateTime2.getEpochSecond(),</span><br><span class="line">                                                      instantFromZonedDateTime.getEpochSecond(),</span><br><span class="line">                                                      instantFromGMTZonedDateTime.getEpochSecond(),</span><br><span class="line">                                                      instantFromAsiaSeoulZonedDateTime.getEpochSecond(),</span><br><span class="line">                                                      instantFromOffsetDateTime.getEpochSecond(),</span><br><span class="line">                                                      instantFromUTCOffsetDateTime.getEpochSecond(),</span><br><span class="line">                                                      instantFromUTC9OffsetDateTime.getEpochSecond(),</span><br><span class="line">                                                      instantNow.getEpochSecond()))).size() == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;thumb.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;부끄럽게도 Java8에 나온 날짜와 시간 API를 제대로 모르고 계속해서 사용해왔다.&lt;br&gt;늦었지만 지금이라도 정리를 해봤다.  &lt;/p&gt;
&lt;h2 id=&quot;들어가기에-앞서&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="Programming" scheme="https://perfectacle.github.io/categories/Programming/"/>
    
      <category term="Java" scheme="https://perfectacle.github.io/categories/Programming/Java/"/>
    
    
      <category term="Time" scheme="https://perfectacle.github.io/tags/Time/"/>
    
      <category term="Date" scheme="https://perfectacle.github.io/tags/Date/"/>
    
      <category term="Java8" scheme="https://perfectacle.github.io/tags/Java8/"/>
    
  </entry>
  
  <entry>
    <title>날짜와 시간</title>
    <link href="https://perfectacle.github.io/2018/09/26/date-and-time/"/>
    <id>https://perfectacle.github.io/2018/09/26/date-and-time/</id>
    <published>2018-09-25T15:27:20.000Z</published>
    <updated>2019-03-10T07:22:48.165Z</updated>
    
    <content type="html"><![CDATA[<p><img src="thumb.jpg" alt="출처: https://www.sitepoint.com/suggesting-carbon-with-composer-date-and-time-the-right-way/"></p><h2 id="GMT-Greenwich-Mean-Time-vs-UTC-Coordinated-Universal-Time"><a href="#GMT-Greenwich-Mean-Time-vs-UTC-Coordinated-Universal-Time" class="headerlink" title="GMT(Greenwich Mean Time) vs. UTC(Coordinated Universal Time)"></a>GMT(Greenwich Mean Time) vs. UTC(Coordinated Universal Time)</h2><p>세계 표준 시간 관련해서 위 두 키워드가 자주 나오길래 <a href="https://www.google.co.kr/search?newwindow=1&amp;hl=en-KR&amp;rlz=1C5CHFA_enKR721KR721&amp;ei=zc2pW-WIHYq88QXQmKzABQ&amp;q=gmt+vs+utc&amp;oq=gmt+vs+utc&amp;gs_l=psy-ab.3..0i67k1j0i20i263k1j0l3.1063480.1067397.0.1067832.22.18.2.0.0.0.289.2326.0j9j4.14.0....0...1.1j4.64.psy-ab..6.16.2500.6..0i131k1j0i10k1j35i39k1j0i203k1.171.hKhy4qSkjm4" rel="external nofollow noopener noreferrer" target="_blank">구글</a>에서 검색해보았다.  </p><blockquote><p>There is no time difference between Greenwich Mean Time and Coordinated Universal Time.<br>6:13 AM Tuesday, Greenwich Mean Time (GMT) is 6:13 AM Tuesday, Coordinated Universal Time (UTC)  </p></blockquote><p>둘의 차이점이 없다고 한다.<br>그래서 다른 사이트를 뒤져보았다.</p><blockquote><p>GMT is a time zone and UTC is a time standard.<br>Although GMT and UTC share the same current time in practice.<br><a href="https://www.timeanddate.com/time/gmt-utc-time.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.timeanddate.com/time/gmt-utc-time.html</a></p></blockquote><p>Time Zone과 Time Standard인 게 차이라는데…<br>둘의 차이는 무엇일까… 찾아보았다.  </p><h3 id="Time-Zone"><a href="#Time-Zone" class="headerlink" title="Time Zone"></a>Time Zone</h3><p>세계에는 다양한 Time Zone이 존재한다.<br>우선 우리나라에서 사용하는 KST(Korea Standard Timezone), 하와이에서 사용하는 HST(Hawaii Standard Time), UK 등등에서 사용하는 <a href="#GMT-Greenwich-Mean-Time">GMT</a> 등등이 있다.</p><h4 id="GMT-Greenwich-Mean-Time"><a href="#GMT-Greenwich-Mean-Time" class="headerlink" title="GMT(Greenwich Mean Time)"></a>GMT(Greenwich Mean Time)</h4><blockquote><p>GMT is a time zone officially used in some European and African countries.<br>The time can be displayed using both the 24-hour format (0 - 24) or the 12-hour format (1 - 12 am/pm).<br><a href="https://www.timeanddate.com/time/gmt-utc-time.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.timeanddate.com/time/gmt-utc-time.html</a>  </p></blockquote><p>뭐, 유럽과 아프리카 쪽에서 주로 사용되는 <strong>타임존</strong>이란다.<br>의문점은 왜 0 ~ 23이 아니라 0 ~ 24라고 표기했을까…<br>0 ~ 23이라고 표기하는 국가도 있고, 1 ~ 24라고 표기하는 국가도 있어서 그런 걸까…?<br>뭐, 짜치는 문제이므로 건너 뛰자.</p><p><a href="https://en.wikipedia.org/wiki/Greenwich" rel="external nofollow noopener noreferrer" target="_blank">Greenwich</a>는 영국에 위치한 도시이고, 경도(longitude)가 0도인 곳이다.<br>다른 경도가 0인 도시도 많을텐데 아마 이런 표준을 제정할 때 영국이 강대국이었을 것이고, 지리 및 정치 기타 등등의 요소로 인해 Greenwich가 선정된 게 아닐까 싶다.  </p><blockquote><p>GMT is based on the Earth’s motion, mainly its daily rotation.<br>  The day is the “mean (average) solar day” of 86,400 (mean solar) seconds.<br>  That’s simply 24 hours of 60 minutes, each with 60 seconds.<br>  <a href="https://www.quora.com/What-is-difference-between-GMT-and-UTC" rel="external nofollow noopener noreferrer" target="_blank">https://www.quora.com/What-is-difference-between-GMT-and-UTC</a></p></blockquote><p>GMT는(아마 다른 타임존들도 동일할 것이다.) 지구의 자전(daily rotation)을 기반으로 한다.<br>따라서 하루(The day)는 지구의 자전을 의미하고, 지구의 자전 주기를 86,400으로 나눈 단위를 <strong>초(Second)</strong>라고 부른다.<br>즉, 천재지변의 사유로 지구의 자전 주기가 조금 느려졌다 하더라도 하루는 86,400<strong>초</strong>로 동일하다.<br><strong>초</strong>의 단위가 절대적이지 않음을 의미한다. </p><h3 id="Time-Standard"><a href="#Time-Standard" class="headerlink" title="Time Standard"></a>Time Standard</h3><p>세계 어디서나 사용할 수 있는 시간의 표준을 의미한다.<br>그 대표는 어디를 기준으로 해야할까?<br>시간은 경도(longitude)에 따라 달라지지, 위도(longitude)에 따라 달라지지 않는다.<br>따라서 경도가 0°인 곳을 기준으로 하다보니 GMT가 Time Standard로 선정됐<strong>었</strong>다.<br>과거형이니 현재는 GMT가 Time Standard가 아님을 의미한다.<br>현재는 UTC가 Time Standard라는 뜻이다.<br>왜 GMT는 Time Standard에서 탈락하게 된 것일까…?  </p><h4 id="UT-Universal-Time"><a href="#UT-Universal-Time" class="headerlink" title="UT(Universal Time)"></a>UT(Universal Time)</h4><blockquote><p>Universal Time (UT) was created at the International Meridian Conference in 1884.<br>  This is the basis for the 24-hour time zone system we know today.<br>  At the time, Greenwich Mean Time (GMT) was chosen as the world’s time standard.<br>  <a href="https://www.timeanddate.com/time/aboututc.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.timeanddate.com/time/aboututc.html</a> </p></blockquote><p>1884년에 UT(24시간 시스템의 기본)가 만들어졌다.<br>이 때 선정된 표준 시간(Time Standard)이 <a href="#GMT-Greenwich-Mean-Time">GMT</a>이다.  </p><h4 id="GMT에서-UTC로…"><a href="#GMT에서-UTC로…" class="headerlink" title="GMT에서 UTC로…"></a>GMT에서 UTC로…</h4><blockquote><p>In 1960, the International Radio Consultative Committee formalized the concept of UTC, and it was put into practice the year after.<br>The name Coordinated Universal Time was officially adopted in 1967.<br>UTC was adjusted several times until 1972.<br><a href="https://www.timeanddate.com/time/aboututc.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.timeanddate.com/time/aboututc.html</a></p></blockquote><p>UTC는 1972년까지 여러 번 제정되었다.</p><blockquote><p>Until 1972, Greenwich Mean Time (also known as Zulu time) was the same as Universal Time (UT).<br>Since then, GMT is no longer a time standard.<br>Today, Greenwich Mean Time (GMT) is only the name of a time zone.<br><a href="https://www.timeanddate.com/time/aboututc.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.timeanddate.com/time/aboututc.html</a></p></blockquote><p>동시에 1972년부터 GMT는 Time Standard의 자리를 박탈당하고 일개 Time Zone에 불과하게 되었다.</p><h3 id="UTC-Coordinated-Universal-Time"><a href="#UTC-Coordinated-Universal-Time" class="headerlink" title="UTC(Coordinated Universal Time)"></a>UTC(Coordinated Universal Time)</h3><blockquote><p>UTC is not a time zone, but a time standard that is the basis for civil time and time zones worldwide.<br>This means that no country or territory officially uses UTC as a local time.<br><a href="https://www.timeanddate.com/time/gmt-utc-time.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.timeanddate.com/time/gmt-utc-time.html</a>    </p></blockquote><p>GMT와는 달리 세계에서 공통적으로 쓰이는 <strong>시간 표준(time standard)</strong>이란다.<br>KST, GMT와 같이 현지 시간을 반영한 Time Zone과 달리 UTC는 현지 시간(local time)이 반영되지 않은, 즉 Time Zone에 얽매이지 않는 게 특징이다.<br>그래서 세계 표준 시간을 언급할 때 UTC가 많이 언급되는 것 같다.</p><blockquote><p>UTC is almost the same as GMT, but it’s based on the scientific definition of a second (the SI second), which does not depend on the time it takes the Earth to rotate.<br>  The day length, based on UTC, is also 86,400 seconds, but they are SI seconds.<br>  The “mean solar day” is about 86,400.002 “SI seconds”.<br>  That difference is very slowly increasing as the rotation period of Earth very slowly increases.<br>  <a href="https://www.quora.com/What-is-difference-between-GMT-and-UTC" rel="external nofollow noopener noreferrer" target="_blank">https://www.quora.com/What-is-difference-between-GMT-and-UTC</a></p></blockquote><p>UTC는 지구의 자전(the Earth to rotate)에 기반하지 않고, <a href="https://en.wikipedia.org/wiki/International_System_of_Units" rel="external nofollow noopener noreferrer" target="_blank">SI 기준</a>의 초(이하 SI Second)에 기반하고 있다.<br>즉 UTC에서는 하루(The day length)는 SI Second로 86,400초이다.<br>절대적인 기준으로 하루를 세기 때문에 GMT(지구의 자전을 기반으로 하는)와는 미세한 차이가 존재한다.<br>이를 보정하기 위해 UTC에서는 <a href="https://ko.wikipedia.org/wiki/%EC%9C%A4%EC%B4%88" rel="external nofollow noopener noreferrer" target="_blank">윤초(Leap Second)</a>라는 개념을 도입했다.</p><p>UTC를 위에 Coordinated Universal Time라고 적어놨는데 왜 UTC라고 줄여서 부르는 걸까…?<br>원래 UTC는 표준 명칭이 CUT(Coordinated Universal Time in English), TUC(Temps Universel Coordonné in French)로 두 개였다.<br>혼란을 줄이기 위해 표준을 정해야하는데 한 쪽의 손을 들어주면 정치적 싸움판이 될테므로 아마 둘 다 택하지 않고 쌩뚱맞은 UTC로 간 게 아닐까… 싶다.<br>하지만 왜 Universal Coordinated Time이 아닌 Coordinated Universal Time이라고 부르는지는 잘 모르겠다…<br>영어가 불어보다는 글로벌하기 때문에 풀네임은 영어권의 손을 들어준 것일까…?</p><h3 id="Zulu-Time"><a href="#Zulu-Time" class="headerlink" title="Zulu Time"></a>Zulu Time</h3><blockquote><p>Zulu (short for “Zulu time”) is used in the military and in navigation generally as a term for Universal Coordinated Time (UCT), sometimes called Universal Time Coordinated ( UTC ) or Coordinated Universal Time (but abbreviated UTC), and formerly called Greenwich Mean Time.<br>  <a href="https://whatis.techtarget.com/definition/Zulu-Zulu-time" rel="external nofollow noopener noreferrer" target="_blank">https://whatis.techtarget.com/definition/Zulu-Zulu-time</a></p></blockquote><p>짧게는 Zulu라고 부르고, 군사적이나 배, 비행기 항법 등등에서 주로 사용한다.  </p><blockquote><p>Zulu Time Zone (Z) has no offset from Coordinated Universal Time (UTC).<br>  Zulu Time Zone is often used in aviation and the military as another name for UTC +0.<br>  <a href="https://www.timeanddate.com/time/zones/z" rel="external nofollow noopener noreferrer" target="_blank">https://www.timeanddate.com/time/zones/z</a></p></blockquote><p>UTC +0(GMT가 아니다)의 또다른 이름으로 이해하면 될 것 같다.</p><h2 id="그래서-우리나라는…"><a href="#그래서-우리나라는…" class="headerlink" title="그래서 우리나라는…?"></a>그래서 우리나라는…?</h2><p>우리나라는 <strong>KST(Korea Standard Time)</strong>를 사용하고 있다.<br>KST는 UTC에 9시간을 더한 시간으로 <strong>UTC +9</strong> 와 같이 표기하고 있다.<br>그리고 UTC +9을 사용하는 나라가 더 있는데 대표적으로 일본이 있다.<br>하지만 KST는 우리나라에서나 사용하지, 일본에서는 <strong>JST(Japan Standard Time)</strong>를 사용하고 있다.<br>따라서 <a href="https://www.zeitverschiebung.net/en/difference/country/kr/city/1850147" rel="external nofollow noopener noreferrer" target="_blank">일본과 우리나라는 세계 시간이 동일</a>하다.    </p><p>또한 영토가 좌우로 쭉 뻗은 미국 같은 경우에는 여러 타임존(HST(Hawaii Standard Time), PDT(Pacific Daylight Time) 등등)을 사용하고 있다.</p><p>이러한 사유로 AWS RDS의 기본 타임존은 UTC이고, 우리는 현재 시간을 저장(now())했다고 판단했는데 DB에 저장된 시간을 보면 9시간 이전의 시간이 저장된 사례를 볼 수 있다.<br>이게 바로 우리나라가 UTC +9인 KST를 사용하고 있기 때문이다.  </p><h2 id="ISO-8601-Date-and-time-format"><a href="#ISO-8601-Date-and-time-format" class="headerlink" title="ISO-8601 - Date and time format"></a><a href="https://en.wikipedia.org/wiki/ISO_8601" rel="external nofollow noopener noreferrer" target="_blank">ISO-8601 - Date and time format</a></h2><p><a href="https://en.wikipedia.org/wiki/International_Organization_for_Standardization" rel="external nofollow noopener noreferrer" target="_blank">ISO(International Organization for Standardization)</a>는 세계에서 인정하는 표준을 정의하는 기관이다.<br>이 기관에서 시간과 날짜에 관한 표준을 지정하였는데 이게 이 기관에서 정한 8601번 째 표준이라는 의미이다.<br>자바를 비롯해서 많은 프로그래밍 언어에서 날짜와 시간을 표기할 때 위 표준을 준수하고 있다.  </p><p><img src="date-format-by-country.svg" alt="나라별 날짜 형식, 청록색이 일-월-연, 황색이 연-월-일, 자주색이 월-일-연, 적색이 일-월-연과 월-일-연 혼용"><br>사진에서 보다싶이 동아시아권(한국, 일본, 중국 등등)에서는 연-월-일의 순서로 표기한다.<br>하지만 다른 많은 나라에서는 일-월-연, 월-일-연 등등 아주 다양하게 쓰고 있다.<br>우리나라에서는 1970년 01월 02일을 표기할 때 1970-01-02이지만, 미국에서는 02-01-1970이 된다.<br>이런 혼란을 줄이고자 ISO 8601이 나오게 된 것이다.  </p><p>기본적인 규칙은 다음과 같다.  </p><ul><li>큰 단위부터 작은 단위로(연 월 일 시 분 초) 표기한다.  </li><li>0 ~ 9의 숫자는 00 ~ 09와 같이 표기한다.  </li><li>날짜는 <strong>-</strong>을 구분자(delimiter)로 사용하고, 시간은 <strong>:</strong>을 구분자(delimiter)로 사용한다.  </li><li>Time Zone(KST, GMC 등등) 대신에 UTC를 기준으로 시간대를 ±기호를 사용해서 표기한다.</li></ul><p>포스팅 날짜 및 시간인 2018년 9월 26일 00시 10분 13초 KST를 ISO 8601 표기법으로 나타내면 다음과 같다.<br>2018-09-26T00:10:13+09:00<br>2018-09-25T15:10:13+00:00<br>2018-09-25T15:10:13Z<br>여기서 T는 날짜와 시간의 구분자(delimiter)이고, Z는 <a href="#Zulu-Time">Zulu Time</a>을 의미한다.  </p><p>꼭 날짜와 시간을 함께 표시할 필요는 없고 날짜만 표기해도 ISO 8601 표준을 준수했다고 볼 수 있다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;thumb.jpg&quot; alt=&quot;출처: https://www.sitepoint.com/suggesting-carbon-with-composer-date-and-time-the-right-way/&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;GMT-Gr
      
    
    </summary>
    
      <category term="기타" scheme="https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"/>
    
      <category term="등등" scheme="https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EB%93%B1%EB%93%B1/"/>
    
    
      <category term="Time" scheme="https://perfectacle.github.io/tags/Time/"/>
    
      <category term="Date" scheme="https://perfectacle.github.io/tags/Date/"/>
    
      <category term="UTC" scheme="https://perfectacle.github.io/tags/UTC/"/>
    
      <category term="GMT" scheme="https://perfectacle.github.io/tags/GMT/"/>
    
      <category term="Zulu" scheme="https://perfectacle.github.io/tags/Zulu/"/>
    
  </entry>
  
  <entry>
    <title>Unix Timestamp</title>
    <link href="https://perfectacle.github.io/2018/09/25/unix-timestamp/"/>
    <id>https://perfectacle.github.io/2018/09/25/unix-timestamp/</id>
    <published>2018-09-25T14:05:08.000Z</published>
    <updated>2019-03-10T07:22:48.648Z</updated>
    
    <content type="html"><![CDATA[<p><img src="thumb.jpg" alt="https://en.wikipedia.org/wiki/Unix_time"></p><p>들어가기 앞서 Unix Timestamp의 동의어를 살펴보자.  </p><ul><li>Epoch Posix Time</li><li>Epoch Posix Timestamp</li><li>Epoch Unix Time</li><li>Epoch Unix Timestamp</li><li>Posix Epoch</li><li>Posix Epoch Time</li><li>Posix Epoch Timestamp</li><li>Posix Time</li><li>Posix Timestamp  </li><li>Unix Epoch  </li><li>Unix Epoch Time  </li><li>Unix Epoch Timestamp  </li><li>Unix Time  </li><li>Unix Timestamp</li></ul><p>그냥 Epoch, Unix, Posix, Time, Timestamp 등의 조합으로 이뤄진 것 같다…</p><h2 id="Epoch가-뭐지"><a href="#Epoch가-뭐지" class="headerlink" title="Epoch가 뭐지?"></a>Epoch가 뭐지?</h2><blockquote><p>An epoch means an instant in time chosen as the origin of a particular era.<br>  The “epoch” then serves as a reference point from which time is measured.<br>  Time measurement units are counted from the epoch so that the date and time of events can be specified unambiguously.<br>  <a href="https://www.symantec.com/connect/articles/what-epoch-time-and-how-convert-human-understandable-format" rel="external nofollow noopener noreferrer" target="_blank">https://www.symantec.com/connect/articles/what-epoch-time-and-how-convert-human-understandable-format</a></p></blockquote><p>시간을 측정하는 기준점을 Epoch라고 부르는 것 같다.  </p><blockquote><p>In a machine, time is represented by a counter: At the center of a system is a quartz-crystal heart that pulses every second, and each second is added to the count.<br>  For a computer to have any comprehension of now, it must determine how many seconds have elapsed since then – and the earliest then is called the “epoch,” or the theoretical time the clock began ticking.<br>  <a href="https://www.wired.com/2001/09/unix-tick-tocks-to-a-billion/" rel="external nofollow noopener noreferrer" target="_blank">https://www.wired.com/2001/09/unix-tick-tocks-to-a-billion/</a></p></blockquote><p>PC에서 시간은 카운터로 표시되고, 매 초마다 카운트가 증가한다.<br>컴퓨터는 현재 시간(now)을 알려면 “epoch”라고 불리는 것으로부터 얼마나 흘렀는지 알아야한다.</p><h2 id="그래서-그게-뭔데"><a href="#그래서-그게-뭔데" class="headerlink" title="그래서 그게 뭔데?"></a>그래서 그게 뭔데?</h2><p><a href="https://en.wikipedia.org/wiki/ISO_8601" rel="external nofollow noopener noreferrer" target="_blank">ISO 8601</a> 표기법 1970-01-01T00:00:00Z 기준으로 현재까지 몇 초가 지났는지를 나타내는 것이다.<br><a href="https://ko.wikipedia.org/wiki/%EC%9C%A4%EC%B4%88" rel="external nofollow noopener noreferrer" target="_blank">윤초(Leap Second)</a>는 포함하지 않는다.<br>1970-01-01T00:00:00Z는 Unix Timestamp가 0이고, 1970-01-01T00:00:01Z은 Unix Timestamp가 1이고, 1969-12-31T23:59:59Z는 Unix Timestamp가 -1이다.  </p><h2 id="왜-1970년-01월-01일-00시-00분-00초를-기준으로-했을까"><a href="#왜-1970년-01월-01일-00시-00분-00초를-기준으로-했을까" class="headerlink" title="왜 1970년 01월 01일 00시 00분 00초를 기준으로 했을까?"></a>왜 1970년 01월 01일 00시 00분 00초를 기준으로 했을까?</h2><p>Unix의 <a href="https://namu.wiki/w/10%EC%96%B5%20%EC%B4%88%20%EB%AC%B8%EC%A0%9C" rel="external nofollow noopener noreferrer" target="_blank">10억 초 문제</a>를 기념해 2001년 9월 8일에 쓰여진 <a href="https://www.wired.com/2001/09/unix-tick-tocks-to-a-billion/" rel="external nofollow noopener noreferrer" target="_blank">UNIX TICK TOCKS TO A BILLION</a>의 기사를 찾아보니 그 설명이 나온다.  </p><blockquote><p>The Unix epoch is midnight on January 1, 1970. It’s important to remember that this isn’t Unix’s “birthday” – rough versions of the operating system were around in the 1960s.<br>  Instead, the date was programmed into the system sometime in the early 70s only because it was convenient to do so, according to Dennis Ritchie, one the engineers who worked on Unix at Bell Labs at its inception.</p></blockquote><p>Unix Epoch(Unix OS에서 사용되는 Epoch)는 Unix OS의 탄생일이 아니다. (이미 1960년대에 Unix의 대략적인 버전은 이미 존재했다는 것 같다.)<br>그냥 1970년이 프로그래밍 하기 편리해보여서 지정한 걸로 보인다.</p><blockquote><p>“At the time we didn’t have tapes and we had a couple of file-systems running and we kept changing the origin of time,” he said.<br>  “So finally we said, ‘Let’s pick one thing that’s not going to overflow for a while.’ 1970 seemed to be as good as any.”</p></blockquote><p>그냥 1970년이 진짜 날짜/시간을 계산하기에 <strong>당분간</strong> 편리해보여서 선택했다고 한다.<br>왜 <strong>당분간</strong>일까?</p><h2 id="2038년-문제"><a href="#2038년-문제" class="headerlink" title="2038년 문제"></a><a href="https://namu.wiki/w/2038%EB%85%84%20%EB%AC%B8%EC%A0%9C" rel="external nofollow noopener noreferrer" target="_blank">2038년 문제</a></h2><p>위에 언급한 <a href="https://namu.wiki/w/10%EC%96%B5%20%EC%B4%88%20%EB%AC%B8%EC%A0%9C" rel="external nofollow noopener noreferrer" target="_blank">10억 초 문제</a>를 비롯해 <a href="https://namu.wiki/w/497%EC%9D%BC%20%EB%AC%B8%EC%A0%9C" rel="external nofollow noopener noreferrer" target="_blank">497일 문제</a> 등등이 있지만 여기서는 2038년 문제만 다뤄보겠다.  </p><p>이는 32bit Integer의 Overflow 현상을 이해하면 된다.<br>Unix Timestamp가 만들어질 당시 대부분 32bit OS 밖에 존재하지 않았다.<br>32bit Integer의 범위는 −2,147,483,648 (−2³²) ~ 2,147,483,647 (2³¹ − 1)이다.<br>Unsigned Integer를 사용할 경우 부호를 없애서 0 ~ 4,294,967,295 (2³² − 1)까지 가능하지만 1970-01-01T00:00:00Z 이전을 나타낼 수 없으므로 어쩔 수 없이 Signed Integer를 사용했다.<br>따라서 1970-01-01T00:00:00Z에서 2,147,483,647초를 더하면 2038-01-19T03:14:07Z인데(Unix Timestamp 2,147,483,647),<br>여기서 1초가 추가된 2038-01-19T03:14:08Z이 되는 순간 Unix Timestamp 0이 되어 시스템은 1970-01-01T00:00:00Z와 동일한 시간으로 인식한다.<br>즉, 타임머신을 돌렸다고 보면 된다. </p><p>그냥 와, 타임머신 탔다~ 신기하다~로 끝나는 게 아니다.<br>대부분의 서버는 Unix 기반(Linux도 Unix 기반이고 Mac OS도 Unix 기반이므로 시스템의 시간을 나타낼 때 Unix Timestamp를 사용한다.)이기 때문에<br>현재 시간이 1970년대로 표시되고, 시간을 처리하는 로직들(금융권, 각종 행정 처리, 특정 기간 동안의 이벤트 등등)이 망가질 것이다.  </p><p>해결책으로는 아주~ 간단하게 생각했을 때 64bit OS를 사용하면 해결될 일이다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;thumb.jpg&quot; alt=&quot;https://en.wikipedia.org/wiki/Unix_time&quot;&gt;&lt;/p&gt;
&lt;p&gt;들어가기 앞서 Unix Timestamp의 동의어를 살펴보자.  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Epoch Posix 
      
    
    </summary>
    
      <category term="기타" scheme="https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"/>
    
      <category term="등등" scheme="https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EB%93%B1%EB%93%B1/"/>
    
    
      <category term="Time" scheme="https://perfectacle.github.io/tags/Time/"/>
    
      <category term="Unix" scheme="https://perfectacle.github.io/tags/Unix/"/>
    
  </entry>
  
  <entry>
    <title>(AWS) Security Group에서 다른 Security Group을 참조하는 경우</title>
    <link href="https://perfectacle.github.io/2018/08/30/aws-security-group-reference-another-security-group/"/>
    <id>https://perfectacle.github.io/2018/08/30/aws-security-group-reference-another-security-group/</id>
    <published>2018-08-29T18:41:08.000Z</published>
    <updated>2019-03-10T07:22:48.039Z</updated>
    
    <content type="html"><![CDATA[<p><img src="thumb.png" alt=""></p><h2 id="상황"><a href="#상황" class="headerlink" title="상황"></a>상황</h2><p>결제 서비스는 아래와 같은 접근 경로를 허용해야한다.  </p><ol><li>사내</li><li>결제 서비스 개발자의 작업 공간</li><li>A라는 웹 서비스  </li></ol><p>따라서 아래와 같은 Security Group을 가져야한다.</p><table><thead><tr><th>Type</th><th>Protocol</th><th>Port Range</th><th>Source</th><th>Description</th></tr></thead><tbody><tr><td>HTTPS</td><td>TCP</td><td>443</td><td>12.34.44.12/32</td><td>Developer Home</td></tr><tr><td>HTTPS</td><td>TCP</td><td>443</td><td>13.44.12.55/32</td><td>Developer Cafe</td></tr><tr><td>HTTPS</td><td>TCP</td><td>443</td><td>22.33.44.11/32</td><td>Office</td></tr><tr><td>HTTPS</td><td>TCP</td><td>443</td><td>77.33.44.22/32</td><td>A Web Service</td></tr></tbody></table><p>또한 인증 서비스는 아래와 같은 접근 경로를 허용해야한다.  </p><ol><li>사내</li><li>개발자의 작업 공간</li><li>B라는 웹 서비스</li></ol><p>따라서 아래와 같은 Security Group을 가져야한다.</p><table><thead><tr><th>Type</th><th>Protocol</th><th>Port Range</th><th>Source</th><th>Description</th></tr></thead><tbody><tr><td>HTTPS</td><td>TCP</td><td>443</td><td>12.34.44.12/32</td><td>Developer Home</td></tr><tr><td>HTTPS</td><td>TCP</td><td>443</td><td>13.44.12.55/32</td><td>Developer Cafe</td></tr><tr><td>HTTPS</td><td>TCP</td><td>443</td><td>22.33.44.11/32</td><td>Office</td></tr><tr><td>HTTPS</td><td>TCP</td><td>443</td><td>41.22.44.22/32</td><td>B Web Service</td></tr></tbody></table><p>결제 서비스의 Security Group과 인증 서비스의 Security Group은 <code>어떤 웹 서비스에서 접근해야하느냐</code>만 다르고, 나머진 동일하다.<br>위와 같은 문제는 개발자나 사내의 IP(즉 <code>공통된 부분</code>)이 변경됐을 때 각 시큐리티 그룹을 <code>일일이 찾아서 수정</code>해줘야한다는 문제점이 존재한다.</p><p>따라서 먼저 공통 부분을 Security Group으로 뺏다. (id는 sg-workaround라고 가정)<br>이렇게 하면 공통된 부분이 변경됐을 때 일일이 찾아다녀도 되지 않는다는 장점이 존재한다.  </p><table><thead><tr><th>Type</th><th>Protocol</th><th>Port Range</th><th>Source</th><th>Description</th></tr></thead><tbody><tr><td>HTTPS</td><td>TCP</td><td>443</td><td>12.34.44.12/32</td><td>Developer Home</td></tr><tr><td>HTTPS</td><td>TCP</td><td>443</td><td>13.44.12.55/32</td><td>Developer Cafe</td></tr><tr><td>HTTPS</td><td>TCP</td><td>443</td><td>22.33.44.11/32</td><td>Office</td></tr></tbody></table><p>그리고 다시 결제 서비스 Security Group을 만들었다.  </p><table><thead><tr><th>Type</th><th>Protocol</th><th>Port Range</th><th>Source</th><th>Description</th></tr></thead><tbody><tr><td>HTTPS</td><td>TCP</td><td>443</td><td>sg-workaround</td><td>Developer + Office</td></tr><tr><td>HTTPS</td><td>TCP</td><td>443</td><td>77.33.44.22/32</td><td>A Web Service</td></tr></tbody></table><p>그리고 다시 인증 서비스 Security Group을 만들었다.</p><table><thead><tr><th>Type</th><th>Protocol</th><th>Port Range</th><th>Source</th><th>Description</th></tr></thead><tbody><tr><td>HTTPS</td><td>TCP</td><td>443</td><td>sg-workaround</td><td>Developer + Office</td></tr><tr><td>HTTPS</td><td>TCP</td><td>443</td><td>41.22.44.22/32</td><td>B Web Service</td></tr></tbody></table><p>Security Group을 리팩토링(?)해서 공통된 부분을 추출해서 장애의 가능성을 좀 더 줄였다.<br>하지만 위와 같이 작동을 할까?<br>답은 <strong>아니다</strong>.  </p><h2 id="문제-해결"><a href="#문제-해결" class="headerlink" title="문제 해결"></a>문제 해결</h2><p>Security Group의 Source 부분에 다른 Security Group을 추가하는 것은 <code>중첩이나 상속 등등을 의미하지 않는다</code>.<br><a href="#Security-Group에서-다른-Security-Group을-참조하는-경우">Security Group에서 다른 Security Group을 참조하는 경우</a>가 어떨 때 쓰는 건지는 좀 이따 설명하겠다.<br>우리는 우선 위 문제부터 해결해보자.  </p><p>우선 공통된 부분을 따로 빼야한다는 사실은 변하지 않는다. (id는 sg-workaround라고 가정)<br>이렇게 하면 공통된 부분이 변경됐을 때 일일이 찾아다녀도 되지 않는다는 장점이 존재한다.  </p><table><thead><tr><th>Type</th><th>Protocol</th><th>Port Range</th><th>Source</th><th>Description</th></tr></thead><tbody><tr><td>HTTPS</td><td>TCP</td><td>443</td><td>12.34.44.12/32</td><td>Developer Home</td></tr><tr><td>HTTPS</td><td>TCP</td><td>443</td><td>13.44.12.55/32</td><td>Developer Cafe</td></tr><tr><td>HTTPS</td><td>TCP</td><td>443</td><td>22.33.44.11/32</td><td>Office</td></tr></tbody></table><p>그리고 결제 서비스에서만 차이점을 가지는 서버들을 시큐리티 그룹에 추가해주자. (id는 sg-payment라고 가정)</p><table><thead><tr><th>Type</th><th>Protocol</th><th>Port Range</th><th>Source</th><th>Description</th></tr></thead><tbody><tr><td>HTTPS</td><td>TCP</td><td>443</td><td>77.33.44.22/32</td><td>A Web Service</td></tr></tbody></table><p>그리고 인증 서비스에서만 차이점을 가지는 서버들을 시큐리티 그룹에 추가해주자. (id는 sg-auth라고 가정)</p><table><thead><tr><th>Type</th><th>Protocol</th><th>Port Range</th><th>Source</th><th>Description</th></tr></thead><tbody><tr><td>HTTPS</td><td>TCP</td><td>443</td><td>41.22.44.22/32</td><td>B Web Service</td></tr></tbody></table><p>그리고 결제 서비스의 Security Group에는 sg-workaround, sg-payment 두 개를 적용하고,<br>인증 서비스의 Security Group에는 sg-workaround, sg-auth 두 개를 적용해주면 된다.  </p><p>이거보다 더 나은 방법이 있으면 댓글 남겨주시면 감사하겠습니다 :)</p><h2 id="Security-Group에서-다른-Security-Group을-참조하는-경우"><a href="#Security-Group에서-다른-Security-Group을-참조하는-경우" class="headerlink" title="Security Group에서 다른 Security Group을 참조하는 경우"></a>Security Group에서 다른 Security Group을 참조하는 경우</h2><p>시큐리티 그룹을 source에 왜 할당할 수 있는 걸까??<br>Elastic Load Balancer(AWS에서 제공하는 Load Balancer라고 보면 됨, 이하 ELB) - EC2(AWS에서 제공하는 웹 서버라고 보면 됨) 구조를 이해하면 편하다.<br>여기서 가정할 것은 ELB는 public subnet에 있어서 외부에서 바로 접근이 가능해야하고,<br>EC2 인스턴스는 private subnet에 있어서 외부에서 접근이 불가능 하고, 오직 ELB를 통해서만 접근이 가능하다는 점이다.  </p><p>우선 ELB의 Security Group부터 구성해보자. (id는 sg-elb라고 가정.)  </p><table><thead><tr><th>Type</th><th>Protocol</th><th>Port Range</th><th>Source</th><th>Description</th></tr></thead><tbody><tr><td>HTTPS</td><td>TCP</td><td>443</td><td>0.0.0.0/0</td><td>public access</td></tr></tbody></table><p>EC2 인스턴스로는 다이렉트로 요청이 오는 게 아니라 무조건 ELB를 통해서 온다.<br>ELB와 EC2 사이의 통신은 private network를 통해 이뤄지므로 외부로 패킷이 새어나갈 일이 거의 없다고 보면 된다.<br>따라서 EC2 인스턴스와 ELB 사이의 통신은 HTTPS일 필요가 없으므로 EC2에는 TLS(SSL) 인증서를 붙일 필요도 없고, ELB의 http 포트(80번)만 열어주면 되고,<br>ELB의 IP를 EC2 인스턴스의 시큐리티 그룹으로 추가해주면 된다.  </p><p><img src="elb.png" alt="하지만 ELB 어디를 보더라도 IP 주소는 나와있지 않고 DNS만 나와있는 걸 볼 수 있다.">  </p><p><img src="elb-ip.png" alt="nslookup을 때려보면 ELB의 IP 주소가 두 개인 걸 알 수 있다."><br>AWS에서는 ELB가 죽으면 서비스가 죽는 걸(SPOF, Single Point of Failure) 방지하고자 ELB까지 이중화했다.<br>AWS의 이런 세심한 배려 덕분에 우리는 EC2의 Security Group을 다음과 같이 구성하면 된다.<br><a href="https://blog.wisen.co.kr/?p=1926" rel="external nofollow noopener noreferrer" target="_blank">Network Load Balancer</a>의 경우에는 Elastic IP(AWS에서 제공하는 고정 IP, 이하 EIP)를 설정하고 그것만 등록하면 된다.  </p><table><thead><tr><th>Type</th><th>Protocol</th><th>Port Range</th><th>Source</th><th>Description</th></tr></thead><tbody><tr><td>HTTP</td><td>TCP</td><td>80</td><td>13.124.xxx.124/32</td><td>ELB 1</td></tr><tr><td>HTTP</td><td>TCP</td><td>80</td><td>13.209.xxx.125/32</td><td>ELB 2</td></tr></tbody></table><p>하지만 위와 같이 설정해도 다음과 같은 문제가 존재한다.<br>시간이 지나면 ELB의 ip는 변한다.<br>또한 우리는 <code>Public</code> DNS를 가지고 nslookup 명령어를 때려서 ip 주소를 가져왔다.<br><code>Public</code> DNS를 가지고 온 ip는 <code>Public</code> ip이다. (13.124.xxx.124, 13.209.xxx.125)<br>ELB와 EC2 사이의 통신은 private network를 통해 이뤄지므로 ELB의 <code>private ip</code>가 Security Group에 추가돼야한다.<br>하지만 우리는 ELB의 private ip를 알 방법이 없다.  </p><p>방법이 없는 것은 아니다.<br>private ip는 서브넷의 cidr block 안에서 생성된다.<br>따라서 elb가 존재하는 public subnet의 cidr block을 설정하면 된다. (여기서는 cidr block을 가정하겠다.)  </p><table><thead><tr><th>Type</th><th>Protocol</th><th>Port Range</th><th>Source</th><th>Description</th></tr></thead><tbody><tr><td>HTTP</td><td>TCP</td><td>80</td><td>10.0.1.0/24</td><td>Public Subnet</td></tr></tbody></table><p>위와 같이 설정하면 ELB를 통해서 접속은 <code>된다</code>.<br>하지만 한 가지 문제점이 존재한다.<br>해당 서브넷의 모든 리소스가 EC2 인스턴스에 접근이 가능하다는 문제점이 존재한다.  </p><p>private ip는 고정할 수 없고, ELB의 private ip는 알 방법이 없는데 어떻게 해당 ELB만 EC2에 접근할 수 있게 설정할 수 있을까?<br>해답은 바로 EC2의 Security Group에 ELB의 Security Group을 추가하는 것이다.  </p><table><thead><tr><th>Type</th><th>Protocol</th><th>Port Range</th><th>Source</th><th>Description</th></tr></thead><tbody><tr><td>HTTP</td><td>TCP</td><td>80</td><td>sg-elb</td><td>ELB</td></tr></tbody></table><p>위와 같이 설정하면 <code>sg-elb를 사용하는 리소스를 통과한 호스트들</code>만 EC2로 다시 통과할 수 있게 되는 구조다.  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;thumb.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;상황&quot;&gt;&lt;a href=&quot;#상황&quot; class=&quot;headerlink&quot; title=&quot;상황&quot;&gt;&lt;/a&gt;상황&lt;/h2&gt;&lt;p&gt;결제 서비스는 아래와 같은 접근 경로를 허용해야한다.  &lt;/p
      
    
    </summary>
    
      <category term="Middle-end" scheme="https://perfectacle.github.io/categories/Middle-end/"/>
    
      <category term="DevOps" scheme="https://perfectacle.github.io/categories/Middle-end/DevOps/"/>
    
    
      <category term="AWS" scheme="https://perfectacle.github.io/tags/AWS/"/>
    
      <category term="Security Group" scheme="https://perfectacle.github.io/tags/Security-Group/"/>
    
  </entry>
  
  <entry>
    <title>YAML</title>
    <link href="https://perfectacle.github.io/2018/08/19/yaml/"/>
    <id>https://perfectacle.github.io/2018/08/19/yaml/</id>
    <published>2018-08-19T04:56:20.000Z</published>
    <updated>2019-03-10T07:22:48.702Z</updated>
    
    <content type="html"><![CDATA[<p><img src="thumbs.png" alt="YAML Ain&#39;t Markup Language">    </p><h2 id="YAML"><a href="#YAML" class="headerlink" title="YAML"></a><a href="http://yaml.org/" rel="external nofollow noopener noreferrer" target="_blank">YAML</a></h2><blockquote><p>YAML Ain’t Markup Language<br>YAML is a human friendly data serialization standard for all programming languages.</p></blockquote><p>YAML은 마크업 언어가 아니고, <code>사람에게 친숙한 데이터 Serializaition 표준</code>이다.<br>아마 X<strong>ML</strong>, HT<strong>ML</strong>과 같이 YA<strong>ML</strong>도 <strong>ML</strong>이 들어가서 사람들의 오해를 샀던 모양이다.<br>마크업 언어는 태그를 이용하여 문서나 데이터의 구조를 표현하는 언어이다. (HTML, XML)<br>Serialization(직렬화)은 데이터를 시스템 외부(파일로 쓰거나 네트워크로 전송하거나)에서 사용할 때 사용한다. (Byte Array, <a href="https://www.json.org/" rel="external nofollow noopener noreferrer" target="_blank">JSON</a>, YAML)  </p><p><img src="snake-yaml.png" alt="Spring Boot 2의 기본 디펜던시에 포함된 SnakeYAML"><br><a href="https://spring.io/" rel="external nofollow noopener noreferrer" target="_blank">Spring</a>에서는 YAML Parser인 <a href="https://bitbucket.org/asomov/snakeyaml" rel="external nofollow noopener noreferrer" target="_blank">SnakeYAML</a>이 내장돼있다.<br>따라서 YAML 파일을 POJO로 매핑할 수도 있고, Configuration 파일에서도 사용할 수 있다.<br>주의사항은 Spring에 내장된 <a href="https://mvnrepository.com/artifact/org.yaml/snakeyaml" rel="external nofollow noopener noreferrer" target="_blank">SankeYAML은 YAML 1.1 스펙을 구현한 점</a>이다.  </p><p><img src="js-yaml.png" alt="Hexo의 기본 디펜던시에 포함된 js-yaml"><br><a href="https://nodejs.org/" rel="external nofollow noopener noreferrer" target="_blank">Node.js</a> 기반의 블로그 프레임워크인 <a href="https://hexo.io/" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a>에서도<br><a href="https://github.com/nodeca/js-yaml" rel="external nofollow noopener noreferrer" target="_blank">JS-YAML</a>이라는 YAML Parser를 이용해 Configuration을 설정하고 있다.<br>JS-YAML은 Python의 YAML Parser인 <a href="https://pyyaml.org/" rel="external nofollow noopener noreferrer" target="_blank">PyYAML</a>을 포팅하면서 처음에는 YAML 1.1 스펙을 지원했는데, 현재는 YAML 1.2 스펙까지 구현했다.  </p><h3 id="YAML-vs-JSON"><a href="#YAML-vs-JSON" class="headerlink" title="YAML vs. JSON"></a>YAML vs. JSON</h3><blockquote><p>JSON’s foremost design goal is simplicity and universality.<br>Thus, JSON is trivial to generate and parse, at the cost of reduced human readability.<br>In contrast, YAML’s foremost design goals are human readability and support for serializing arbitrary native data structures.<br>Thus, YAML allows for extremely readable files, but is more complex to generate and parse.  </p></blockquote><p>JSON의 최우선 설계 목표는 간편성과 보편성이다. 따라서 JSON은 가독성을 조금 떨어트리는 대신에 생성 및 파싱이 용이하다.<br>반면에 YAML의 최우선 설계 목표는 가독성과 데이터 구조 Serialization이다. 따라서 YAML은 사람이 읽기 쉬운 반면에 생성 및 파싱이 JSON 보다 복잡하다.</p><blockquote><p>YAML can therefore be viewed as a natural superset of JSON.<br>This is also the case in practice; every JSON file is also a valid YAML file.<br>This makes it easy to migrate from JSON to YAML if/when the additional features are required.  </p></blockquote><p>YAML을 JSON의 Superset으로 볼 수도 있다.<br>모든 JSON 파일은 유효한 YAML 파일이다.<br>따라서 JSON에서 YAML로 마이그레이션 하기가 용이하다.  </p><h4 id="가독성"><a href="#가독성" class="headerlink" title="가독성"></a>가독성</h4><p>YAML 홈페이지 조차도 아래와 같이 유효한 YAML 문법으로 이루어져있다.<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">%YAML</span> <span class="number">1.2</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">Projects:</span></span><br><span class="line">  <span class="string">C/C++</span> <span class="attr">Libraries:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">libyaml</span>            <span class="comment"># "C" Fast YAML 1.1</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">libcyaml</span>           <span class="comment"># YAML de/serialization of C data structures (using libyaml)</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">Syck</span>               <span class="comment"># (dated) "C" YAML 1.0</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">yaml-cpp</span>           <span class="comment"># C++ YAML 1.2 implementation</span></span><br></pre></td></tr></table></figure></p><p>과연 JSON 형태로 YAML 홈페이지를 가독성 좋게 표현할 수 있었을까…?<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"Projects"</span>: &#123;</span><br><span class="line">    <span class="attr">"C/C++ Libraries"</span>: [<span class="string">"libyaml"</span>, <span class="string">"libcyaml"</span>, <span class="string">"Syck"</span>, <span class="string">"yaml-cpp"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="퍼포먼스"><a href="#퍼포먼스" class="headerlink" title="퍼포먼스"></a>퍼포먼스</h4><blockquote><p>JSON It also uses a lowest common denominator information model, ensuring any JSON data can be easily processed by every modern programming environment.<br>YAML ventures beyond the lowest common denominator data types, requiring more complex processing when crossing between different programming environments.  </p></blockquote><p>JSON 보다 <a href="http://yaml.org/spec/1.2/spec.html#id2763452" rel="external nofollow noopener noreferrer" target="_blank">YAML의 모델</a>이 좀 더 복잡하기 때문에 파싱하고 생성하는데 YAML이 더 느리다.<br>속도도 느린데 직접 파싱을 한다고 생각해도 JSON이 훨씬 간단하다.</p><h4 id="용도"><a href="#용도" class="headerlink" title="용도"></a>용도</h4><ul><li>대부분의 웹 기술(<a href="https://developer.mozilla.org/en-US/docs/Web/Guide/AJAX" rel="external nofollow noopener noreferrer" target="_blank">AJAX</a> 등등)에서 데이터 통신을 위해서 성능을 위한 것인지는 잘 모르겠지만 대부분 JSON을 많이 사용하고,<br><a href="#Anchor-amp-Alias">reference</a>가 있는 YAML은 복잡한 object 구조를 표현하는데 적합해서, 오프라인에서 data serialization을 위해 더 적합하다.     </li><li>파이썬 커뮤니티에서는 <code>{ } [ ] : ,</code>과 같은 <a href="#Flow-Style-Indicator">Indicator</a> 보다는 파이썬 문법과 비슷한 <a href="#Indentation">indent</a>로 indicate level을 구분하는 YAML을 더 선호하고,<br>자바스크립트 진영에서는 별도의 파서가 필요없고, Javascript Object와 구조가 유사한 JSON을 선호하는 편이다.  </li></ul><h4 id="그-외"><a href="#그-외" class="headerlink" title="그 외."></a>그 외.</h4><ul><li>JSON은 주석이 없다.  </li><li>YAML은 <a href="#Multiple-Documents">한 파일에 여러 Document</a>를 표현할 수 있다.</li><li><blockquote><p>JSON’s RFC4627 requires that mappings keys merely “SHOULD” be unique, while YAML insists they “MUST” be.<br>Technically, YAML therefore complies with the JSON spec, choosing to treat duplicates as an error.<br>In practice, since JSON is silent on the semantics of such duplicates, the only portable JSON files are those with unique keys, which are therefore valid YAML files.</p></blockquote></li></ul><p>JSON은 Key의 중복을 Warning으로 표시하지만, YAML은 허용하지 않는다.  </p><h3 id="YAML-vs-XML"><a href="#YAML-vs-XML" class="headerlink" title="YAML vs. XML"></a>YAML vs. XML</h3><blockquote><p>two languages may actually compete in several application domains, there is no direct correlation between them.<br>  YAML is primarily a data serialization language.<br>  XML was designed to be backwards compatible with the Standard Generalized Markup Language (SGML), which was designed to support structured documentation.</p></blockquote><p>XML과 YAML은 전혀 연관이 없다.<br>XML은 구조화된 문서를 위해 설계된 언어이고, YAML은 data serialization을 위해 설계된 언어이다.   </p><h3 id="Version-1-2-Specification"><a href="#Version-1-2-Specification" class="headerlink" title="Version 1.2 Specification"></a><a href="http://yaml.org/spec/1.2/spec.html" rel="external nofollow noopener noreferrer" target="_blank">Version 1.2 Specification</a></h3><p>1.1에서 1.2로 바뀐 주요 사항은 JSON의 Superset처럼 동작하기 위해서 많은 사항들이 바뀌었다.  </p><blockquote><p>All other characters, including the form feed (#x0C), are considered to be non-break characters.<br>  Note that these include the non-ASCII line breaks: next line (#x85), line separator (#x2028) and paragraph separator (#x2029).<br>  YAML version 1.1 did support the above non-ASCII line break characters; however, JSON does not.<br>  Hence, to ensure JSON compatibility, YAML treats them as non-break characters as of version 1.2. In theory this would cause incompatibility with version 1.1;<br>  in practice these characters were rarely (if ever) used.<br>  YAML 1.2 processors parsing a version 1.1 document should therefore treat these line breaks as non-break characters, with an appropriate warning.</p></blockquote><p>따라서 JSON Syntax를 YAML 1.2에서는 거의 완벽하게 지원한다.  </p><h4 id="목적"><a href="#목적" class="headerlink" title="목적"></a>목적</h4><blockquote><p>YAML is easily readable by humans.  </p></blockquote><p>YAML은 사람이 읽기 쉽다.</p><blockquote><p>YAML data is portable between programming languages.  </p></blockquote><p>YAML 데이터는 프로그래밍 언어 간에 이동이 가능하다.</p><blockquote><p>YAML matches the native data structures of agile languages.  </p></blockquote><p>YAML은 agile 언어의 native data structure와 매치된다.  </p><blockquote><p>YAML’s core type system is based on the requirements of agile languages such as Perl, Python, and Ruby.<br>YAML directly supports both collections (mappings, sequences) and scalars.<br>Support for these common types enables programmers to use their language’s native data structures for YAML manipulation</p></blockquote><p>Perl, Python, Ruby와 같은 agile language에 존재하는 <a href="#Scalar">scalar</a>, <a href="#Collections">collection</a> 타입을 지원해서,<br>프로그래머가 native data structure를 조작하기가 용이하다.  </p><blockquote><p>YAML has a consistent model to support generic tools.</p></blockquote><p>YAML은 parser들을 위해서 <a href="http://yaml.org/spec/1.2/spec.html#id2763452" rel="external nofollow noopener noreferrer" target="_blank">일관적인 모델</a>이 있다.  </p><blockquote><p>YAML supports one-pass processing.</p></blockquote><p>YAML은 <a href="http://yaml.org/spec/1.2/spec.html#id2762107" rel="external nofollow noopener noreferrer" target="_blank">one-pass processing</a>을 지원한다.  </p><blockquote><p>YAML is expressive and extensible.</p></blockquote><p>YAML은 표현력과 확장성이 뛰어나다.  </p><blockquote><p>YAML is easy to implement and use.</p></blockquote><p>YAML은 구현 및 사용이 쉽다.  </p><h4 id="Prior-Art-들어가기에-앞서"><a href="#Prior-Art-들어가기에-앞서" class="headerlink" title="Prior Art(들어가기에 앞서?)"></a>Prior Art(들어가기에 앞서?)</h4><p>HTML의 EOL(End of Line)에 영감을 받아서 sinlge line break는 single space로 해석되고,<br>empty line은 line break character를 뜻한다.<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">asdf:</span> <span class="string">"asdf</span></span><br><span class="line"><span class="string">aass"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">qwer:</span> <span class="string">"qwer</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">zxcv"</span></span><br></pre></td></tr></table></figure></p><p>위와 아래의 결과는 같다.<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">asdf:</span> <span class="string">"asdf aass"</span></span><br><span class="line"><span class="attr">qwer:</span> <span class="string">"qwer\nzxcv"</span></span><br></pre></td></tr></table></figure></p><p>YAML 스펙 문서는 <a href="/2018/08/15/bnf/">BNF 표기법</a>을 사용하고 있기 때문에 BNF 표기법에 대해 조금은 알고 있어야 읽기가 수월하다.</p><h4 id="Node-Kinds"><a href="#Node-Kinds" class="headerlink" title="Node Kinds"></a>Node Kinds</h4><p>일반적인 자료형과 비슷하다는 생각으로 보면 된다.  </p><h5 id="Scalar"><a href="#Scalar" class="headerlink" title="Scalar"></a>Scalar</h5><blockquote><p>The content of a scalar node is an opaque datum that can be presented as a series of zero or more Unicode characters.</p></blockquote><p>스칼라 노드는 0개 이상의 유니코드 문자이다.<br>일반적인 primitive type을 생각하면 편하다.  </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>여기서 b와 0 모두 scalar 노드이다.</p><p>Scalar의 종류는 아래와 같다.  </p><ul><li><a href="#Block-Styles">Block Styles</a><ul><li><a href="http://yaml.org/spec/1.2/spec.html#id2793652" rel="external nofollow noopener noreferrer" target="_blank">Block Scalar Styles</a>  <ul><li><a href="http://yaml.org/spec/1.2/spec.html#id2795688" rel="external nofollow noopener noreferrer" target="_blank">Literal Style</a></li><li><a href="http://yaml.org/spec/1.2/spec.html#id2796251" rel="external nofollow noopener noreferrer" target="_blank">Floded Style</a></li></ul></li></ul></li><li><a href="#Flow-Styles">Flow Styles</a><ul><li><a href="http://yaml.org/spec/1.2/spec.html#id2786942" rel="external nofollow noopener noreferrer" target="_blank">Flow Scalar Styles</a>  <ul><li><a href="http://yaml.org/spec/1.2/spec.html#id2787109" rel="external nofollow noopener noreferrer" target="_blank">Double-Quoted Style</a></li><li><a href="http://yaml.org/spec/1.2/spec.html#id2788097" rel="external nofollow noopener noreferrer" target="_blank">Single-Quoted Style</a></li><li><a href="http://yaml.org/spec/1.2/spec.html#id2788859" rel="external nofollow noopener noreferrer" target="_blank">Plain Style</a></li></ul></li></ul></li></ul><h5 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h5><blockquote><p>When appropriate, it is convenient to consider sequences and mappings together, as collections.</p></blockquote><p><a href="#Sequence">Sequence</a>와 <a href="#Mapping">Mapping</a> 두 개를 합쳐 collections로 퉁친다는 소리 같다.</p><h6 id="Sequence"><a href="#Sequence" class="headerlink" title="Sequence"></a>Sequence</h6><blockquote><p>The content of a sequence node is an ordered series of zero or more nodes.<br>  In particular, a sequence may contain the same node more than once.<br>  It could even contain itself (directly or indirectly).</p></blockquote><p>시퀀스 노드는 0개 이상의 순서가 보장된 노드이다.<br>또한 똑같은 노드를 여러 번 포함할 수 있다.<br>심지어 자기 자신을 포함할 수도 있다.<br>일반적인 list를 생각하면 편하다.  </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">a</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">b</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">a</span></span><br></pre></td></tr></table></figure><p>여기서 <code>-a -b -a</code>를 통틀어 시퀀스 노드라고 부른다.</p><h6 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h6><blockquote><p>The content of a mapping node is an unordered set of key: value node pairs, with the restriction that each of the keys is unique.<br>  YAML places no further restrictions on the nodes.<br>  In particular, keys may be arbitrary nodes, the same node may be used as the value of several key: value pairs, and a mapping could even contain itself as a key or a value (directly or indirectly).</p></blockquote><p>매핑 노드는 순서가 보장되지 않은 key:value 쌍의 집합이다.<br>key는 고유하다는 제한을 빼고는 다른 제한은 있지 않다.  </p><ol><li>키는 임의의 노드일 수도 있고 자기 자신을 포함할 수 있다.<br>-&gt; 키에 문자열을 대부분 넣는데 문자열은 scalar 노드이니까 임의의 노드일 수도 있다고 표현한 게 아닐까?</li><li>동일한 노드를 여러 key:value 쌍의 값으로 사용할 수 있고,<br>-&gt; key는 고유한데, value는 고유하지 않다는 걸 표현한 게 아닐까?  </li><li>자기 자신을 포함할 수 있다. </li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">a:</span> <span class="string">b</span></span><br><span class="line"><span class="attr">c:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">e</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">f</span></span><br></pre></td></tr></table></figure><p><code>a: b</code>, <code>c: -e -f</code> 이 두 개 모두 매핑 노드이다.</p><h4 id="Block-Styles"><a href="#Block-Styles" class="headerlink" title="Block Styles"></a>Block Styles</h4><blockquote><p>In YAML block styles, structure is determined by indentation.<br>  In general, indentation is defined as a zero or more space characters at the start of a line.<br>  To maintain portability, tab characters must not be used in indentation, since different systems treat tabs differently.</p></blockquote><p>구조를 표현할 때 <a href="#Indentation">indentation</a>를 사용한다.<br>라인의 시작점에 존재하는 0개 이상의 <a href="#White-Space-Characters">white space character</a>에 의해 정의된다.<br>하지만 이식성을 고려해서 Tab키는 사용하면 안 된다.<br>시스템들 사이에서 Tab키를 취급하는 방법이 서로 다르기 때문이다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">asdf:</span> <span class="string">qwer</span></span><br><span class="line"><span class="attr">zxcv:</span></span><br><span class="line"><span class="attr">  ssss:</span> <span class="string">dd</span></span><br><span class="line"><span class="attr">  qwer:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">z</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">x</span></span><br><span class="line"><span class="attr">ssdd:</span> <span class="string">cc</span></span><br><span class="line"><span class="comment"># asdf</span></span><br></pre></td></tr></table></figure><p>mapping node에서 key:value 쌍을 구분짓기 위해 <code>:</code>라는 <a href="#Block-Style-Indicator">indicator</a>를 사용한다.<br>또한 sequence node의 value들을 구분짓기 위해 <code>-</code>라는 <a href="#Block-Style-Indicator">indicator</a>를 사용한다.<br>주석을 표시하기 위해서 <code>#</code>라는 <a href="#Block-Style-Indicator">indicator</a>를 사용한다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"asdf"</span>: <span class="string">"qwer"</span>,</span><br><span class="line">  <span class="attr">"zxcv"</span>: &#123;</span><br><span class="line">    <span class="attr">"ssss"</span>: <span class="string">"dd"</span>,</span><br><span class="line">    <span class="attr">"qwer"</span>: [<span class="string">"z"</span>, <span class="string">"x"</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"ssdd"</span>: <span class="string">"cc"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Flow-Styles"><a href="#Flow-Styles" class="headerlink" title="Flow Styles"></a>Flow Styles</h4><blockquote><p>YAML’s flow styles can be thought of as the natural extension of JSON to cover folding long content lines for readability</p></blockquote><p>Flow style은 JSON의 확장 정도로 생각하면 된다.  </p><blockquote><p>flow styles, using explicit indicators rather than indentation to denote scope</p></blockquote><p>flow style은 socope를 나타내기 위해 <a href="#Indentation">indentation</a> 보다 <a href="#Flow-Style-Indicator">indicator</a> 문자를 사용한다.<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="attr">asdf:</span> <span class="string">qwer,</span></span><br><span class="line"><span class="attr">zxcv:</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">ssss:</span> <span class="string">dd,</span></span><br><span class="line"><span class="attr">qwer:</span> <span class="string">[z,</span> <span class="string">x]</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="attr">ssdd:</span> <span class="string">cc</span></span><br><span class="line"><span class="comment">#qqww</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"asdf"</span>: <span class="string">"qwer"</span>,</span><br><span class="line">  <span class="attr">"zxcv"</span>: &#123;</span><br><span class="line">    <span class="attr">"ssss"</span>: <span class="string">"dd"</span>,</span><br><span class="line">    <span class="attr">"qwer"</span>: [<span class="string">"z"</span>, <span class="string">"x"</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"ssdd"</span>: <span class="string">"cc"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Anchor-amp-Alias"><a href="#Anchor-amp-Alias" class="headerlink" title="Anchor &amp; Alias"></a>Anchor &amp; Alias</h4><p>Object의 Reference를 표기하는 방법이다.<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Block Styles</span></span><br><span class="line"><span class="attr">b-anchor:</span> <span class="meta">&amp;name</span> <span class="string">value</span></span><br><span class="line"><span class="attr">b-alias:</span> <span class="meta">*name</span></span><br></pre></td></tr></table></figure></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"b-anchor"</span>: <span class="string">"value"</span>,</span><br><span class="line">  <span class="attr">"b-alias"</span>: <span class="string">"value"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Flow Styles</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="attr">  f-anchor:</span> <span class="meta">&amp;name</span> <span class="string">value,</span></span><br><span class="line"><span class="attr">  f-alias:</span> <span class="meta">*name</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"f-anchor"</span>: <span class="string">"value"</span>,</span><br><span class="line">  <span class="attr">"f-alias"</span>: <span class="string">"value"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Directives"><a href="#Directives" class="headerlink" title="Directives"></a>Directives</h4><blockquote><p>Directives are instructions to the YAML processor.<br>  This specification defines two directives, “YAML” and “TAG”, and reserves all other directives for future use.<br>  There is no way to define private directives. This is intentional.<br>  Directives are a presentation detail and must not be used to convey content information.</p></blockquote><p>Directives는 YAML Processor에게 <code>어떻게 해석해라</code>라고 지시하는 것이다.<br>YAML의 버전을 명시하는 <a href="http://yaml.org/spec/1.2/spec.html#directive/YAML/" rel="external nofollow noopener noreferrer" target="_blank">YAML Directive</a>와<br><a href="http://yaml.org/spec/1.2/spec.html#tag//" rel="external nofollow noopener noreferrer" target="_blank">node tags</a>를 명시하는 <a href="http://yaml.org/spec/1.2/spec.html#directive/TAG/" rel="external nofollow noopener noreferrer" target="_blank">TAG Directive</a>가 있다.<br>맨 첫 번째 줄의 % <a href="#Common-Indicator">Indicator</a>를 통해 표시한다.<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">%YAML</span> <span class="number">1.2</span></span><br></pre></td></tr></table></figure></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">%TAG</span> <span class="string">!yaml!</span> <span class="attr">tag:yaml.org,2002:</span></span><br></pre></td></tr></table></figure><h4 id="Multiple-Documents"><a href="#Multiple-Documents" class="headerlink" title="Multiple Documents"></a>Multiple Documents</h4><blockquote><p>YAML uses three dashes (“—”) to separate directives from document content.<br>  This also serves to signal the start of a document if no directives are present.<br>  Three dots ( “…”) indicate the end of a document without starting a new one, for use in communication channels.</p></blockquote><p><code>---</code> <a href="#Common-Indicator">Indicator</a>로 <a href="#Directives">Directive</a>와 Documnet content를 구분지을 수 있고, document content의 시작이라는 신호도 된다.<br><code>...</code> <a href="#Common-Indicator">Indicator</a>로 <a href="#Directives">Directive</a>와 Document content를 구분지을 수 있고, document content의 끝이라는 신호도 된다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">%YAML</span> <span class="number">1.2</span> <span class="comment"># Directive</span></span><br><span class="line"><span class="bullet">-</span><span class="bullet">--</span> <span class="comment"># Document content begin</span></span><br><span class="line"><span class="attr">a:</span> <span class="string">b</span> <span class="comment"># Document content</span></span><br><span class="line"><span class="attr">c:</span> <span class="string">d</span></span><br><span class="line"><span class="string">...</span> <span class="comment"># Document content end</span></span><br><span class="line"><span class="string">%YAML</span> <span class="number">1.1</span> <span class="comment"># Directive</span></span><br><span class="line"><span class="bullet">-</span><span class="bullet">--</span> <span class="comment"># Document content begin</span></span><br><span class="line"><span class="attr">a:</span> <span class="string">d</span> <span class="comment"># Document content</span></span><br><span class="line"><span class="attr">c:</span> <span class="string">b</span></span><br><span class="line"><span class="string">...</span> <span class="comment"># Document content end</span></span><br></pre></td></tr></table></figure><p>좀 더 다양한 예제를 살펴보자.  </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">local</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">      url:</span> <span class="attr">jdbc:mysql://local</span></span><br></pre></td></tr></table></figure><p>위와 아래는 같다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">local</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">      url:</span> <span class="attr">jdbc:mysql://local</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><p>이번엔 multiple documents를 표현해보자.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">local</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">      url:</span> <span class="attr">jdbc:mysql://local</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">      url:</span> <span class="attr">jdbc:mysql://dev</span></span><br></pre></td></tr></table></figure><p>위와 아래는 같다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">local</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">      url:</span> <span class="attr">jdbc:mysql://local</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">      url:</span> <span class="attr">jdbc:mysql://dev</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><h4 id="Indentation"><a href="#Indentation" class="headerlink" title="Indentation"></a>Indentation</h4><blockquote><p>In YAML block styles, structure is determined by indentation.<br>  In general, indentation is defined as a zero or more space characters at the start of a line.<br>  To maintain portability, tab characters must not be used in indentation, since different systems treat tabs differently.</p></blockquote><p><a href="#Block-Styles">Block Style</a>의 구조는 들여쓰기에 의해 결정된다.<br>라인의 시작점에 존재하는 0개 이상의 <a href="#White-Space-Characters">white space character</a>에 의해 정의된다.<br>하지만 이식성을 고려해서 Tab키는 사용하면 안 된다.<br>시스템들 사이에서 Tab키를 취급하는 방법이 서로 다르기 때문이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s-indent(n) ::= s-space × n</span><br></pre></td></tr></table></figure><blockquote><p>A block style construct is terminated when encountering a line which is less indented than the construct.<br>  Each node must be indented further than its parent node.<br>  All sibling nodes must use the exact same indentation level.<br>  However the content of each sibling node may be further indented independently.</p></blockquote><p><a href="#Block-Styles">Block Style</a>의 구조는 이전 라인보다 더 적은 들여쓰기가 있는 라인을 만나면 끝난다.<br>각각의 노드는 부모 노드보다 더 많은 들여쓰기를 써야만 한다.<br>모든 형제 노드는 같은 들여쓰기 레벨을 써야만 한다.<br>하지만 각 형제 노드의 내용들은 독립적이다.</p><h5 id="White-Space-Characters"><a href="#White-Space-Characters" class="headerlink" title="White Space Characters"></a>White Space Characters</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s-space ::= #x20 /* SP */</span><br><span class="line">s-tab   ::= #x9  /* TAB */</span><br><span class="line">s-white ::= s-space | s-tab</span><br></pre></td></tr></table></figure><p>스페이스와 탭 문자만 white space character로 인식한다.</p><h4 id="Indicator"><a href="#Indicator" class="headerlink" title="Indicator"></a>Indicator</h4><h5 id="Block-Style-Indicator"><a href="#Block-Style-Indicator" class="headerlink" title="Block Style Indicator"></a>Block Style Indicator</h5><p><code>-</code>: <a href="#Block-Styles">Block Style</a>에서 <a href="#Sequence">sequence node</a>임을 나타내는 문자<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c-sequence-entry    ::= “-”</span><br></pre></td></tr></table></figure></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">a</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">b</span></span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"a"</span>, <span class="string">"b"</span>]</span><br></pre></td></tr></table></figure><p><code>:</code>: <a href="#Block-Styles">Block Style</a>에서 <a href="#Mapping">mapping node</a>의 value임을 나타내는 문자<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c-mapping-value ::= “:”</span><br></pre></td></tr></table></figure></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">a:</span> <span class="string">b</span></span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"a"</span>: <span class="string">"b"</span>&#125;</span><br></pre></td></tr></table></figure><p><code>?</code>: <a href="#Block-Styles">Block Style</a>에서 <a href="#Mapping">mapping node</a>의 key임을 알리는 문자<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c-mapping-key   ::= “?”</span><br></pre></td></tr></table></figure></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">?</span> <span class="string">a</span></span><br><span class="line"><span class="string">:</span> <span class="string">b</span></span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"a"</span>: <span class="string">"b"</span>&#125;</span><br></pre></td></tr></table></figure><h5 id="Flow-Style-Indicator"><a href="#Flow-Style-Indicator" class="headerlink" title="Flow Style Indicator"></a>Flow Style Indicator</h5><p><code>{</code>: <a href="#Flow-Styles">Flow Style</a>에서 <a href="#Mapping">mapping node</a>의 시작을 알리는 문자<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c-mapping-start ::= “&#123;”</span><br></pre></td></tr></table></figure></p><p><code>}</code>: <a href="#Flow-Styles">Flow Style</a>에서 <a href="#Mapping">mapping node</a>의 끝을 알리는 문자<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c-mapping-end ::= “&#125;”</span><br></pre></td></tr></table></figure></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="attr">a:</span> <span class="string">b</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"a"</span>: <span class="string">"b"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>[</code>: <a href="#Flow-Styles">Flow Style</a>에서 <a href="#Sequence">sequence node</a>의 시작을 알리는 문자<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c-sequence-start ::= “[”</span><br></pre></td></tr></table></figure></p><p><code>]</code>: <a href="#Flow-Styles">Flow Style</a>에서 <a href="#Sequence">sequence node</a>의 끝을 알리는 문자<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c-sequence-end ::= “]”</span><br></pre></td></tr></table></figure></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[a,</span> <span class="string">b]</span></span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"a"</span>, <span class="string">"b"</span>]</span><br></pre></td></tr></table></figure><p><code>,</code>: <a href="#Flow-Styles">Flow Style</a>에서 <a href="#Collections">collection node</a>의 끝을 알리는 문자<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c-collect-entry ::= “,”</span><br></pre></td></tr></table></figure></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="attr">a:</span> <span class="string">b,</span></span><br><span class="line"><span class="attr">b:</span> <span class="string">[c,</span> <span class="string">d],</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>마지막 <code>[c, d],</code>는 마지막 ,를 생략해서 <code>[c, d]</code>로 써도 똑같다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"a"</span>: <span class="string">"b"</span>,</span><br><span class="line">  <span class="attr">"b"</span>: [<span class="string">"c"</span>, <span class="string">"d"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Common-Indicator"><a href="#Common-Indicator" class="headerlink" title="Common Indicator"></a>Common Indicator</h5><p><code>#</code>: 주석을 나타내는 문자<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c-comment   ::= “#”</span><br></pre></td></tr></table></figure></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">?</span> <span class="string">a</span></span><br><span class="line"><span class="string">:</span> <span class="string">b</span></span><br><span class="line"><span class="comment"># asdf</span></span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"a"</span>: <span class="string">"b"</span>&#125;</span><br></pre></td></tr></table></figure><p><code>&amp;</code>: node의 <a href="#Anchor-amp-Alias">anchor property</a>를 나타내는 문자<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c-anchor    ::= “&amp;”</span><br></pre></td></tr></table></figure></p><p><code>*</code>: <a href="#Anchor-amp-Alias">alias node</a>를 나타내는 문자<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c-anchor    ::= “&amp;”</span><br></pre></td></tr></table></figure></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">anchor:</span> <span class="meta">&amp;name</span> <span class="string">value</span></span><br><span class="line"><span class="attr">alias:</span> <span class="meta">*name</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">anchor:</span> <span class="string">value</span></span><br><span class="line"><span class="attr">alias:</span> <span class="string">value</span></span><br></pre></td></tr></table></figure><p><code>%</code>: <a href="#Directives">Directive</a> Line 임을 나타내는 문자<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c-directive ::= “%”</span><br></pre></td></tr></table></figure></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">%YAML</span> <span class="number">1.2</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">%TAG</span> <span class="string">!yaml!</span> <span class="attr">tag:yaml.org,2002:</span></span><br></pre></td></tr></table></figure><p><code>---</code>: <a href="#Directives">Directive</a> Line이 끝나고 Document content의 시작을 알리는 문자<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c-directives-end    ::= “-” “-” “-”</span><br></pre></td></tr></table></figure></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">%YAML</span> <span class="number">1.2</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">asdf:</span> <span class="string">qwer</span></span><br></pre></td></tr></table></figure><p><code>,,,</code>: Document content가 끝나고 <a href="#Directives">Directive</a> Line과 구분을 짓는 문자<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c-document-end  ::= “.” “.” “.”</span><br></pre></td></tr></table></figure></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">asdf:</span> <span class="string">qwer</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">%YAML</span> <span class="number">1.2</span></span><br></pre></td></tr></table></figure><h3 id="yaml-vs-yml"><a href="#yaml-vs-yml" class="headerlink" title="*.yaml vs *.yml"></a>*.yaml vs *.yml</h3><p><a href="http://yaml.org/faq.html" rel="external nofollow noopener noreferrer" target="_blank">YAML FAQ</a>에서는 *.yaml을 공식 확장자라고 얘기하고 있다.<br>그럼에도 불구하고 *.yml이 있는 이유는 <code>*.html vs *.htm</code> 과도 비슷한 이유일 것 같다.<br>MS-Dos 시절에는 파일의 확장자 길이가 3자로 제한됐었다.<br>그 시절의 영향 때문인지, 3글자 확장자 스타일을 고수하는 사람들 때문에 *.yml이나 *.htm 같은 확장자가 보이는 것 같다. </p><h3 id="yaml-vs-properties"><a href="#yaml-vs-properties" class="headerlink" title="*.yaml vs. *.properties"></a>*.yaml vs. *.properties</h3><p>스프링에서 개발 환경 별로 configuration을 구성할 때 *.properties를 사용하면 아래와 같이 할 수 있다.  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.profiles=dev</span><br><span class="line">spring.datasource.url=jdbc:mysql://</span><br><span class="line">management.endpoints.web.base-path=/</span><br><span class="line">spring.datasource.hikari.minimum-idle=1</span><br><span class="line">spring.datasource.hikari.maximum-pool-size=3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.profiles=prod</span><br><span class="line">spring.datasource.url=jdbc:mysql://</span><br><span class="line">management.endpoints.web.base-path=/</span><br><span class="line">spring.datasource.hikari.minimum-idle=5</span><br><span class="line">spring.datasource.hikari.maximum-pool-size=10</span><br></pre></td></tr></table></figure><p>하지만 *.yaml로 구성하게 되면 아래와 같이 구성할 수 있다.<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:mysql://</span></span><br><span class="line"><span class="attr">    hikari:</span></span><br><span class="line"><span class="attr">      minimum-idle:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">      maximum-pool-size:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line"><span class="attr">  endpoints:</span></span><br><span class="line"><span class="attr">    web:</span></span><br><span class="line"><span class="attr">      base-path:</span> <span class="string">/</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">prod</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:mysql://</span></span><br><span class="line"><span class="attr">    hikari:</span></span><br><span class="line"><span class="attr">      minimum-idle:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">      maximum-pool-size:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line"><span class="attr">  endpoints:</span></span><br><span class="line"><span class="attr">    web:</span></span><br><span class="line"><span class="attr">      base-path:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure></p><p>*.yaml로 했을 때 특징은 다음과 같다.  </p><ol><li>한 파일에서 모든 configuration을 관리할 수 있다.<br>이건 호불호가 갈릴 것 같다.<br>오히려 특정 환경의 설정만 바꾸고 싶은데 똑같은 key들이 환경별로 있어서 헷갈린다는 사람도 있을 것이고,<br>하나의 파일에서 설정을 다 바꿀 수 있어서 여기 저기 다른 파일을 탐색하지 않아서 좋다고 하는 사람도 있을 수 있을 것이다.<br>환경 별로 쪼개서 사용할 수도 있으니 자기 취향 혹은 팀의 가이드라인을 따라 사용하면 될 것 같다.</li><li>비슷한 설정들끼리 뭉친다.<br>동일한 key를 허용하지 않기 때문에 동일한 부모를 가진 key들끼리 뭉치는데, 동일한 부모 아래의 자식이기 때문에 비슷한 설정들끼리 뭉친다.<br>비슷한 설정들끼리 뭉치기 때문에 yaml 파일을 읽을 때 흐름을 파악하기가 훨씬 용이하다.<br>물론 *.properties에서도 비슷한 설정들끼리 뭉쳐놓으면 되는데 설정의 순서를 강제할 순 없기 때문에 yaml이 난 더 좋은 것 같다.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;thumbs.png&quot; alt=&quot;YAML Ain&amp;#39;t Markup Language&quot;&gt;    &lt;/p&gt;
&lt;h2 id=&quot;YAML&quot;&gt;&lt;a href=&quot;#YAML&quot; class=&quot;headerlink&quot; title=&quot;YAML&quot;&gt;&lt;/a&gt;&lt;a 
      
    
    </summary>
    
      <category term="Note" scheme="https://perfectacle.github.io/categories/Note/"/>
    
      <category term="Dev" scheme="https://perfectacle.github.io/categories/Note/Dev/"/>
    
    
      <category term="YAML" scheme="https://perfectacle.github.io/tags/YAML/"/>
    
  </entry>
  
</feed>
